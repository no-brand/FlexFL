/**	     * Parses a {@code MonthDay} from the specified string.	     * <p>	     * This uses {@link ISODateTimeFormat#localDateParser()} or the format {@code --MM-dd}.	     * 	     * @param str  the string to parse, not null	     * @since 2.0	     */	    @FromString	    public static MonthDay parse(String str) {	        return parse(str, PARSER);	    }	
/**	     * Parses a {@code MonthDay} from the specified string using a formatter.	     * 	     * @param str  the string to parse, not null	     * @param formatter  the formatter to use, not null	     * @since 2.0	     */	    public static MonthDay parse(String str, DateTimeFormatter formatter) {	        LocalDate date = formatter.parseLocalDate(str);	        return new MonthDay(date.getMonthOfYear(), date.getDayOfMonth());	    }	
/**	     * Constructs a MonthDay from a <code>java.util.Calendar</code>	     * using exactly the same field values avoiding any time zone effects.	     * <p>	     * Each field is queried from the Calendar and assigned to the MonthDay.	     * <p>	     * This factory method ignores the type of the calendar and always	     * creates a MonthDay with ISO chronology. It is expected that you	     * will only pass in instances of <code>GregorianCalendar</code> however	     * this is not validated.	     *	     * @param calendar  the Calendar to extract fields from	     * @return the created MonthDay, never null	     * @throws IllegalArgumentException if the calendar is null	     * @throws IllegalArgumentException if the monthOfYear or dayOfMonth is invalid for the ISO chronology	     */	    public static MonthDay fromCalendarFields(Calendar calendar) {	        if (calendar == null) {	            throw new IllegalArgumentException("The calendar must not be null");	        }	        return new MonthDay(calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH));	    }	
/**	     * Constructs a MonthDay from a <code>java.util.Date</code>	     * using exactly the same field values avoiding any time zone effects.	     * <p>	     * Each field is queried from the Date and assigned to the MonthDay.	     * <p>	     * This factory method always creates a MonthDay with ISO chronology.	     *	     * @param date  the Date to extract fields from	     * @return the created MonthDay, never null	     * @throws IllegalArgumentException if the calendar is null	     * @throws IllegalArgumentException if the monthOfYear or dayOfMonth is invalid for the ISO chronology	     */	    @SuppressWarnings("deprecation")	    public static MonthDay fromDateFields(Date date) {	        if (date == null) {	            throw new IllegalArgumentException("The date must not be null");	        }	        return new MonthDay(date.getMonth() + 1, date.getDate());	    }	
/**	     * Constructs a MonthDay with the current monthOfYear, using ISOChronology in	     * the default zone to extract the fields.	     * <p>	     * The constructor uses the default time zone, resulting in the local time	     * being initialised. Once the constructor is complete, all further calculations	     * are performed without reference to a time-zone (by switching to UTC).	     */	    public MonthDay() {	        super();	    }	
/**	     * Constructs a MonthDay with the current month-day, using ISOChronology in	     * the specified zone to extract the fields.	     * <p>	     * The constructor uses the specified time zone to obtain the current month-day.	     * Once the constructor is complete, all further calculations	     * are performed without reference to a time-zone (by switching to UTC).	     * 	     * @param zone  the zone to use, null means default zone	     */	    public MonthDay(DateTimeZone zone) {	        super(ISOChronology.getInstance(zone));	    }	
/**	     * Constructs a MonthDay with the current month-day, using the specified chronology	     * and zone to extract the fields.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a time-zone (by switching to UTC).	     *	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    public MonthDay(Chronology chronology) {	        super(chronology);	    }	
/**	     * Constructs a MonthDay extracting the partial fields from the specified	     * milliseconds using the ISOChronology in the default zone.	     * <p>	     * The constructor uses the default time zone, resulting in the local time	     * being initialised. Once the constructor is complete, all further calculations	     * are performed without reference to a time-zone (by switching to UTC).	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     */	    public MonthDay(long instant) {	        super(instant);	    }	
/**	     * Constructs a MonthDay extracting the partial fields from the specified	     * milliseconds using the chronology provided.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a time-zone (by switching to UTC).	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    public MonthDay(long instant, Chronology chronology) {	        super(instant, chronology);	    }	
/**	     * Constructs a MonthDay from an Object that represents some form of time.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.	     * <p>	     * The chronology used will be derived from the object, defaulting to ISO.	     *	     * @param instant  the date-time object, null means now	     * @throws IllegalArgumentException if the instant is invalid	     */	    public MonthDay(Object instant) {	        super(instant, null, ISODateTimeFormat.localDateParser());	    }	
/**	     * Constructs a MonthDay from an Object that represents some form of time,	     * using the specified chronology.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a time-zone (by switching to UTC).	     * The specified chronology overrides that of the object.	     *	     * @param instant  the date-time object, null means now	     * @param chronology  the chronology, null means ISO default	     * @throws IllegalArgumentException if the instant is invalid	     */	    public MonthDay(Object instant, Chronology chronology) {	        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser());	    }	
/**	     * Constructs a MonthDay with specified year and month	     * using <code>ISOChronology</code>.	     * <p>	     * The constructor uses the no time zone initialising the fields as provided.	     * Once the constructor is complete, all further calculations	     * are performed without reference to a time-zone (by switching to UTC).	     *	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     */	    public MonthDay(int monthOfYear, int dayOfMonth) {	        this(monthOfYear, dayOfMonth, null);	    }	
/**	     * Constructs an instance set to the specified monthOfYear and dayOfMonth	     * using the specified chronology, whose zone is ignored.	     * <p>	     * If the chronology is null, <code>ISOChronology</code> is used.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a time-zone (by switching to UTC).	     *	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {	        super(new int[] {monthOfYear, dayOfMonth}, chronology);	    }	
/**	     * Constructs a MonthDay with chronology from this instance and new values.	     *	     * @param partial  the partial to base this new instance on	     * @param values  the new set of values	     */	    MonthDay(MonthDay partial, int[] values) {	        super(partial, values);	    }	
/**	     * Constructs a MonthDay with values from this instance and a new chronology.	     *	     * @param partial  the partial to base this new instance on	     * @param chrono  the new chronology	     */	    MonthDay(MonthDay partial, Chronology chrono) {	        super(partial, chrono);	    }	
/**	     * Gets the number of fields in this partial, which is two.	     * The supported fields are MonthOfYear and DayOfMonth.	     * Note that only these fields may be queried.	     *	     * @return the field count, two	     */	    public int size() {	        return 2;	    }	
/**	     * Gets the field for a specific index in the chronology specified.	     * <p>	     * This method must not use any instance variables.	     * 	     * @param index  the index to retrieve	     * @param chrono  the chronology to use	     * @return the field, never null	     */	    protected DateTimeField getField(int index, Chronology chrono) {	        switch (index) {	        case MONTH_OF_YEAR:	            return chrono.monthOfYear();	        case DAY_OF_MONTH:	            return chrono.dayOfMonth();	        default:	            throw new IndexOutOfBoundsException("Invalid index: " + index);	        }	    }	
/**	     * Gets the field type at the specified index.	     *	     * @param index  the index to retrieve	     * @return the field at the specified index, never null	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public DateTimeFieldType getFieldType(int index) {	        return FIELD_TYPES[index];	    }	
/**	     * Gets an array of the field type of each of the fields that this partial supports.	     * <p>	     * The fields are returned largest to smallest, Month, Day.	     *	     * @return the array of field types (cloned), largest to smallest, never null	     */	    public DateTimeFieldType[] getFieldTypes() {	        return (DateTimeFieldType[]) FIELD_TYPES.clone();	    }	
/**	     * Returns a copy of this month-day with the specified chronology.	     * This instance is immutable and unaffected by this method call.	     * <p>	     * This method retains the values of the fields, thus the result will	     * typically refer to a different instant.	     * <p>	     * The time zone of the specified chronology is ignored, as MonthDay	     * operates without a time zone.	     *	     * @param newChronology  the new chronology, null means ISO	     * @return a copy of this month-day with a different chronology, never null	     * @throws IllegalArgumentException if the values are invalid for the new chronology	     */	    public MonthDay withChronologyRetainFields(Chronology newChronology) {	        newChronology = DateTimeUtils.getChronology(newChronology);	        newChronology = newChronology.withUTC();	        if (newChronology == getChronology()) {	            return this;	        } else {	            MonthDay newMonthDay = new MonthDay(this, newChronology);	            newChronology.validate(newMonthDay, getValues());	            return newMonthDay;	        }	    }	
/**	     * Returns a copy of this month-day with the specified field set to a new value.	     * <p>	     * For example, if the field type is <code>dayOfMonth</code> then the day	     * would be changed in the returned instance.	     * <p>	     * These three lines are equivalent:	     * <pre>	     * MonthDay updated = md.withField(DateTimeFieldType.dayOfMonth(), 6);	     * MonthDay updated = md.dayOfMonth().setCopy(6);	     * MonthDay updated = md.property(DateTimeFieldType.dayOfMonth()).setCopy(6);	     * </pre>	     *	     * @param fieldType  the field type to set, not null	     * @param value  the value to set	     * @return a copy of this instance with the field set, never null	     * @throws IllegalArgumentException if the value is null or invalid	     */	    public MonthDay withField(DateTimeFieldType fieldType, int value) {	        int index = indexOfSupported(fieldType);	        if (value == getValue(index)) {	            return this;	        }	        int[] newValues = getValues();	        newValues = getField(index).set(this, index, newValues, value);	        return new MonthDay(this, newValues);	    }	
/**	     * Returns a copy of this month-day with the value of the specified field increased.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * <p>	     * These three lines are equivalent:	     * <pre>	     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);	     * MonthDay added = md.plusDays(6);	     * MonthDay added = md.dayOfMonth().addToCopy(6);	     * </pre>	     * 	     * @param fieldType  the field type to add to, not null	     * @param amount  the amount to add	     * @return a copy of this instance with the field updated, never null	     * @throws IllegalArgumentException if the value is null or invalid	     * @throws ArithmeticException if the new date-time exceeds the capacity	     */	    public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {	        int index = indexOfSupported(fieldType);	        if (amount == 0) {	            return this;	        }	        int[] newValues = getValues();	        newValues = getField(index).add(this, index, newValues, amount);	        return new MonthDay(this, newValues);	    }	
/**	     * Returns a copy of this month-day with the specified period added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * Fields in the period that aren't present in the partial are ignored.	     * <p>	     * This method is typically used to add multiple copies of complex	     * period instances. Adding one field is best achieved using methods	     * like {@link #withFieldAdded(DurationFieldType, int)}	     * or {@link #plusMonths(int)}.	     * 	     * @param period  the period to add to this one, null means zero	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this instance with the period added, never null	     * @throws ArithmeticException if the new date-time exceeds the capacity	     */	    public MonthDay withPeriodAdded(ReadablePeriod period, int scalar) {	        if (period == null || scalar == 0) {	            return this;	        }	        int[] newValues = getValues();	        for (int i = 0; i < period.size(); i++) {	            DurationFieldType fieldType = period.getFieldType(i);	            int index = indexOf(fieldType);	            if (index >= 0) {	                newValues = getField(index).add(this, index, newValues,	                        FieldUtils.safeMultiply(period.getValue(i), scalar));	            }	        }	        return new MonthDay(this, newValues);	    }	
/**	     * Returns a copy of this month-day with the specified period added.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to add complex period instances.	     * Adding one field is best achieved using methods	     * like {@link #plusMonths(int)}.	     * 	     * @param period  the duration to add to this one, null means zero	     * @return a copy of this instance with the period added, never null	     * @throws ArithmeticException if the new month-day exceeds the capacity	     */	    public MonthDay plus(ReadablePeriod period) {	        return withPeriodAdded(period, 1);	    }	
/**	     * Returns a copy of this month-day plus the specified number of months.	     * <p>	     * This month-day instance is immutable and unaffected by this method call.	     * The month will wrap at the end of the year from December to January.	     * The day will be adjusted to the last valid value if necessary.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * MonthDay added = md.plusMonths(6);	     * MonthDay added = md.plus(Period.months(6));	     * MonthDay added = md.withFieldAdded(DurationFieldType.months(), 6);	     * </pre>	     *	     * @param months  the amount of months to add, may be negative	     * @return the new month-day plus the increased months, never null	     */	    public MonthDay plusMonths(int months) {	        return withFieldAdded(DurationFieldType.months(), months);	    }	
/**	     * Returns a copy of this month-day plus the specified number of days.	     * <p>	     * This month-day instance is immutable and unaffected by this method call.	     * The month will wrap at the end of the year from December to January.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * MonthDay added = md.plusDays(6);	     * MonthDay added = md.plus(Period.days(6));	     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);	     * </pre>	     *	     * @param days  the amount of days to add, may be negative	     * @return the new month-day plus the increased days, never null	     */	    public MonthDay plusDays(int days) {	        return withFieldAdded(DurationFieldType.days(), days);	    }	
/**	     * Returns a copy of this month-day with the specified period taken away.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to subtract complex period instances.	     * Subtracting one field is best achieved using methods	     * like {@link #minusMonths(int)}.	     * 	     * @param period  the period to reduce this instant by	     * @return a copy of this instance with the period taken away, never null	     * @throws ArithmeticException if the new month-day exceeds the capacity	     */	    public MonthDay minus(ReadablePeriod period) {	        return withPeriodAdded(period, -1);	    }	
/**	     * Returns a copy of this month-day minus the specified number of months.	     * <p>	     * This MonthDay instance is immutable and unaffected by this method call.	     * The month will wrap at the end of the year from January to December.	     * The day will be adjusted to the last valid value if necessary.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * MonthDay subtracted = md.minusMonths(6);	     * MonthDay subtracted = md.minus(Period.months(6));	     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.months(), -6);	     * </pre>	     *	     * @param months  the amount of months to subtract, may be negative	     * @return the new month-day minus the increased months, never null	     */	    public MonthDay minusMonths(int months) {	        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));	    }	
/**	     * Returns a copy of this month-day minus the specified number of months.	     * <p>	     * This month-day instance is immutable and unaffected by this method call.	     * The month will wrap at the end of the year from January to December.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * MonthDay subtracted = md.minusDays(6);	     * MonthDay subtracted = md.minus(Period.days(6));	     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.days(), -6);	     * </pre>	     *	     * @param days  the amount of days to subtract, may be negative	     * @return the new month-day minus the increased days, never null	     */	    public MonthDay minusDays(int days) {	        return withFieldAdded(DurationFieldType.days(), FieldUtils.safeNegate(days));	    }	
/**	     * Converts this object to a LocalDate with the same month-day and chronology.	     *	     * @param year  the year to use, valid for chronology	     * @return a LocalDate with the same month-day and chronology, never null	     */	    public LocalDate toLocalDate(int year) {	        return new LocalDate(year, getMonthOfYear(), getDayOfMonth(), getChronology());	    }	
/**	     * Get the month of year field value.	     *	     * @return the month of year	     */	    public int getMonthOfYear() {	        return getValue(MONTH_OF_YEAR);	    }	
/**	     * Get the day of month field value.	     *	     * @return the day of month	     */	    public int getDayOfMonth() {	        return getValue(DAY_OF_MONTH);	    }	
/**	     * Returns a copy of this month-day with the month of year field updated.	     * <p>	     * MonthDay is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * month of year changed.	     *	     * @param monthOfYear  the month of year to set	     * @return a copy of this object with the field set, never null	     * @throws IllegalArgumentException if the value is invalid	     */	    public MonthDay withMonthOfYear(int monthOfYear) {	        int[] newValues = getValues();	        newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);	        return new MonthDay(this, newValues);	    }	
/**	     * Returns a copy of this month-day with the day of month field updated.	     * <p>	     * MonthDay is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * day of month changed.	     *	     * @param dayOfMonth  the day of month to set	     * @return a copy of this object with the field set, never null	     * @throws IllegalArgumentException if the value is invalid	     */	    public MonthDay withDayOfMonth(int dayOfMonth) {	        int[] newValues = getValues();	        newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth);	        return new MonthDay(this, newValues);	    }	
/**	     * Gets the property object for the specified type, which contains	     * many useful methods.	     *	     * @param type  the field type to get the property for	     * @return the property object	     * @throws IllegalArgumentException if the field is null or unsupported	     */	    public Property property(DateTimeFieldType type) {	        return new Property(this, indexOfSupported(type));	    }	
/**	     * Get the month of year field property which provides access to advanced functionality.	     * 	     * @return the month of year property	     */	    public Property monthOfYear() {	        return new Property(this, MONTH_OF_YEAR);	    }	
/**	     * Get the day of month field property which provides access to advanced functionality.	     * 	     * @return the day of month property	     */	    public Property dayOfMonth() {	        return new Property(this, DAY_OF_MONTH);	    }	
/**	     * Output the month-day in ISO8601 format (--MM-dd).	     *	     * @return ISO8601 time formatted string.	     */	    @ToString	    public String toString() {	        List<DateTimeFieldType> fields = new ArrayList<DateTimeFieldType>();	        fields.add(DateTimeFieldType.monthOfYear());	        fields.add(DateTimeFieldType.dayOfMonth());	        return ISODateTimeFormat.forFields(fields, true, true).print(this);	    }	
/**	     * Output the month-day using the specified format pattern.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @see org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern) {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).print(this);	    }	
/**	     * Output the month-day using the specified format pattern.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @param locale  Locale to use, null means default	     * @see org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern, Locale locale) throws IllegalArgumentException {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);	    }	
/**	         * Constructs a property.	         * 	         * @param partial  the partial instance	         * @param fieldIndex  the index in the partial	         */	        Property(MonthDay partial, int fieldIndex) {	            super();	            iBase = partial;	            iFieldIndex = fieldIndex;	        }	
/**	         * Gets the field that this property uses.	         * 	         * @return the field	         */	        public DateTimeField getField() {	            return iBase.getField(iFieldIndex);	        }	
/**	         * Gets the partial that this property belongs to.	         * 	         * @return the partial	         */	        protected ReadablePartial getReadablePartial() {	            return iBase;	        }	
/**	         * Gets the partial that this property belongs to.	         * 	         * @return the partial	         */	        public MonthDay getMonthDay() {	            return iBase;	        }	
/**	         * Gets the value of this field.	         * 	         * @return the field value	         */	        public int get() {	            return iBase.getValue(iFieldIndex);	        }	
/**	         * Adds to the value of this field in a copy of this MonthDay.	         * <p>	         * The value will be added to this field. If the value is too large to be	         * added solely to this field then it will affect larger fields.	         * Smaller fields are unaffected.	         * <p>	         * The MonthDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param valueToAdd  the value to add to the field in the copy	         * @return a copy of the MonthDay with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public MonthDay addToCopy(int valueToAdd) {	            int[] newValues = iBase.getValues();	            newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd);	            return new MonthDay(iBase, newValues);	        }	
/**	         * Adds to the value of this field in a copy of this MonthDay wrapping	         * within this field if the maximum value is reached.	         * <p>	         * The value will be added to this field. If the value is too large to be	         * added solely to this field then it wraps within this field.	         * Other fields are unaffected.	         * <p>	         * For example,	         * <code>--12-30</code> addWrapField one month returns <code>--01-30</code>.	         * <p>	         * The MonthDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param valueToAdd  the value to add to the field in the copy	         * @return a copy of the MonthDay with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public MonthDay addWrapFieldToCopy(int valueToAdd) {	            int[] newValues = iBase.getValues();	            newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd);	            return new MonthDay(iBase, newValues);	        }	
/**	         * Sets this field in a copy of the MonthDay.	         * <p>	         * The MonthDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param value  the value to set the field in the copy to	         * @return a copy of the MonthDay with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public MonthDay setCopy(int value) {	            int[] newValues = iBase.getValues();	            newValues = getField().set(iBase, iFieldIndex, newValues, value);	            return new MonthDay(iBase, newValues);	        }	
/**	         * Sets this field in a copy of the MonthDay to a parsed text value.	         * <p>	         * The MonthDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param text  the text value to set	         * @param locale  optional locale to use for selecting a text symbol	         * @return a copy of the MonthDay with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public MonthDay setCopy(String text, Locale locale) {	            int[] newValues = iBase.getValues();	            newValues = getField().set(iBase, iFieldIndex, newValues, text, locale);	            return new MonthDay(iBase, newValues);	        }	
/**	         * Sets this field in a copy of the MonthDay to a parsed text value.	         * <p>	         * The MonthDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param text  the text value to set	         * @return a copy of the MonthDay with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public MonthDay setCopy(String text) {	            return setCopy(text, null);	        }	
/**	     * Parses a {@code LocalDate} from the specified string.	     * <p>	     * This uses {@link ISODateTimeFormat#localDateParser()}.	     * 	     * @param str  the string to parse, not null	     * @since 2.0	     */	    @FromString	    public static LocalDate parse(String str) {	        return parse(str, ISODateTimeFormat.localDateParser());	    }	
/**	     * Parses a {@code LocalDate} from the specified string using a formatter.	     * 	     * @param str  the string to parse, not null	     * @param formatter  the formatter to use, not null	     * @since 2.0	     */	    public static LocalDate parse(String str, DateTimeFormatter formatter) {	        return formatter.parseLocalDate(str);	    }	
/**	     * Constructs a LocalDate from a <code>java.util.Calendar</code>	     * using exactly the same field values.	     * <p>	     * Each field is queried from the Calendar and assigned to the LocalDate.	     * This is useful if you have been using the Calendar as a local date,	     * ignoring the zone.	     * <p>	     * One advantage of this method is that this method is unaffected if the	     * version of the time zone data differs between the JDK and Joda-Time.	     * That is because the local field values are transferred, calculated using	     * the JDK time zone data and without using the Joda-Time time zone data.	     * <p>	     * This factory method ignores the type of the calendar and always	     * creates a LocalDate with ISO chronology. It is expected that you	     * will only pass in instances of <code>GregorianCalendar</code> however	     * this is not validated.	     *	     * @param calendar  the Calendar to extract fields from	     * @return the created LocalDate	     * @throws IllegalArgumentException if the calendar is null	     * @throws IllegalArgumentException if the date is invalid for the ISO chronology	     */	    public static LocalDate fromCalendarFields(Calendar calendar) {	        if (calendar == null) {	            throw new IllegalArgumentException("The calendar must not be null");	        }	        return new LocalDate(	            calendar.get(Calendar.YEAR),	            calendar.get(Calendar.MONTH) + 1,	            calendar.get(Calendar.DAY_OF_MONTH)	        );	    }	
/**	     * Constructs a LocalDate from a <code>java.util.Date</code>	     * using exactly the same field values.	     * <p>	     * Each field is queried from the Date and assigned to the LocalDate.	     * This is useful if you have been using the Date as a local date,	     * ignoring the zone.	     * <p>	     * One advantage of this method is that this method is unaffected if the	     * version of the time zone data differs between the JDK and Joda-Time.	     * That is because the local field values are transferred, calculated using	     * the JDK time zone data and without using the Joda-Time time zone data.	     * <p>	     * This factory method always creates a LocalDate with ISO chronology.	     *	     * @param date  the Date to extract fields from	     * @return the created LocalDate	     * @throws IllegalArgumentException if the calendar is null	     * @throws IllegalArgumentException if the date is invalid for the ISO chronology	     */	    @SuppressWarnings("deprecation")	    public static LocalDate fromDateFields(Date date) {	        if (date == null) {	            throw new IllegalArgumentException("The date must not be null");	        }	        return new LocalDate(	            date.getYear() + 1900,	            date.getMonth() + 1,	            date.getDate()	        );	    }	
/**	     * Constructs an instance set to the current local time evaluated using	     * ISO chronology in the default zone.	     * <p>	     * Once the constructor is completed, the zone is no longer used.	     */	    public LocalDate() {	        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());	    }	
/**	     * Constructs an instance set to the current local time evaluated using	     * ISO chronology in the specified zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     * Once the constructor is completed, the zone is no longer used.	     *	     * @param zone  the time zone, null means default zone	     */	    public LocalDate(DateTimeZone zone) {	        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));	    }	
/**	     * Constructs an instance set to the current local time evaluated using	     * specified chronology.	     * <p>	     * If the chronology is null, ISO chronology in the default time zone is used.	     * Once the constructor is completed, the zone is no longer used.	     *	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public LocalDate(Chronology chronology) {	        this(DateTimeUtils.currentTimeMillis(), chronology);	    }	
/**	     * Constructs an instance set to the local time defined by the specified	     * instant evaluated using ISO chronology in the default zone.	     * <p>	     * Once the constructor is completed, the zone is no longer used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     */	    public LocalDate(long instant) {	        this(instant, ISOChronology.getInstance());	    }	
/**	     * Constructs an instance set to the local time defined by the specified	     * instant evaluated using ISO chronology in the specified zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     * Once the constructor is completed, the zone is no longer used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param zone  the time zone, null means default zone	     */	    public LocalDate(long instant, DateTimeZone zone) {	        this(instant, ISOChronology.getInstance(zone));	    }	
/**	     * Constructs an instance set to the local time defined by the specified	     * instant evaluated using the specified chronology.	     * <p>	     * If the chronology is null, ISO chronology in the default zone is used.	     * Once the constructor is completed, the zone is no longer used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public LocalDate(long instant, Chronology chronology) {	        chronology = DateTimeUtils.getChronology(chronology);	        	        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);	        chronology = chronology.withUTC();	        iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);	        iChronology = chronology;	    }	
/**	     * Constructs an instance from an Object that represents a datetime.	     * The time zone will be retrieved from the object if possible,	     * otherwise the default time zone will be used.	     * <p>	     * If the object contains no chronology, <code>ISOChronology</code> is used.	     * Once the constructor is completed, the zone is no longer used.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePartial, ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.	     * The default String converter ignores the zone and only parses the field values.	     *	     * @param instant  the datetime object	     * @throws IllegalArgumentException if the instant is invalid	     */	    public LocalDate(Object instant) {	        this(instant, (Chronology) null);	    }	
/**	     * Constructs an instance from an Object that represents a datetime,	     * forcing the time zone to that specified.	     * <p>	     * If the object contains no chronology, <code>ISOChronology</code> is used.	     * If the specified time zone is null, the default zone is used.	     * Once the constructor is completed, the zone is no longer used.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePartial, ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.	     * The default String converter ignores the zone and only parses the field values.	     *	     * @param instant  the datetime object	     * @param zone  the time zone	     * @throws IllegalArgumentException if the instant is invalid	     */	    public LocalDate(Object instant, DateTimeZone zone) {	        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);	        Chronology chronology = converter.getChronology(instant, zone);	        chronology = DateTimeUtils.getChronology(chronology);	        iChronology = chronology.withUTC();	        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());	        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);	    }	
/**	     * Constructs an instance from an Object that represents a datetime,	     * using the specified chronology.	     * <p>	     * If the chronology is null, ISO in the default time zone is used.	     * Once the constructor is completed, the zone is no longer used.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePartial, ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.	     * The default String converter ignores the zone and only parses the field values.	     *	     * @param instant  the datetime object	     * @param chronology  the chronology	     * @throws IllegalArgumentException if the instant is invalid	     */	    public LocalDate(Object instant, Chronology chronology) {	        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);	        chronology = converter.getChronology(instant, chronology);	        chronology = DateTimeUtils.getChronology(chronology);	        iChronology = chronology.withUTC();	        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());	        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);	    }	
/**	     * Constructs an instance set to the specified date and time	     * using <code>ISOChronology</code>.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     */	    public LocalDate(	            int year,	            int monthOfYear,	            int dayOfMonth) {	        this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC());	    }	
/**	     * Constructs an instance set to the specified date and time	     * using the specified chronology, whose zone is ignored.	     * <p>	     * If the chronology is null, <code>ISOChronology</code> is used.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public LocalDate(	            int year,	            int monthOfYear,	            int dayOfMonth,	            Chronology chronology) {	        super();	        chronology = DateTimeUtils.getChronology(chronology).withUTC();	        long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);	        iChronology = chronology;	        iLocalMillis = instant;	    }	
/**	     * Gets the number of fields in this partial, which is three.	     * The supported fields are Year, MonthOfYear and DayOfMonth.	     * Note that all fields from day and above may in fact be queried via	     * other methods.	     *	     * @return the field count, three	     */	    public int size() {	        return 3;	    }	
/**	     * Gets the field for a specific index in the chronology specified.	     * <p>	     * This method must not use any instance variables.	     *	     * @param index  the index to retrieve	     * @param chrono  the chronology to use	     * @return the field	     */	    protected DateTimeField getField(int index, Chronology chrono) {	        switch (index) {	            case YEAR:	                return chrono.year();	            case MONTH_OF_YEAR:	                return chrono.monthOfYear();	            case DAY_OF_MONTH:	                return chrono.dayOfMonth();	            default:	                throw new IndexOutOfBoundsException("Invalid index: " + index);	        }	    }	
/**	     * Gets the value of the field at the specifed index.	     * <p>	     * This method is required to support the <code>ReadablePartial</code>	     * interface. The supported fields are Year, MonthOfYear and DayOfMonth.	     * Note that all fields from day and above may in fact be queried via	     * other methods.	     *	     * @param index  the index, zero to two	     * @return the value	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public int getValue(int index) {	        switch (index) {	            case YEAR:	                return getChronology().year().get(getLocalMillis());	            case MONTH_OF_YEAR:	                return getChronology().monthOfYear().get(getLocalMillis());	            case DAY_OF_MONTH:	                return getChronology().dayOfMonth().get(getLocalMillis());	            default:	                throw new IndexOutOfBoundsException("Invalid index: " + index);	        }	    }	
/**	     * Get the value of one of the fields of a datetime.	     * <p>	     * This method gets the value of the specified field.	     * For example:	     * <pre>	     * LocalDate dt = LocalDate.nowDefaultZone();	     * int year = dt.get(DateTimeFieldType.year());	     * </pre>	     *	     * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null	     * @return the value of that field	     * @throws IllegalArgumentException if the field type is null or unsupported	     */	    public int get(DateTimeFieldType fieldType) {	        if (fieldType == null) {	            throw new IllegalArgumentException("The DateTimeFieldType must not be null");	        }	        if (isSupported(fieldType) == false) {	            throw new IllegalArgumentException("Field '" + fieldType + "' is not supported");	        }	        return fieldType.getField(getChronology()).get(getLocalMillis());	    }	
/**	     * Checks if the field type specified is supported by this	     * local date and chronology.	     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.	     *	     * @param type  a field type, usually obtained from DateTimeFieldType	     * @return true if the field type is supported	     */	    public boolean isSupported(DateTimeFieldType type) {	        if (type == null) {	            return false;	        }	        DurationFieldType durType = type.getDurationType();	        if (DATE_DURATION_TYPES.contains(durType) ||	                durType.getField(getChronology()).getUnitMillis() >=	                    getChronology().days().getUnitMillis()) {	            return type.getField(getChronology()).isSupported();	        }	        return false;	    }	
/**	     * Checks if the duration type specified is supported by this	     * local date and chronology.	     *	     * @param type  a duration type, usually obtained from DurationFieldType	     * @return true if the field type is supported	     */	    public boolean isSupported(DurationFieldType type) {	        if (type == null) {	            return false;	        }	        DurationField field = type.getField(getChronology());	        if (DATE_DURATION_TYPES.contains(type) ||	            field.getUnitMillis() >= getChronology().days().getUnitMillis()) {	            return field.isSupported();	        }	        return false;	    }	
/**	     * Gets the local milliseconds from the Java epoch	     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).	     * 	     * @return the number of milliseconds since 1970-01-01T00:00:00	     * @since 1.5 (previously private)	     */	    protected long getLocalMillis() {	        return iLocalMillis;	    }	
/**	     * Gets the chronology of the date.	     * 	     * @return the Chronology that the date is using	     */	    public Chronology getChronology() {	        return iChronology;	    }	
/**	     * Compares this ReadablePartial with another returning true if the chronology,	     * field types and values are equal.	     *	     * @param partial  an object to check against	     * @return true if fields and values are equal	     */	    public boolean equals(Object partial) {	        // override to perform faster	        if (this == partial) {	            return true;	        }	        if (partial instanceof LocalDate) {	            LocalDate other = (LocalDate) partial;	            if (iChronology.equals(other.iChronology)) {	                return iLocalMillis == other.iLocalMillis;	            }	        }	        return super.equals(partial);	    }	
/**	     * Gets a hash code for the instant as defined in <code>ReadablePartial</code>.	     *	     * @return a suitable hash code	     */	    public int hashCode() {	        // override for performance	        int hash = iHash;	        if (hash == 0) {	            hash = iHash = super.hashCode();	        }	        return hash;	    }	
/**	     * Compares this partial with another returning an integer	     * indicating the order.	     * <p>	     * The fields are compared in order, from largest to smallest.	     * The first field that is non-equal is used to determine the result.	     * <p>	     * The specified object must be a partial instance whose field types	     * match those of this partial.	     * <p>	     * NOTE: This implementation violates the Comparable contract.	     * This method will accept any instance of ReadablePartial as input.	     * However, it is possible that some implementations of ReadablePartial	     * exist that do not extend AbstractPartial, and thus will throw a	     * ClassCastException if compared in the opposite direction.	     * The cause of this problem is that ReadablePartial doesn't define	     * the compareTo() method, however we can't change that until v2.0.	     *	     * @param partial  an object to check against	     * @return negative if this is less, zero if equal, positive if greater	     * @throws ClassCastException if the partial is the wrong class	     *  or if it has field types that don't match	     * @throws NullPointerException if the partial is null	     */	    public int compareTo(ReadablePartial partial) {	        // override to perform faster	        if (this == partial) {	            return 0;	        }	        if (partial instanceof LocalDate) {	            LocalDate other = (LocalDate) partial;	            if (iChronology.equals(other.iChronology)) {	                return (iLocalMillis < other.iLocalMillis ? -1 :	                            (iLocalMillis == other.iLocalMillis ? 0 : 1));		            }	        }	        return super.compareTo(partial);	    }	
/**	     * Converts this LocalDate to a full datetime at the earliest valid time	     * for the date using the default time zone.	     * <p>	     * The time will normally be midnight, as that is the earliest time on	     * any given day. However, in some time zones when Daylight Savings Time	     * starts, there is no midnight because time jumps from 11:59 to 01:00.	     * This method handles that situation by returning 01:00 on that date.	     * <p>	     * This instance is immutable and unaffected by this method call.	     * 	     * @return this date as a datetime at the start of the day	     * @since 1.5	     */	    public DateTime toDateTimeAtStartOfDay() {	        return toDateTimeAtStartOfDay(null);	    }	
/**	     * Converts this LocalDate to a full datetime at the earliest valid time	     * for the date using the specified time zone.	     * <p>	     * The time will normally be midnight, as that is the earliest time on	     * any given day. However, in some time zones when Daylight Savings Time	     * starts, there is no midnight because time jumps from 11:59 to 01:00.	     * This method handles that situation by returning 01:00 on that date.	     * <p>	     * This method uses the chronology from this instance plus the time zone	     * specified.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param zone  the zone to use, null means default zone	     * @return this date as a datetime at the start of the day	     * @since 1.5	     */	    public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) {	        zone = DateTimeUtils.getZone(zone);	        Chronology chrono = getChronology().withZone(zone);	        long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR;	        long instant = zone.convertLocalToUTC(localMillis, false);	        instant = chrono.dayOfMonth().roundFloor(instant);	        return new DateTime(instant, chrono);	    }	
/**	     * Converts this LocalDate to a full datetime at midnight using the default	     * time zone.	     * <p>	     * This method will throw an exception if the default time zone switches	     * to Daylight Savings Time at midnight and this LocalDate represents	     * that switchover date. The problem is that there is no such time as	     * midnight on the required date, and as such an exception is thrown.	     * <p>	     * This instance is immutable and unaffected by this method call.	     * 	     * @return this date as a datetime at midnight	     * @deprecated Use {@link #toDateTimeAtStartOfDay()} which won't throw an exception	     */	    @Deprecated	    public DateTime toDateTimeAtMidnight() {	        return toDateTimeAtMidnight(null);	    }	
/**	     * Converts this LocalDate to a full datetime at midnight using the	     * specified time zone.	     * <p>	     * This method will throw an exception if the time zone switches	     * to Daylight Savings Time at midnight and this LocalDate represents	     * that switchover date. The problem is that there is no such time as	     * midnight on the required date, and as such an exception is thrown.	     * <p>	     * This method uses the chronology from this instance plus the time zone	     * specified.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param zone  the zone to use, null means default zone	     * @return this date as a datetime at midnight	     * @deprecated Use {@link #toDateTimeAtStartOfDay(DateTimeZone)} which won't throw an exception	     */	    @Deprecated	    public DateTime toDateTimeAtMidnight(DateTimeZone zone) {	        zone = DateTimeUtils.getZone(zone);	        Chronology chrono = getChronology().withZone(zone);	        return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);	    }	
/**	     * Converts this LocalDate to a full datetime using the default time zone	     * setting the date fields from this instance and the time fields from	     * the current time.	     * <p>	     * This method will throw an exception if the datetime that would be	     * created does not exist when the time zone is taken into account.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @return this date as a datetime with the time as the current time	     */	    public DateTime toDateTimeAtCurrentTime() {	        return toDateTimeAtCurrentTime(null);	    }	
/**	     * Converts this LocalDate to a full datetime using the specified time zone	     * setting the date fields from this instance and the time fields from	     * the current time.	     * <p>	     * This method uses the chronology from this instance plus the time zone	     * specified.	     * <p>	     * This method will throw an exception if the datetime that would be	     * created does not exist when the time zone is taken into account.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param zone  the zone to use, null means default zone	     * @return this date as a datetime with the time as the current time	     */	    public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {	        zone = DateTimeUtils.getZone(zone);	        Chronology chrono = getChronology().withZone(zone);	        long instantMillis = DateTimeUtils.currentTimeMillis();	        long resolved = chrono.set(this, instantMillis);	        return new DateTime(resolved, chrono);	    }	
/**	     * Converts this LocalDate to a DateMidnight in the default time zone.	     * <p>	     * As from v1.5, you are recommended to avoid DateMidnight and use	     * {@link #toDateTimeAtStartOfDay()} instead because of the exception	     * detailed below.	     * <p>	     * This method will throw an exception if the default time zone switches	     * to Daylight Savings Time at midnight and this LocalDate represents	     * that switchover date. The problem is that there is no such time as	     * midnight on the required date, and as such an exception is thrown.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @return the DateMidnight instance in the default zone	     */	    public DateMidnight toDateMidnight() {	        return toDateMidnight(null);	    }	
/**	     * Converts this LocalDate to a DateMidnight.	     * <p>	     * As from v1.5, you are recommended to avoid DateMidnight and use	     * {@link #toDateTimeAtStartOfDay()} instead because of the exception	     * detailed below.	     * <p>	     * This method will throw an exception if the time zone switches	     * to Daylight Savings Time at midnight and this LocalDate represents	     * that switchover date. The problem is that there is no such time as	     * midnight on the required date, and as such an exception is thrown.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param zone  the zone to get the DateMidnight in, null means default zone	     * @return the DateMidnight instance	     */	    public DateMidnight toDateMidnight(DateTimeZone zone) {	        zone = DateTimeUtils.getZone(zone);	        Chronology chrono = getChronology().withZone(zone);	        return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);	    }	
/**	     * Converts this object to a LocalDateTime using a LocalTime to fill in	     * the missing fields.	     * <p>	     * The resulting chronology is determined by the chronology of this	     * LocalDate. The chronology of the time must also match.	     * If the time is null an exception is thrown.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param time  the time of day to use, must not be null	     * @return the LocalDateTime instance	     * @throws IllegalArgumentException if the time is null	     * @throws IllegalArgumentException if the chronology of the time does not match	     * @since 1.5	     */	    public LocalDateTime toLocalDateTime(LocalTime time) {	        if (time == null) {	            throw new IllegalArgumentException("The time must not be null");	        }	        if (getChronology() != time.getChronology()) {	            throw new IllegalArgumentException("The chronology of the time does not match");	        }	        long localMillis = getLocalMillis() + time.getLocalMillis();	        return new LocalDateTime(localMillis, getChronology());	    }	
/**	     * Converts this object to a DateTime using a LocalTime to fill in the	     * missing fields and using the default time zone.	     * <p>	     * The resulting chronology is determined by the chronology of this	     * LocalDate. The chronology of the time must match.	     * If the time is null, the current time in the date's chronology is used.	     * <p>	     * This method will throw an exception if the datetime that would be	     * created does not exist when the time zone is taken into account.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param time  the time of day to use, null means current time	     * @return the DateTime instance	     * @throws IllegalArgumentException if the chronology of the time does not match	     */	    public DateTime toDateTime(LocalTime time) {	        return toDateTime(time, null);	    }	
/**	     * Converts this object to a DateTime using a LocalTime to fill in the	     * missing fields.	     * <p>	     * The resulting chronology is determined by the chronology of this	     * LocalDate plus the time zone. The chronology of the time must match.	     * If the time is null, the current time in the date's chronology is used.	     * <p>	     * This method will throw an exception if the datetime that would be	     * created does not exist when the time zone is taken into account.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param time  the time of day to use, null means current time	     * @param zone  the zone to get the DateTime in, null means default	     * @return the DateTime instance	     * @throws IllegalArgumentException if the chronology of the time does not match	     */	    public DateTime toDateTime(LocalTime time, DateTimeZone zone) {	        if (time != null && getChronology() != time.getChronology()) {	            throw new IllegalArgumentException("The chronology of the time does not match");	        }	        Chronology chrono = getChronology().withZone(zone);	        long instant = DateTimeUtils.currentTimeMillis();	        instant = chrono.set(this, instant);	        if (time != null) {	            instant = chrono.set(time, instant);	        }	        return new DateTime(instant, chrono);	    }	
/**	     * Converts this object to an Interval representing the whole day	     * in the default time zone.	     * <p>	     * The interval may have more or less than 24 hours if this is a daylight	     * savings cutover date.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @return a interval over the day	     */	    public Interval toInterval() {	        return toInterval(null);	    }	
/**	     * Converts this object to an Interval representing the whole day.	     * <p>	     * The interval may have more or less than 24 hours if this is a daylight	     * savings cutover date.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param zone  the zone to get the Interval in, null means default	     * @return a interval over the day	     */	    public Interval toInterval(DateTimeZone zone) {	        zone = DateTimeUtils.getZone(zone);	        DateTime start = toDateTimeAtStartOfDay(zone);	        DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone);	        return new Interval(start, end);	    }	
/**	     * Get the date time as a <code>java.util.Date</code>.	     * <p>	     * The <code>Date</code> object created has exactly the same year, month and day	     * as this date. The time will be set to the earliest valid time for that date.	     * <p>	     * Converting to a JDK Date is full of complications as the JDK Date constructor	     * doesn't behave as you might expect around DST transitions. This method works	     * by taking a first guess and then adjusting the JDK date until it has the	     * earliest valid instant. This also handles the situation where the JDK time	     * zone data differs from the Joda-Time time zone data.	     *	     * @return a Date initialised with this date, never null	     * @since 2.0	     */	    @SuppressWarnings("deprecation")	    public Date toDate() {	        int dom = getDayOfMonth();	        Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom);	        LocalDate check = LocalDate.fromDateFields(date);	        if (check.isBefore(this)) {	            // DST gap (no midnight)	            // move forward in units of one hour until date correct	            while (check.equals(this) == false) {	                date.setTime(date.getTime() + 3600000);	                check = LocalDate.fromDateFields(date);	            }	            // move back in units of one second until date wrong	            while (date.getDate() == dom) {	                date.setTime(date.getTime() - 1000);	            }	            // fix result	            date.setTime(date.getTime() + 1000);	        } else if (check.equals(this)) {	            // check for DST overlap (two midnights)	            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());	            if (earlier.getDate() == dom) {	                date = earlier;	            }	        }	        return date;	    }	
/**	     * Returns a copy of this date with different local millis.	     * <p>	     * The returned object will be a new instance of the same type.	     * Only the millis will change, the chronology is kept.	     * The returned object will be either be a new instance or <code>this</code>.	     *	     * @param newMillis  the new millis, from 1970-01-01T00:00:00	     * @return a copy of this date with different millis	     */	    LocalDate withLocalMillis(long newMillis) {	        newMillis = iChronology.dayOfMonth().roundFloor(newMillis);	        return (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));	    }	
/**	     * Returns a copy of this date with the partial set of fields replacing	     * those from this instance.	     * <p>	     * For example, if the partial contains a year and a month then those two	     * fields will be changed in the returned instance.	     * Unsupported fields are ignored.	     * If the partial is null, then <code>this</code> is returned.	     *	     * @param partial  the partial set of fields to apply to this date, null ignored	     * @return a copy of this date with a different set of fields	     * @throws IllegalArgumentException if any value is invalid	     */	    public LocalDate withFields(ReadablePartial partial) {	        if (partial == null) {	            return this;	        }	        return withLocalMillis(getChronology().set(partial, getLocalMillis()));	    }	
/**	     * Returns a copy of this date with the specified field set to a new value.	     * <p>	     * For example, if the field type is <code>monthOfYear</code> then the	     * month of year field will be changed in the returned instance.	     * If the field type is null, then <code>this</code> is returned.	     * <p>	     * These two lines are equivalent:	     * <pre>	     * LocalDate updated = dt.withDayOfMonth(6);	     * LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);	     * </pre>	     *	     * @param fieldType  the field type to set, not null	     * @param value  the value to set	     * @return a copy of this date with the field set	     * @throws IllegalArgumentException if the field is null or unsupported	     */	    public LocalDate withField(DateTimeFieldType fieldType, int value) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field must not be null");	        }	        if (isSupported(fieldType) == false) {	            throw new IllegalArgumentException("Field '" + fieldType + "' is not supported");	        }	        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this date with the value of the specified field increased.	     * <p>	     * If the addition is zero or the field is null, then <code>this</code> is returned.	     * <p>	     * These three lines are equivalent:	     * <pre>	     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);	     * LocalDate added = dt.plusYears(6);	     * LocalDate added = dt.plus(Period.years(6));	     * </pre>	     *	     * @param fieldType  the field type to add to, not null	     * @param amount  the amount to add	     * @return a copy of this date with the field updated	     * @throws IllegalArgumentException if the field is null or unsupported	     * @throws ArithmeticException if the result exceeds the internal capacity	     */	    public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field must not be null");	        }	        if (isSupported(fieldType) == false) {	            throw new IllegalArgumentException("Field '" + fieldType + "' is not supported");	        }	        if (amount == 0) {	            return this;	        }	        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this date with the specified period added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * <p>	     * This method is typically used to add multiple copies of complex	     * period instances. Adding one field is best achieved using methods	     * like {@link #withFieldAdded(DurationFieldType, int)}	     * or {@link #plusYears(int)}.	     * <p>	     * Unsupported time fields are ignored, thus adding a period of 24 hours	     * will not have any effect.	     *	     * @param period  the period to add to this one, null means zero	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this date with the period added	     * @throws ArithmeticException if the result exceeds the internal capacity	     */	    public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) {	        if (period == null || scalar == 0) {	            return this;	        }	        long instant = getLocalMillis();	        Chronology chrono = getChronology();	        for (int i = 0; i < period.size(); i++) {	            long value = FieldUtils.safeMultiply(period.getValue(i), scalar);	            DurationFieldType type = period.getFieldType(i);	            if (isSupported(type)) {	                instant = type.getField(chrono).add(instant, value);	            }	        }	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this date with the specified period added.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to add complex period instances.	     * Adding one field is best achieved using methods	     * like {@link #plusYears(int)}.	     * <p>	     * Unsupported time fields are ignored, thus adding a period of 24 hours	     * will not have any effect.	     *	     * @param period  the period to add to this one, null means zero	     * @return a copy of this date with the period added	     * @throws ArithmeticException if the result exceeds the internal capacity	     */	    public LocalDate plus(ReadablePeriod period) {	        return withPeriodAdded(period, 1);	    }	
/**	     * Returns a copy of this date plus the specified number of years.	     * <p>	     * This LocalDate instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDate added = dt.plusYears(6);	     * LocalDate added = dt.plus(Period.years(6));	     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);	     * </pre>	     *	     * @param years  the amount of years to add, may be negative	     * @return the new LocalDate plus the increased years	     */	    public LocalDate plusYears(int years) {	        if (years == 0) {	            return this;	        }	        long instant = getChronology().years().add(getLocalMillis(), years);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this date plus the specified number of months.	     * <p>	     * This LocalDate instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDate added = dt.plusMonths(6);	     * LocalDate added = dt.plus(Period.months(6));	     * LocalDate added = dt.withFieldAdded(DurationFieldType.months(), 6);	     * </pre>	     *	     * @param months  the amount of months to add, may be negative	     * @return the new LocalDate plus the increased months	     */	    public LocalDate plusMonths(int months) {	        if (months == 0) {	            return this;	        }	        long instant = getChronology().months().add(getLocalMillis(), months);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this date plus the specified number of weeks.	     * <p>	     * This LocalDate instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDate added = dt.plusWeeks(6);	     * LocalDate added = dt.plus(Period.weeks(6));	     * LocalDate added = dt.withFieldAdded(DurationFieldType.weeks(), 6);	     * </pre>	     *	     * @param weeks  the amount of weeks to add, may be negative	     * @return the new LocalDate plus the increased weeks	     */	    public LocalDate plusWeeks(int weeks) {	        if (weeks == 0) {	            return this;	        }	        long instant = getChronology().weeks().add(getLocalMillis(), weeks);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this date plus the specified number of days.	     * <p>	     * This LocalDate instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDate added = dt.plusDays(6);	     * LocalDate added = dt.plus(Period.days(6));	     * LocalDate added = dt.withFieldAdded(DurationFieldType.days(), 6);	     * </pre>	     *	     * @param days  the amount of days to add, may be negative	     * @return the new LocalDate plus the increased days	     */	    public LocalDate plusDays(int days) {	        if (days == 0) {	            return this;	        }	        long instant = getChronology().days().add(getLocalMillis(), days);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this date with the specified period taken away.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to subtract complex period instances.	     * Subtracting one field is best achieved using methods	     * like {@link #minusYears(int)}.	     * <p>	     * Unsupported time fields are ignored, thus subtracting a period of 24 hours	     * will not have any effect.	     *	     * @param period  the period to reduce this instant by	     * @return a copy of this LocalDate with the period taken away	     * @throws ArithmeticException if the result exceeds the internal capacity	     */	    public LocalDate minus(ReadablePeriod period) {	        return withPeriodAdded(period, -1);	    }	
/**	     * Returns a copy of this date minus the specified number of years.	     * <p>	     * This LocalDate instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDate subtracted = dt.minusYears(6);	     * LocalDate subtracted = dt.minus(Period.years(6));	     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);	     * </pre>	     *	     * @param years  the amount of years to subtract, may be negative	     * @return the new LocalDate minus the increased years	     */	    public LocalDate minusYears(int years) {	        if (years == 0) {	            return this;	        }	        long instant = getChronology().years().subtract(getLocalMillis(), years);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this date minus the specified number of months.	     * <p>	     * This LocalDate instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDate subtracted = dt.minusMonths(6);	     * LocalDate subtracted = dt.minus(Period.months(6));	     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);	     * </pre>	     *	     * @param months  the amount of months to subtract, may be negative	     * @return the new LocalDate minus the increased months	     */	    public LocalDate minusMonths(int months) {	        if (months == 0) {	            return this;	        }	        long instant = getChronology().months().subtract(getLocalMillis(), months);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this date minus the specified number of weeks.	     * <p>	     * This LocalDate instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDate subtracted = dt.minusWeeks(6);	     * LocalDate subtracted = dt.minus(Period.weeks(6));	     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);	     * </pre>	     *	     * @param weeks  the amount of weeks to subtract, may be negative	     * @return the new LocalDate minus the increased weeks	     */	    public LocalDate minusWeeks(int weeks) {	        if (weeks == 0) {	            return this;	        }	        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this date minus the specified number of days.	     * <p>	     * This LocalDate instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDate subtracted = dt.minusDays(6);	     * LocalDate subtracted = dt.minus(Period.days(6));	     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);	     * </pre>	     *	     * @param days  the amount of days to subtract, may be negative	     * @return the new LocalDate minus the increased days	     */	    public LocalDate minusDays(int days) {	        if (days == 0) {	            return this;	        }	        long instant = getChronology().days().subtract(getLocalMillis(), days);	        return withLocalMillis(instant);	    }	
/**	     * Gets the property object for the specified type, which contains many	     * useful methods.	     *	     * @param fieldType  the field type to get the chronology for	     * @return the property object	     * @throws IllegalArgumentException if the field is null or unsupported	     */	    public Property property(DateTimeFieldType fieldType) {	        if (fieldType == null) {	            throw new IllegalArgumentException("The DateTimeFieldType must not be null");	        }	        if (isSupported(fieldType) == false) {	            throw new IllegalArgumentException("Field '" + fieldType + "' is not supported");	        }	        return new Property(this, fieldType.getField(getChronology()));	    }	
/**	     * Get the era field value.	     *	     * @return the era	     */	    public int getEra() {	        return getChronology().era().get(getLocalMillis());	    }	
/**	     * Get the year of era field value.	     *	     * @return the year of era	     */	    public int getCenturyOfEra() {	        return getChronology().centuryOfEra().get(getLocalMillis());	    }	
/**	     * Get the year of era field value.	     *	     * @return the year of era	     */	    public int getYearOfEra() {	        return getChronology().yearOfEra().get(getLocalMillis());	    }	
/**	     * Get the year of century field value.	     *	     * @return the year of century	     */	    public int getYearOfCentury() {	        return getChronology().yearOfCentury().get(getLocalMillis());	    }	
/**	     * Get the year field value.	     *	     * @return the year	     */	    public int getYear() {	        return getChronology().year().get(getLocalMillis());	    }	
/**	     * Get the weekyear field value.	     * <p>	     * The weekyear is the year that matches with the weekOfWeekyear field.	     * In the standard ISO8601 week algorithm, the first week of the year	     * is that in which at least 4 days are in the year. As a result of this	     * definition, day 1 of the first week may be in the previous year.	     * The weekyear allows you to query the effective year for that day.	     *	     * @return the weekyear	     */	    public int getWeekyear() {	        return getChronology().weekyear().get(getLocalMillis());	    }	
/**	     * Get the month of year field value.	     *	     * @return the month of year	     */	    public int getMonthOfYear() {	        return getChronology().monthOfYear().get(getLocalMillis());	    }	
/**	     * Get the week of weekyear field value.	     *	     * @return the week of a week based year	     */	    public int getWeekOfWeekyear() {	        return getChronology().weekOfWeekyear().get(getLocalMillis());	    }	
/**	     * Get the day of year field value.	     *	     * @return the day of year	     */	    public int getDayOfYear() {	        return getChronology().dayOfYear().get(getLocalMillis());	    }	
/**	     * Get the day of month field value.	     * <p>	     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.	     *	     * @return the day of month	     */	    public int getDayOfMonth() {	        return getChronology().dayOfMonth().get(getLocalMillis());	    }	
/**	     * Get the day of week field value.	     * <p>	     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.	     *	     * @return the day of week	     */	    public int getDayOfWeek() {	        return getChronology().dayOfWeek().get(getLocalMillis());	    }	
/**	     * Returns a copy of this date with the era field updated.	     * <p>	     * LocalDate is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * era changed.	     *	     * @param era  the era to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDate withEra(int era) {	        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));	    }	
/**	     * Returns a copy of this date with the century of era field updated.	     * <p>	     * LocalDate is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * century of era changed.	     *	     * @param centuryOfEra  the centurey of era to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDate withCenturyOfEra(int centuryOfEra) {	        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));	    }	
/**	     * Returns a copy of this date with the year of era field updated.	     * <p>	     * LocalDate is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * year of era changed.	     *	     * @param yearOfEra  the year of era to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDate withYearOfEra(int yearOfEra) {	        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));	    }	
/**	     * Returns a copy of this date with the year of century field updated.	     * <p>	     * LocalDate is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * year of century changed.	     *	     * @param yearOfCentury  the year of century to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDate withYearOfCentury(int yearOfCentury) {	        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));	    }	
/**	     * Returns a copy of this date with the year field updated.	     * <p>	     * LocalDate is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * year changed.	     *	     * @param year  the year to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDate withYear(int year) {	        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));	    }	
/**	     * Returns a copy of this date with the weekyear field updated.	     * <p>	     * LocalDate is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * weekyear changed.	     *	     * @param weekyear  the weekyear to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDate withWeekyear(int weekyear) {	        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));	    }	
/**	     * Returns a copy of this date with the month of year field updated.	     * <p>	     * LocalDate is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * month of year changed.	     *	     * @param monthOfYear  the month of year to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDate withMonthOfYear(int monthOfYear) {	        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));	    }	
/**	     * Returns a copy of this date with the week of weekyear field updated.	     * <p>	     * LocalDate is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * week of weekyear changed.	     *	     * @param weekOfWeekyear  the week of weekyear to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDate withWeekOfWeekyear(int weekOfWeekyear) {	        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));	    }	
/**	     * Returns a copy of this date with the day of year field updated.	     * <p>	     * LocalDate is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * day of year changed.	     *	     * @param dayOfYear  the day of year to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDate withDayOfYear(int dayOfYear) {	        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));	    }	
/**	     * Returns a copy of this date with the day of month field updated.	     * <p>	     * LocalDate is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * day of month changed.	     *	     * @param dayOfMonth  the day of month to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDate withDayOfMonth(int dayOfMonth) {	        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));	    }	
/**	     * Returns a copy of this date with the day of week field updated.	     * <p>	     * LocalDate is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * day of week changed.	     *	     * @param dayOfWeek  the day of week to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDate withDayOfWeek(int dayOfWeek) {	        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));	    }	
/**	     * Get the era property which provides access to advanced functionality.	     *	     * @return the era property	     */	    public Property era() {	        return new Property(this, getChronology().era());	    }	
/**	     * Get the century of era property which provides access to advanced functionality.	     *	     * @return the year of era property	     */	    public Property centuryOfEra() {	        return new Property(this, getChronology().centuryOfEra());	    }	
/**	     * Get the year of century property which provides access to advanced functionality.	     *	     * @return the year of era property	     */	    public Property yearOfCentury() {	        return new Property(this, getChronology().yearOfCentury());	    }	
/**	     * Get the year of era property which provides access to advanced functionality.	     *	     * @return the year of era property	     */	    public Property yearOfEra() {	        return new Property(this, getChronology().yearOfEra());	    }	
/**	     * Get the year property which provides access to advanced functionality.	     *	     * @return the year property	     */	    public Property year() {	        return new Property(this, getChronology().year());	    }	
/**	     * Get the weekyear property which provides access to advanced functionality.	     *	     * @return the weekyear property	     */	    public Property weekyear() {	        return new Property(this, getChronology().weekyear());	    }	
/**	     * Get the month of year property which provides access to advanced functionality.	     *	     * @return the month of year property	     */	    public Property monthOfYear() {	        return new Property(this, getChronology().monthOfYear());	    }	
/**	     * Get the week of a week based year property which provides access to advanced functionality.	     *	     * @return the week of a week based year property	     */	    public Property weekOfWeekyear() {	        return new Property(this, getChronology().weekOfWeekyear());	    }	
/**	     * Get the day of year property which provides access to advanced functionality.	     *	     * @return the day of year property	     */	    public Property dayOfYear() {	        return new Property(this, getChronology().dayOfYear());	    }	
/**	     * Get the day of month property which provides access to advanced functionality.	     *	     * @return the day of month property	     */	    public Property dayOfMonth() {	        return new Property(this, getChronology().dayOfMonth());	    }	
/**	     * Get the day of week property which provides access to advanced functionality.	     *	     * @return the day of week property	     */	    public Property dayOfWeek() {	        return new Property(this, getChronology().dayOfWeek());	    }	
/**	     * Output the date time in ISO8601 format (yyyy-MM-dd).	     *	     * @return ISO8601 time formatted string.	     */	    @ToString	    public String toString() {	        return ISODateTimeFormat.date().print(this);	    }	
/**	     * Output the date using the specified format pattern.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @see org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern) {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).print(this);	    }	
/**	     * Output the date using the specified format pattern.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @param locale  Locale to use, null means default	     * @see org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern, Locale locale) throws IllegalArgumentException {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);	    }	
/**	         * Constructor.	         * 	         * @param instant  the instant to set	         * @param field  the field to use	         */	        Property(LocalDate instant, DateTimeField field) {	            super();	            iInstant = instant;	            iField = field;	        }	
/**	         * Writes the property in a safe serialization format.	         */	        private void writeObject(ObjectOutputStream oos) throws IOException {	            oos.writeObject(iInstant);	            oos.writeObject(iField.getType());	        }	
/**	         * Reads the property from a safe serialization format.	         */	        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {	            iInstant = (LocalDate) oos.readObject();	            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();	            iField = type.getField(iInstant.getChronology());	        }	
/**	         * Gets the field being used.	         * 	         * @return the field	         */	        public DateTimeField getField() {	            return iField;	        }	
/**	         * Gets the milliseconds of the date that this property is linked to.	         * 	         * @return the milliseconds	         */	        protected long getMillis() {	            return iInstant.getLocalMillis();	        }	
/**	         * Gets the chronology of the datetime that this property is linked to.	         * 	         * @return the chronology	         * @since 1.4	         */	        protected Chronology getChronology() {	            return iInstant.getChronology();	        }	
/**	         * Gets the LocalDate object linked to this property.	         * 	         * @return the linked LocalDate	         */	        public LocalDate getLocalDate() {	            return iInstant;	        }	
/**	         * Adds to this field in a copy of this LocalDate.	         * <p>	         * The LocalDate attached to this property is unchanged by this call.	         *	         * @param value  the value to add to the field in the copy	         * @return a copy of the LocalDate with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public LocalDate addToCopy(int value) {	            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));	        }	
/**	         * Adds to this field, possibly wrapped, in a copy of this LocalDate.	         * A field wrapped operation only changes this field.	         * Thus 31st January addWrapField one day goes to the 1st January.	         * <p>	         * The LocalDate attached to this property is unchanged by this call.	         *	         * @param value  the value to add to the field in the copy	         * @return a copy of the LocalDate with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public LocalDate addWrapFieldToCopy(int value) {	            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));	        }	
/**	         * Sets this field in a copy of the LocalDate.	         * <p>	         * The LocalDate attached to this property is unchanged by this call.	         *	         * @param value  the value to set the field in the copy to	         * @return a copy of the LocalDate with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public LocalDate setCopy(int value) {	            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));	        }	
/**	         * Sets this field in a copy of the LocalDate to a parsed text value.	         * <p>	         * The LocalDate attached to this property is unchanged by this call.	         *	         * @param text  the text value to set	         * @param locale  optional locale to use for selecting a text symbol	         * @return a copy of the LocalDate with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public LocalDate setCopy(String text, Locale locale) {	            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));	        }	
/**	         * Sets this field in a copy of the LocalDate to a parsed text value.	         * <p>	         * The LocalDate attached to this property is unchanged by this call.	         *	         * @param text  the text value to set	         * @return a copy of the LocalDate with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public LocalDate setCopy(String text) {	            return setCopy(text, null);	        }	
/**	         * Returns a new LocalDate with this field set to the maximum value	         * for this field.	         * <p>	         * This operation is useful for obtaining a LocalDate on the last day	         * of the month, as month lengths vary.	         * <pre>	         * LocalDate lastDayOfMonth = dt.dayOfMonth().withMaximumValue();	         * </pre>	         * <p>	         * The LocalDate attached to this property is unchanged by this call.	         *	         * @return a copy of the LocalDate with this field set to its maximum	         */	        public LocalDate withMaximumValue() {	            return setCopy(getMaximumValue());	        }	
/**	         * Returns a new LocalDate with this field set to the minimum value	         * for this field.	         * <p>	         * The LocalDate attached to this property is unchanged by this call.	         *	         * @return a copy of the LocalDate with this field set to its minimum	         */	        public LocalDate withMinimumValue() {	            return setCopy(getMinimumValue());	        }	
/**	         * Rounds to the lowest whole unit of this field on a copy of this	         * LocalDate.	         * <p>	         * For example, rounding floor on the hourOfDay field of a LocalDate	         * where the time is 10:30 would result in new LocalDate with the	         * time of 10:00.	         *	         * @return a copy of the LocalDate with the field value changed	         */	        public LocalDate roundFloorCopy() {	            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));	        }	
/**	         * Rounds to the highest whole unit of this field on a copy of this	         * LocalDate.	         * <p>	         * For example, rounding floor on the hourOfDay field of a LocalDate	         * where the time is 10:30 would result in new LocalDate with the	         * time of 11:00.	         *	         * @return a copy of the LocalDate with the field value changed	         */	        public LocalDate roundCeilingCopy() {	            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));	        }	
/**	         * Rounds to the nearest whole unit of this field on a copy of this	         * LocalDate, favoring the floor if halfway.	         *	         * @return a copy of the LocalDate with the field value changed	         */	        public LocalDate roundHalfFloorCopy() {	            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));	        }	
/**	         * Rounds to the nearest whole unit of this field on a copy of this	         * LocalDate, favoring the ceiling if halfway.	         *	         * @return a copy of the LocalDate with the field value changed	         */	        public LocalDate roundHalfCeilingCopy() {	            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));	        }	
/**	         * Rounds to the nearest whole unit of this field on a copy of this	         * LocalDate.  If halfway, the ceiling is favored over the floor	         * only if it makes this field's value even.	         *	         * @return a copy of the LocalDate with the field value changed	         */	        public LocalDate roundHalfEvenCopy() {	            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));	        }	
/**	     * Constructs a new permission object.	     * 	     * @param name  the permission name	     */	    public JodaTimePermission(String name) {	        super(name);	    }	
/**	     * Gets the default time zone.	     * <p>	     * The default time zone is derived from the system property {@code user.timezone}.	     * If that is {@code null} or is not a valid identifier, then the value of the	     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.	     * <p>	     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this	     * method, then the change will not be picked up here.	     * 	     * @return the default datetime zone object	     */	    public static DateTimeZone getDefault() {	        DateTimeZone zone = cDefault;	        if (zone == null) {	            synchronized(DateTimeZone.class) {	                zone = cDefault;	                if (zone == null) {	                    DateTimeZone temp = null;	                    try {	                        try {	                            String id = System.getProperty("user.timezone");	                            if (id != null) {  // null check avoids stack overflow	                                temp = forID(id);	                            }	                        } catch (RuntimeException ex) {	                            // ignored	                        }	                        if (temp == null) {	                            temp = forTimeZone(TimeZone.getDefault());	                        }	                    } catch (IllegalArgumentException ex) {	                        // ignored	                    }	                    if (temp == null) {	                        temp = UTC;	                    }	                    cDefault = zone = temp;	                }	            }	        }	        return zone;	    }	
/**	     * Sets the default time zone.	     * <p>	     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.	     * 	     * @param zone  the default datetime zone object, must not be null	     * @throws IllegalArgumentException if the zone is null	     * @throws SecurityException if the application has insufficient security rights	     */	    public static void setDefault(DateTimeZone zone) throws SecurityException {	        SecurityManager sm = System.getSecurityManager();	        if (sm != null) {	            sm.checkPermission(new JodaTimePermission("DateTimeZone.setDefault"));	        }	        if (zone == null) {	            throw new IllegalArgumentException("The datetime zone must not be null");	        }	        synchronized(DateTimeZone.class) {	            cDefault = zone;	        }	    }	
/**	     * Gets a time zone instance for the specified time zone id.	     * <p>	     * The time zone id may be one of those returned by getAvailableIDs.	     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.	     * All IDs must be specified in the long format.	     * The exception is UTC, which is an acceptable id.	     * <p>	     * Alternatively a locale independent, fixed offset, datetime zone can	     * be specified. The form <code>[+-]hh:mm</code> can be used.	     * 	     * @param id  the ID of the datetime zone, null means default	     * @return the DateTimeZone object for the ID	     * @throws IllegalArgumentException if the ID is not recognised	     */	    @FromString	    public static DateTimeZone forID(String id) {	        if (id == null) {	            return getDefault();	        }	        if (id.equals("UTC")) {	            return DateTimeZone.UTC;	        }	        DateTimeZone zone = cProvider.getZone(id);	        if (zone != null) {	            return zone;	        }	        if (id.startsWith("+") || id.startsWith("-")) {	            int offset = parseOffset(id);	            if (offset == 0L) {	                return DateTimeZone.UTC;	            } else {	                id = printOffset(offset);	                return fixedOffsetZone(id, offset);	            }	        }	        throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised");	    }	
/**	     * Gets a time zone instance for the specified offset to UTC in hours.	     * This method assumes standard length hours.	     * <p>	     * This factory is a convenient way of constructing zones with a fixed offset.	     * 	     * @param hoursOffset  the offset in hours from UTC	     * @return the DateTimeZone object for the offset	     * @throws IllegalArgumentException if the offset is too large or too small	     */	    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {	        return forOffsetHoursMinutes(hoursOffset, 0);	    }	
/**	     * Gets a time zone instance for the specified offset to UTC in hours and minutes.	     * This method assumes 60 minutes in an hour, and standard length minutes.	     * <p>	     * This factory is a convenient way of constructing zones with a fixed offset.	     * The minutes value is always positive and in the range 0 to 59.	     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.	     * 	     * @param hoursOffset  the offset in hours from UTC	     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive	     * @return the DateTimeZone object for the offset	     * @throws IllegalArgumentException if the offset or minute is too large or too small	     */	    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {	        if (hoursOffset == 0 && minutesOffset == 0) {	            return DateTimeZone.UTC;	        }	        if (minutesOffset < 0 || minutesOffset > 59) {	            throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);	        }	        int offset = 0;	        try {	            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);	            if (hoursInMinutes < 0) {	                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);	            } else {	                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);	            }	            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);	        } catch (ArithmeticException ex) {	            throw new IllegalArgumentException("Offset is too large");	        }	        return forOffsetMillis(offset);	    }	
/**	     * Gets a time zone instance for the specified offset to UTC in milliseconds.	     *	     * @param millisOffset  the offset in millis from UTC	     * @return the DateTimeZone object for the offset	     */	    public static DateTimeZone forOffsetMillis(int millisOffset) {	        String id = printOffset(millisOffset);	        return fixedOffsetZone(id, millisOffset);	    }	
/**	     * Gets a time zone instance for a JDK TimeZone.	     * <p>	     * DateTimeZone only accepts a subset of the IDs from TimeZone. The	     * excluded IDs are the short three letter form (except UTC). This 	     * method will attempt to convert between time zones created using the	     * short IDs and the full version.	     * <p>	     * This method is not designed to parse time zones with rules created by	     * applications using <code>SimpleTimeZone</code> directly.	     * 	     * @param zone  the zone to convert, null means default	     * @return the DateTimeZone object for the zone	     * @throws IllegalArgumentException if the zone is not recognised	     */	    public static DateTimeZone forTimeZone(TimeZone zone) {	        if (zone == null) {	            return getDefault();	        }	        final String id = zone.getID();	        if (id.equals("UTC")) {	            return DateTimeZone.UTC;	        }		        // Convert from old alias before consulting provider since they may differ.	        DateTimeZone dtz = null;	        String convId = getConvertedId(id);	        if (convId != null) {	            dtz = cProvider.getZone(convId);	        }	        if (dtz == null) {	            dtz = cProvider.getZone(id);	        }	        if (dtz != null) {	            return dtz;	        }		        // Support GMT+/-hh:mm formats	        if (convId == null) {	            convId = zone.getDisplayName();	            if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) {	                convId = convId.substring(3);	                int offset = parseOffset(convId);	                if (offset == 0L) {	                    return DateTimeZone.UTC;	                } else {	                    convId = printOffset(offset);	                    return fixedOffsetZone(convId, offset);	                }	            }	        }	        throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised");	    }	
/**	     * Gets the zone using a fixed offset amount.	     * 	     * @param id  the zone id	     * @param offset  the offset in millis	     * @return the zone	     */	    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {	        if (offset == 0) {	            return DateTimeZone.UTC;	        }	        if (iFixedOffsetCache == null) {	            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();	        }	        DateTimeZone zone;	        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);	        if (ref != null) {	            zone = ref.get();	            if (zone != null) {	                return zone;	            }	        }	        zone = new FixedDateTimeZone(id, null, offset, offset);	        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));	        return zone;	    }	
/**	     * Gets all the available IDs supported.	     * 	     * @return an unmodifiable Set of String IDs	     */	    public static Set<String> getAvailableIDs() {	        return cAvailableIDs;	    }	
/**	     * Gets the zone provider factory.	     * <p>	     * The zone provider is a pluggable instance factory that supplies the	     * actual instances of DateTimeZone.	     * 	     * @return the provider	     */	    public static Provider getProvider() {	        return cProvider;	    }	
/**	     * Sets the zone provider factory.	     * <p>	     * The zone provider is a pluggable instance factory that supplies the	     * actual instances of DateTimeZone.	     * 	     * @param provider  provider to use, or null for default	     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider	     * @throws IllegalArgumentException if the provider is invalid	     */	    public static void setProvider(Provider provider) throws SecurityException {	        SecurityManager sm = System.getSecurityManager();	        if (sm != null) {	            sm.checkPermission(new JodaTimePermission("DateTimeZone.setProvider"));	        }	        setProvider0(provider);	    }	
/**	     * Sets the zone provider factory without performing the security check.	     * 	     * @param provider  provider to use, or null for default	     * @throws IllegalArgumentException if the provider is invalid	     */	    private static void setProvider0(Provider provider) {	        if (provider == null) {	            provider = getDefaultProvider();	        }	        Set<String> ids = provider.getAvailableIDs();	        if (ids == null || ids.size() == 0) {	            throw new IllegalArgumentException	                ("The provider doesn't have any available ids");	        }	        if (!ids.contains("UTC")) {	            throw new IllegalArgumentException("The provider doesn't support UTC");	        }	        if (!UTC.equals(provider.getZone("UTC"))) {	            throw new IllegalArgumentException("Invalid UTC zone provided");	        }	        cProvider = provider;	        cAvailableIDs = ids;	    }	
/**	     * Gets the default zone provider.	     * <p>	     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.	     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.	     * Then uses <code>UTCProvider</code>.	     * 	     * @return the default name provider	     */	    private static Provider getDefaultProvider() {	        Provider provider = null;		        try {	            String providerClass =	                System.getProperty("org.joda.time.DateTimeZone.Provider");	            if (providerClass != null) {	                try {	                    provider = (Provider) Class.forName(providerClass).newInstance();	                } catch (Exception ex) {	                    Thread thread = Thread.currentThread();	                    thread.getThreadGroup().uncaughtException(thread, ex);	                }	            }	        } catch (SecurityException ex) {	            // ignored	        }		        if (provider == null) {	            try {	                provider = new ZoneInfoProvider("org/joda/time/tz/data");	            } catch (Exception ex) {	                Thread thread = Thread.currentThread();	                thread.getThreadGroup().uncaughtException(thread, ex);	            }	        }		        if (provider == null) {	            provider = new UTCProvider();	        }		        return provider;	    }	
/**	     * Gets the name provider factory.	     * <p>	     * The name provider is a pluggable instance factory that supplies the	     * names of each DateTimeZone.	     * 	     * @return the provider	     */	    public static NameProvider getNameProvider() {	        return cNameProvider;	    }	
/**	     * Sets the name provider factory.	     * <p>	     * The name provider is a pluggable instance factory that supplies the	     * names of each DateTimeZone.	     * 	     * @param nameProvider  provider to use, or null for default	     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider	     * @throws IllegalArgumentException if the provider is invalid	     */	    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {	        SecurityManager sm = System.getSecurityManager();	        if (sm != null) {	            sm.checkPermission(new JodaTimePermission("DateTimeZone.setNameProvider"));	        }	        setNameProvider0(nameProvider);	    }	
/**	     * Sets the name provider factory without performing the security check.	     * 	     * @param nameProvider  provider to use, or null for default	     * @throws IllegalArgumentException if the provider is invalid	     */	    private static void setNameProvider0(NameProvider nameProvider) {	        if (nameProvider == null) {	            nameProvider = getDefaultNameProvider();	        }	        cNameProvider = nameProvider;	    }	
/**	     * Gets the default name provider.	     * <p>	     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.	     * Then uses <code>DefaultNameProvider</code>.	     * 	     * @return the default name provider	     */	    private static NameProvider getDefaultNameProvider() {	        NameProvider nameProvider = null;	        try {	            String providerClass = System.getProperty("org.joda.time.DateTimeZone.NameProvider");	            if (providerClass != null) {	                try {	                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();	                } catch (Exception ex) {	                    Thread thread = Thread.currentThread();	                    thread.getThreadGroup().uncaughtException(thread, ex);	                }	            }	        } catch (SecurityException ex) {	            // ignore	        }		        if (nameProvider == null) {	            nameProvider = new DefaultNameProvider();	        }		        return nameProvider;	    }	
/**	     * Converts an old style id to a new style id.	     * 	     * @param id  the old style id	     * @return the new style id, null if not found	     */	    private static synchronized String getConvertedId(String id) {	        Map<String, String> map = cZoneIdConversion;	        if (map == null) {	            // Backwards compatibility with TimeZone.	            map = new HashMap<String, String>();	            map.put("GMT", "UTC");	            map.put("MIT", "Pacific/Apia");	            map.put("HST", "Pacific/Honolulu");	            map.put("AST", "America/Anchorage");	            map.put("PST", "America/Los_Angeles");	            map.put("MST", "America/Denver");	            map.put("PNT", "America/Phoenix");	            map.put("CST", "America/Chicago");	            map.put("EST", "America/New_York");	            map.put("IET", "America/Indianapolis");	            map.put("PRT", "America/Puerto_Rico");	            map.put("CNT", "America/St_Johns");	            map.put("AGT", "America/Buenos_Aires");	            map.put("BET", "America/Sao_Paulo");	            map.put("WET", "Europe/London");	            map.put("ECT", "Europe/Paris");	            map.put("ART", "Africa/Cairo");	            map.put("CAT", "Africa/Harare");	            map.put("EET", "Europe/Bucharest");	            map.put("EAT", "Africa/Addis_Ababa");	            map.put("MET", "Asia/Tehran");	            map.put("NET", "Asia/Yerevan");	            map.put("PLT", "Asia/Karachi");	            map.put("IST", "Asia/Calcutta");	            map.put("BST", "Asia/Dhaka");	            map.put("VST", "Asia/Saigon");	            map.put("CTT", "Asia/Shanghai");	            map.put("JST", "Asia/Tokyo");	            map.put("ACT", "Australia/Darwin");	            map.put("AET", "Australia/Sydney");	            map.put("SST", "Pacific/Guadalcanal");	            map.put("NST", "Pacific/Auckland");	            cZoneIdConversion = map;	        }	        return map.get(id);	    }	
private static int parseOffset(String str) {	        // Can't use a real chronology if called during class	        // initialization. Offset parser doesn't need it anyhow.	        Chronology chrono = new BaseChronology() {	            public DateTimeZone getZone() {	                return null;	            }	            public Chronology withUTC() {	                return this;	            }	            public Chronology withZone(DateTimeZone zone) {	                return this;	            }	            public String toString() {	                return getClass().getName();	            }	        };	        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);	    }	
/**	     * Formats a timezone offset string.	     * <p>	     * This method is kept separate from the formatting classes to speed and	     * simplify startup and classloading.	     * 	     * @param offset  the offset in milliseconds	     * @return the time zone string	     */	    private static String printOffset(int offset) {	        StringBuffer buf = new StringBuffer();	        if (offset >= 0) {	            buf.append('+');	        } else {	            buf.append('-');	            offset = -offset;	        }		        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;	        FormatUtils.appendPaddedInteger(buf, hours, 2);	        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;		        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;	        buf.append(':');	        FormatUtils.appendPaddedInteger(buf, minutes, 2);	        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;	        if (offset == 0) {	            return buf.toString();	        }		        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;	        buf.append(':');	        FormatUtils.appendPaddedInteger(buf, seconds, 2);	        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;	        if (offset == 0) {	            return buf.toString();	        }		        buf.append('.');	        FormatUtils.appendPaddedInteger(buf, offset, 3);	        return buf.toString();	    }	
/**	     * Gets a printer/parser for managing the offset id formatting.	     * 	     * @return the formatter	     */	    private static synchronized DateTimeFormatter offsetFormatter() {	        if (cOffsetFormatter == null) {	            cOffsetFormatter = new DateTimeFormatterBuilder()	                .appendTimeZoneOffset(null, true, 2, 4)	                .toFormatter();	        }	        return cOffsetFormatter;	    }	
/**	     * Constructor.	     * 	     * @param id  the id to use	     * @throws IllegalArgumentException if the id is null	     */	    protected DateTimeZone(String id) {	        if (id == null) {	            throw new IllegalArgumentException("Id must not be null");	        }	        iID = id;	    }	
/**	     * Gets the ID of this datetime zone.	     * 	     * @return the ID of this datetime zone	     */	    @ToString	    public final String getID() {	        return iID;	    }	
/**	     * Gets the short name of this datetime zone suitable for display using	     * the default locale.	     * <p>	     * If the name is not available for the locale, then this method returns a	     * string in the format <code>[+-]hh:mm</code>.	     * 	     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for	     * @return the human-readable short name in the default locale	     */	    public final String getShortName(long instant) {	        return getShortName(instant, null);	    }	
/**	     * Gets the short name of this datetime zone suitable for display using	     * the specified locale.	     * <p>	     * If the name is not available for the locale, then this method returns a	     * string in the format <code>[+-]hh:mm</code>.	     * 	     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for	     * @param locale  the locale to get the name for	     * @return the human-readable short name in the specified locale	     */	    public String getShortName(long instant, Locale locale) {	        if (locale == null) {	            locale = Locale.getDefault();	        }	        String nameKey = getNameKey(instant);	        if (nameKey == null) {	            return iID;	        }	        String name = cNameProvider.getShortName(locale, iID, nameKey);	        if (name != null) {	            return name;	        }	        return printOffset(getOffset(instant));	    }	
/**	     * Gets the long name of this datetime zone suitable for display using	     * the default locale.	     * <p>	     * If the name is not available for the locale, then this method returns a	     * string in the format <code>[+-]hh:mm</code>.	     * 	     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for	     * @return the human-readable long name in the default locale	     */	    public final String getName(long instant) {	        return getName(instant, null);	    }	
/**	     * Gets the long name of this datetime zone suitable for display using	     * the specified locale.	     * <p>	     * If the name is not available for the locale, then this method returns a	     * string in the format <code>[+-]hh:mm</code>.	     * 	     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for	     * @param locale  the locale to get the name for	     * @return the human-readable long name in the specified locale	     */	    public String getName(long instant, Locale locale) {	        if (locale == null) {	            locale = Locale.getDefault();	        }	        String nameKey = getNameKey(instant);	        if (nameKey == null) {	            return iID;	        }	        String name = cNameProvider.getName(locale, iID, nameKey);	        if (name != null) {	            return name;	        }	        return printOffset(getOffset(instant));	    }	
/**	     * Gets the millisecond offset to add to UTC to get local time.	     * 	     * @param instant  instant to get the offset for, null means now	     * @return the millisecond offset to add to UTC to get local time	     */	    public final int getOffset(ReadableInstant instant) {	        if (instant == null) {	            return getOffset(DateTimeUtils.currentTimeMillis());	        }	        return getOffset(instant.getMillis());	    }	
/**	     * Checks whether, at a particular instant, the offset is standard or not.	     * <p>	     * This method can be used to determine whether Summer Time (DST) applies.	     * As a general rule, if the offset at the specified instant is standard,	     * then either Winter time applies, or there is no Summer Time. If the	     * instant is not standard, then Summer Time applies.	     * <p>	     * The implementation of the method is simply whether {@link #getOffset(long)}	     * equals {@link #getStandardOffset(long)} at the specified instant.	     * 	     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for	     * @return true if the offset at the given instant is the standard offset	     * @since 1.5	     */	    public boolean isStandardOffset(long instant) {	        return getOffset(instant) == getStandardOffset(instant);	    }	
/**	     * Gets the millisecond offset to subtract from local time to get UTC time.	     * This offset can be used to undo adding the offset obtained by getOffset.	     *	     * <pre>	     * millisLocal == millisUTC   + getOffset(millisUTC)	     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)	     * </pre>	     *	     * NOTE: After calculating millisLocal, some error may be introduced. At	     * offset transitions (due to DST or other historical changes), ranges of	     * local times may map to different UTC times.	     * <p>	     * This method will return an offset suitable for calculating an instant	     * after any DST gap. For example, consider a zone with a cutover	     * from 01:00 to 01:59:<br />	     * Input: 00:00  Output: 00:00<br />	     * Input: 00:30  Output: 00:30<br />	     * Input: 01:00  Output: 02:00<br />	     * Input: 01:30  Output: 02:30<br />	     * Input: 02:00  Output: 02:00<br />	     * Input: 02:30  Output: 02:30<br />	     * <p>	     * During a DST overlap (where the local time is ambiguous) this method will return	     * the earlier instant. The combination of these two rules is to always favour	     * daylight (summer) time over standard (winter) time.	     * <p>	     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.	     * Prior to v1.5, the DST gap behaviour was also not defined.	     *	     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for	     * @return the millisecond offset to subtract from local time to get UTC time	     */	    public int getOffsetFromLocal(long instantLocal) {	        // get the offset at instantLocal (first estimate)	        final int offsetLocal = getOffset(instantLocal);	        // adjust instantLocal using the estimate and recalc the offset	        final long instantAdjusted = instantLocal - offsetLocal;	        final int offsetAdjusted = getOffset(instantAdjusted);	        // if the offsets differ, we must be near a DST boundary	        if (offsetLocal != offsetAdjusted) {	            // we need to ensure that time is always after the DST gap	            // this happens naturally for positive offsets, but not for negative	            if ((offsetLocal - offsetAdjusted) < 0) {	                // if we just return offsetAdjusted then the time is pushed	                // back before the transition, whereas it should be	                // on or after the transition	                long nextLocal = nextTransition(instantAdjusted);	                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);	                if (nextLocal != nextAdjusted) {	                    return offsetLocal;	                }	            }	        }	        return offsetAdjusted;	    }	
/**	     * Converts a standard UTC instant to a local instant with the same	     * local time. This conversion is used before performing a calculation	     * so that the calculation can be done using a simple local zone.	     *	     * @param instantUTC  the UTC instant to convert to local	     * @return the local instant with the same local time	     * @throws ArithmeticException if the result overflows a long	     * @since 1.5	     */	    public long convertUTCToLocal(long instantUTC) {	        int offset = getOffset(instantUTC);	        long instantLocal = instantUTC + offset;	        // If there is a sign change, but the two values have the same sign...	        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {	            throw new ArithmeticException("Adding time zone offset caused overflow");	        }	        return instantLocal;	    }	
/**	     * Converts a local instant to a standard UTC instant with the same	     * local time attempting to use the same offset as the original.	     * <p>	     * This conversion is used after performing a calculation	     * where the calculation was done using a simple local zone.	     * Whenever possible, the same offset as the original offset will be used.	     * This is most significant during a daylight savings overlap.	     *	     * @param instantLocal  the local instant to convert to UTC	     * @param strict  whether the conversion should reject non-existent local times	     * @param originalInstantUTC  the original instant that the calculation is based on	     * @return the UTC instant with the same local time, 	     * @throws ArithmeticException if the result overflows a long	     * @throws IllegalArgumentException if the zone has no equivalent local time	     * @since 2.0	     */	    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {	        int offsetOriginal = getOffset(originalInstantUTC);	        long instantUTC = instantLocal - offsetOriginal;	        int offsetLocalFromOriginal = getOffset(instantUTC);	        if (offsetLocalFromOriginal == offsetOriginal) {	            return instantUTC;	        }	        return convertLocalToUTC(instantLocal, strict);	    }	
/**	     * Converts a local instant to a standard UTC instant with the same	     * local time. This conversion is used after performing a calculation	     * where the calculation was done using a simple local zone.	     *	     * @param instantLocal  the local instant to convert to UTC	     * @param strict  whether the conversion should reject non-existent local times	     * @return the UTC instant with the same local time, 	     * @throws ArithmeticException if the result overflows a long	     * @throws IllegalArgumentException if the zone has no equivalent local time	     * @since 1.5	     */	    public long convertLocalToUTC(long instantLocal, boolean strict) {	        // get the offset at instantLocal (first estimate)	        int offsetLocal = getOffset(instantLocal);	        // adjust instantLocal using the estimate and recalc the offset	        int offset = getOffset(instantLocal - offsetLocal);	        // if the offsets differ, we must be near a DST boundary	        if (offsetLocal != offset) {	            // if strict then always check if in DST gap	            // otherwise only check if zone in Western hemisphere (as the	            // value of offset is already correct for Eastern hemisphere)	            if (strict || offsetLocal < 0) {	                // determine if we are in the DST gap	                long nextLocal = nextTransition(instantLocal - offsetLocal);	                if (nextLocal == (instantLocal - offsetLocal)) {	                    nextLocal = Long.MAX_VALUE;	                }	                long nextAdjusted = nextTransition(instantLocal - offset);	                if (nextAdjusted == (instantLocal - offset)) {	                    nextAdjusted = Long.MAX_VALUE;	                }	                if (nextLocal != nextAdjusted) {	                    // yes we are in the DST gap	                    if (strict) {	                        // DST gap is not acceptable	                        throw new IllegalArgumentException("Illegal instant due to time zone offset transition: " +	                                DateTimeFormat.forPattern("yyyy-MM-dd'T'HH:mm:ss.SSS").print(new Instant(instantLocal)) +	                                " (" + getID() + ")");	                    } else {	                        // DST gap is acceptable, but for the Western hemisphere	                        // the offset is wrong and will result in local times	                        // before the cutover so use the offsetLocal instead	                        offset = offsetLocal;	                    }	                }	            }	        }	        // check for overflow	        long instantUTC = instantLocal - offset;	        // If there is a sign change, but the two values have different signs...	        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {	            throw new ArithmeticException("Subtracting time zone offset caused overflow");	        }	        return instantUTC;	    }	
/**	     * Gets the millisecond instant in another zone keeping the same local time.	     * <p>	     * The conversion is performed by converting the specified UTC millis to local	     * millis in this zone, then converting back to UTC millis in the new zone.	     *	     * @param newZone  the new zone, null means default	     * @param oldInstant  the UTC millisecond instant to convert	     * @return the UTC millisecond instant with the same local time in the new zone	     */	    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {	        if (newZone == null) {	            newZone = DateTimeZone.getDefault();	        }	        if (newZone == this) {	            return oldInstant;	        }	        long instantLocal = oldInstant + getOffset(oldInstant);	        return instantLocal - newZone.getOffsetFromLocal(instantLocal);	    }	
/**	     * Checks if the given {@link LocalDateTime} is within a gap.	     * <p>	     * When switching from standard time to Daylight Savings Time there is	     * typically a gap where a clock hour is missing. This method identifies	     * whether the local datetime refers to such a gap.	     * 	     * @param localDateTime  the time to check, not null	     * @return true if the given datetime refers to a gap	     * @since 1.6	     */	    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {	        if (isFixed()) {	            return false;	        }	        try {	            localDateTime.toDateTime(this);	            return false;	        } catch (IllegalArgumentException ex) {	            return true;	        }	    }	
/**	     * Get the datetime zone as a {@link java.util.TimeZone}.	     * 	     * @return the closest matching TimeZone object	     */	    public java.util.TimeZone toTimeZone() {	        return java.util.TimeZone.getTimeZone(iID);	    }	
/**	     * Gets a hash code compatable with equals.	     * 	     * @return suitable hashcode	     */	    public int hashCode() {	        return 57 + getID().hashCode();	    }	
/**	     * Gets the datetime zone as a string, which is simply its ID.	     * @return the id of the zone	     */	    public String toString() {	        return getID();	    }	
/**	     * By default, when DateTimeZones are serialized, only a "stub" object	     * referring to the id is written out. When the stub is read in, it	     * replaces itself with a DateTimeZone object.	     * @return a stub object to go in the stream	     */	    protected Object writeReplace() throws ObjectStreamException {	        return new Stub(iID);	    }	
/**	         * Constructor.	         * @param id  the id of the zone	         */	        Stub(String id) {	            iID = id;	        }	
private void writeObject(ObjectOutputStream out) throws IOException {	            out.writeUTF(iID);	        }	
private void readObject(ObjectInputStream in) throws IOException {	            iID = in.readUTF();	        }	
private Object readResolve() throws ObjectStreamException {	            return forID(iID);	        }	
/**	     * Parses a {@code MutableInterval} from the specified string.	     * <p>	     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}	     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',	     * 'datetime/period' or 'period/datetime'.	     * 	     * @param str  the string to parse, not null	     * @since 2.0	     */	    public static MutableInterval parse(String str) {	        return new MutableInterval(str);	    }	
/**	     * Constructs a zero length time interval from 1970-01-01 to 1970-01-01.	     */	    public MutableInterval() {	        super(0L, 0L, null);	    }	
/**	     * Constructs an interval from a start and end instant with the ISO default chronology.	     * 	     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.	     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.	     * @throws IllegalArgumentException if the end is before the start	     */	    public MutableInterval(long startInstant, long endInstant) {	        super(startInstant, endInstant, null);	    }	
/**	     * Constructs an interval from a start and end instant with a chronology.	     * 	     * @param chronology  the chronology to use, null is ISO default	     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.	     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.	     * @throws IllegalArgumentException if the end is before the start	     */	    public MutableInterval(long startInstant, long endInstant, Chronology chronology) {	        super(startInstant, endInstant, chronology);	    }	
/**	     * Constructs an interval from a start and end instant.	     * <p>	     * The chronology used is that of the start instant.	     * 	     * @param start  start of this interval, null means now	     * @param end  end of this interval, null means now	     * @throws IllegalArgumentException if the end is before the start	     */	    public MutableInterval(ReadableInstant start, ReadableInstant end) {	        super(start, end);	    }	
/**	     * Constructs an interval from a start instant and a duration.	     * 	     * @param start  start of this interval, null means now	     * @param duration  the duration of this interval, null means zero length	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the end instant exceeds the capacity of a long	     */	    public MutableInterval(ReadableInstant start, ReadableDuration duration) {	        super(start, duration);	    }	
/**	     * Constructs an interval from a millisecond duration and an end instant.	     * 	     * @param duration  the duration of this interval, null means zero length	     * @param end  end of this interval, null means now	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the start instant exceeds the capacity of a long	     */	    public MutableInterval(ReadableDuration duration, ReadableInstant end) {	        super(duration, end);	    }	
/**	     * Constructs an interval from a start instant and a time period.	     * <p>	     * When forming the interval, the chronology from the instant is used	     * if present, otherwise the chronology of the period is used.	     * 	     * @param start  start of this interval, null means now	     * @param period  the period of this interval, null means zero length	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the end instant exceeds the capacity of a long	     */	    public MutableInterval(ReadableInstant start, ReadablePeriod period) {	        super(start, period);	    }	
/**	     * Constructs an interval from a time period and an end instant.	     * <p>	     * When forming the interval, the chronology from the instant is used	     * if present, otherwise the chronology of the period is used.	     * 	     * @param period  the period of this interval, null means zero length	     * @param end  end of this interval, null means now	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the start instant exceeds the capacity of a long	     */	    public MutableInterval(ReadablePeriod period, ReadableInstant end) {	        super(period, end);	    }	
/**	     * Constructs a time interval by converting or copying from another object.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInterval and String.	     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}	     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',	     * 'datetime/period' or 'period/datetime'.	     * 	     * @param interval  the time interval to copy	     * @throws IllegalArgumentException if the interval is invalid	     */	    public MutableInterval(Object interval) {	        super(interval, null);	    }	
/**	     * Constructs a time interval by converting or copying from another object,	     * overriding the chronology.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInterval and String.	     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}	     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',	     * 'datetime/period' or 'period/datetime'.	     * 	     * @param interval  the time interval to copy	     * @param chronology  the chronology to use, null means ISO default	     * @throws IllegalArgumentException if the interval is invalid	     */	    public MutableInterval(Object interval, Chronology chronology) {	        super(interval, chronology);	    }	
/**	     * Sets this interval from two millisecond instants retaining the chronology.	     *	     * @param startInstant  the start of the time interval	     * @param endInstant  the start of the time interval	     * @throws IllegalArgumentException if the end is before the start	     */	    public void setInterval(long startInstant, long endInstant) {	        super.setInterval(startInstant, endInstant, getChronology());	    }	
/**	     * Sets this interval to be the same as another.	     *	     * @param interval  the interval to copy	     * @throws IllegalArgumentException if the interval is null	     */	    public void setInterval(ReadableInterval interval) {	        if (interval == null) {	            throw new IllegalArgumentException("Interval must not be null");	        }	        long startMillis = interval.getStartMillis();	        long endMillis = interval.getEndMillis();	        Chronology chrono = interval.getChronology();	        super.setInterval(startMillis, endMillis, chrono);	    }	
/**	     * Sets this interval from two instants, replacing the chronology with	     * that from the start instant.	     *	     * @param start  the start of the time interval	     * @param end  the start of the time interval	     * @throws IllegalArgumentException if the end is before the start	     */	    public void setInterval(ReadableInstant start, ReadableInstant end) {	        if (start == null && end == null) {	            long now = DateTimeUtils.currentTimeMillis();	            setInterval(now, now);	        } else {	            long startMillis = DateTimeUtils.getInstantMillis(start);	            long endMillis = DateTimeUtils.getInstantMillis(end);	            Chronology chrono = DateTimeUtils.getInstantChronology(start);	            super.setInterval(startMillis, endMillis, chrono);	        }	    }	
/**	     * Sets the chronology of this time interval.	     *	     * @param chrono  the chronology to use, null means ISO default	     */	    public void setChronology(Chronology chrono) {	        super.setInterval(getStartMillis(), getEndMillis(), chrono);	    }	
/**	     * Sets the start of this time interval.	     *	     * @param startInstant  the start of the time interval,	     *  millisecond instant from 1970-01-01T00:00:00Z	     * @throws IllegalArgumentException if the end is before the start	     */	    public void setStartMillis(long startInstant) {	        super.setInterval(startInstant, getEndMillis(), getChronology());	    }	
/**	     * Sets the start of this time interval as an Instant.	     *	     * @param start  the start of the time interval, null means now	     * @throws IllegalArgumentException if the end is before the start	     */	    public void setStart(ReadableInstant start) {	        long startMillis = DateTimeUtils.getInstantMillis(start);	        super.setInterval(startMillis, getEndMillis(), getChronology());	    }	
/** 	     * Sets the end of this time interval.	     *	     * @param endInstant  the end of the time interval,	     *  millisecond instant from 1970-01-01T00:00:00Z	     * @throws IllegalArgumentException if the end is before the start	     */	    public void setEndMillis(long endInstant) {	        super.setInterval(getStartMillis(), endInstant, getChronology());	    }	
/** 	     * Sets the end of this time interval as an Instant.	     *	     * @param end  the end of the time interval, null means now	     * @throws IllegalArgumentException if the end is before the start	     */	    public void setEnd(ReadableInstant end) {	        long endMillis = DateTimeUtils.getInstantMillis(end);	        super.setInterval(getStartMillis(), endMillis, getChronology());	    }	
/**	     * Sets the duration of this time interval, preserving the start instant.	     *	     * @param duration  new duration for interval	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the end instant exceeds the capacity of a long	     */	    public void setDurationAfterStart(long duration) {	        setEndMillis(FieldUtils.safeAdd(getStartMillis(), duration));	    }	
/**	     * Sets the duration of this time interval, preserving the end instant.	     *	     * @param duration  new duration for interval	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the start instant exceeds the capacity of a long	     */	    public void setDurationBeforeEnd(long duration) {	        setStartMillis(FieldUtils.safeAdd(getEndMillis(), -duration));	    }	
/**	     * Sets the duration of this time interval, preserving the start instant.	     *	     * @param duration  new duration for interval, null means zero length	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the end instant exceeds the capacity of a long	     */	    public void setDurationAfterStart(ReadableDuration duration) {	        long durationMillis = DateTimeUtils.getDurationMillis(duration);	        setEndMillis(FieldUtils.safeAdd(getStartMillis(), durationMillis));	    }	
/**	     * Sets the duration of this time interval, preserving the end instant.	     *	     * @param duration  new duration for interval, null means zero length	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the start instant exceeds the capacity of a long	     */	    public void setDurationBeforeEnd(ReadableDuration duration) {	        long durationMillis = DateTimeUtils.getDurationMillis(duration);	        setStartMillis(FieldUtils.safeAdd(getEndMillis(), -durationMillis));	    }	
/**	     * Sets the period of this time interval, preserving the start instant	     * and using the ISOChronology in the default zone for calculations.	     *	     * @param period  new period for interval, null means zero length	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the end instant exceeds the capacity of a long	     */	    public void setPeriodAfterStart(ReadablePeriod period) {	        if (period == null) {	            setEndMillis(getStartMillis());	        } else {	            setEndMillis(getChronology().add(period, getStartMillis(), 1));	        }	    }	
/**	     * Sets the period of this time interval, preserving the end instant	     * and using the ISOChronology in the default zone for calculations.	     *	     * @param period  new period for interval, null means zero length	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the start instant exceeds the capacity of a long	     */	    public void setPeriodBeforeEnd(ReadablePeriod period) {	        if (period == null) {	            setStartMillis(getEndMillis());	        } else {	            setStartMillis(getChronology().add(period, getEndMillis(), -1));	        }	    }	
/**	     * Clone this object without having to cast the returned object.	     *	     * @return a clone of the this object.	     */	    public MutableInterval copy() {	        return (MutableInterval) clone();	    }	
/**	     * Clone this object.	     *	     * @return a clone of this object.	     */	    public Object clone() {	        try {	            return super.clone();	        } catch (CloneNotSupportedException ex) {	            throw new InternalError("Clone error");	        }	    }	
/**	     * Obtains an instance of <code>Weeks</code> that may be cached.	     * <code>Weeks</code> is immutable, so instances can be cached and shared.	     * This factory method provides access to shared instances.	     *	     * @param weeks  the number of weeks to obtain an instance for	     * @return the instance of Weeks	     */	    public static Weeks weeks(int weeks) {	        switch (weeks) {	            case 0:	                return ZERO;	            case 1:	                return ONE;	            case 2:	                return TWO;	            case 3:	                return THREE;	            case Integer.MAX_VALUE:	                return MAX_VALUE;	            case Integer.MIN_VALUE:	                return MIN_VALUE;	            default:	                return new Weeks(weeks);	        }	    }	
/**	     * Creates a <code>Weeks</code> representing the number of whole weeks	     * between the two specified datetimes.	     *	     * @param start  the start instant, must not be null	     * @param end  the end instant, must not be null	     * @return the period in weeks	     * @throws IllegalArgumentException if the instants are null or invalid	     */	    public static Weeks weeksBetween(ReadableInstant start, ReadableInstant end) {	        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.weeks());	        return Weeks.weeks(amount);	    }	
/**	     * Creates a <code>Weeks</code> representing the number of whole weeks	     * between the two specified partial datetimes.	     * <p>	     * The two partials must contain the same fields, for example you can specify	     * two <code>LocalDate</code> objects.	     *	     * @param start  the start partial date, must not be null	     * @param end  the end partial date, must not be null	     * @return the period in weeks	     * @throws IllegalArgumentException if the partials are null or invalid	     */	    public static Weeks weeksBetween(ReadablePartial start, ReadablePartial end) {	        if (start instanceof LocalDate && end instanceof LocalDate)   {	            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());	            int weeks = chrono.weeks().getDifference(	                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());	            return Weeks.weeks(weeks);	        }	        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);	        return Weeks.weeks(amount);	    }	
/**	     * Creates a <code>Weeks</code> representing the number of whole weeks	     * in the specified interval.	     *	     * @param interval  the interval to extract weeks from, null returns zero	     * @return the period in weeks	     * @throws IllegalArgumentException if the partials are null or invalid	     */	    public static Weeks weeksIn(ReadableInterval interval) {	        if (interval == null)   {	            return Weeks.ZERO;	        }	        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.weeks());	        return Weeks.weeks(amount);	    }	
/**	     * Creates a new <code>Weeks</code> representing the number of complete	     * standard length weeks in the specified period.	     * <p>	     * This factory method converts all fields from the period to hours using standardised	     * durations for each field. Only those fields which have a precise duration in	     * the ISO UTC chronology can be converted.	     * <ul>	     * <li>One week consists of 7 days.	     * <li>One day consists of 24 hours.	     * <li>One hour consists of 60 minutes.	     * <li>One minute consists of 60 weeks.	     * <li>One second consists of 1000 milliseconds.	     * </ul>	     * Months and Years are imprecise and periods containing these values cannot be converted.	     *	     * @param period  the period to get the number of hours from, null returns zero	     * @return the period in weeks	     * @throws IllegalArgumentException if the period contains imprecise duration values	     */	    public static Weeks standardWeeksIn(ReadablePeriod period) {	        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_WEEK);	        return Weeks.weeks(amount);	    }	
/**	     * Creates a new <code>Weeks</code> by parsing a string in the ISO8601 format 'PnW'.	     * <p>	     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the	     * weeks component may be non-zero. If any other component is non-zero, an exception	     * will be thrown.	     *	     * @param periodStr  the period string, null returns zero	     * @return the period in weeks	     * @throws IllegalArgumentException if the string format is invalid	     */	    @FromString	    public static Weeks parseWeeks(String periodStr) {	        if (periodStr == null) {	            return Weeks.ZERO;	        }	        Period p = PARSER.parsePeriod(periodStr);	        return Weeks.weeks(p.getWeeks());	    }	
/**	     * Creates a new instance representing a number of weeks.	     * You should consider using the factory method {@link #weeks(int)}	     * instead of the constructor.	     *	     * @param weeks  the number of weeks to represent	     */	    private Weeks(int weeks) {	        super(weeks);	    }	
/**	     * Resolves singletons.	     * 	     * @return the singleton instance	     */	    private Object readResolve() {	        return Weeks.weeks(getValue());	    }	
/**	     * Gets the duration field type, which is <code>weeks</code>.	     *	     * @return the period type	     */	    public DurationFieldType getFieldType() {	        return DurationFieldType.weeks();	    }	
/**	     * Gets the period type, which is <code>weeks</code>.	     *	     * @return the period type	     */	    public PeriodType getPeriodType() {	        return PeriodType.weeks();	    }	
/**	     * Converts this period in weeks to a period in days assuming a	     * 7 day week.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all weeks are	     * 7 days long.	     * This may not be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of days for this number of weeks	     * @throws ArithmeticException if the number of days is too large to be represented	     */	    public Days toStandardDays() {	        return Days.days(FieldUtils.safeMultiply(getValue(), DateTimeConstants.DAYS_PER_WEEK));	    }	
/**	     * Converts this period in weeks to a period in hours assuming a	     * 7 day week and 24 hour day.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all weeks are	     * 7 days long and all days are 24 hours long.	     * This is not true when daylight savings is considered and may also not	     * be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of hours for this number of weeks	     * @throws ArithmeticException if the number of hours is too large to be represented	     */	    public Hours toStandardHours() {	        return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_WEEK));	    }	
/**	     * Converts this period in weeks to a period in minutes assuming a	     * 7 day week, 24 hour day and 60 minute hour.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all weeks are	     * 7 days long, all days are 24 hours long and all hours are 60 minutes long.	     * This is not true when daylight savings is considered and may also not	     * be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of minutes for this number of weeks	     * @throws ArithmeticException if the number of minutes is too large to be represented	     */	    public Minutes toStandardMinutes() {	        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_WEEK));	    }	
/**	     * Converts this period in weeks to a period in seconds assuming a	     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all weeks are	     * 7 days long, all days are 24 hours long, all hours are 60 minutes long	     * and all minutes are 60 seconds long.	     * This is not true when daylight savings is considered and may also not	     * be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of seconds for this number of weeks	     * @throws ArithmeticException if the number of seconds is too large to be represented	     */	    public Seconds toStandardSeconds() {	        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_WEEK));	    }	
/**	     * Converts this period in weeks to a duration in milliweeks assuming a	     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert from a period to a duration.	     * However to achieve this it makes the assumption that all weeks are	     * 7 days long, all days are 24 hours long, all hours are 60 minutes long	     * and all minutes are 60 seconds long.	     * This is not true when daylight savings time is considered, and may also	     * not be true for some unusual chronologies. However, it is included as it	     * is a useful operation for many applications and business rules.	     * 	     * @return a duration equivalent to this number of weeks	     */	    public Duration toStandardDuration() {	        long weeks = getValue();  // assign to a long	        return new Duration(weeks * DateTimeConstants.MILLIS_PER_WEEK);	    }	
/**	     * Gets the number of weeks that this period represents.	     *	     * @return the number of weeks in the period	     */	    public int getWeeks() {	        return getValue();	    }	
/**	     * Returns a new instance with the specified number of weeks added.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param weeks  the amount of weeks to add, may be negative	     * @return the new period plus the specified number of weeks	     * @throws ArithmeticException if the result overflows an int	     */	    public Weeks plus(int weeks) {	        if (weeks == 0) {	            return this;	        }	        return Weeks.weeks(FieldUtils.safeAdd(getValue(), weeks));	    }	
/**	     * Returns a new instance with the specified number of weeks added.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param weeks  the amount of weeks to add, may be negative, null means zero	     * @return the new period plus the specified number of weeks	     * @throws ArithmeticException if the result overflows an int	     */	    public Weeks plus(Weeks weeks) {	        if (weeks == null) {	            return this;	        }	        return plus(weeks.getValue());	    }	
/**	     * Returns a new instance with the specified number of weeks taken away.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param weeks  the amount of weeks to take away, may be negative	     * @return the new period minus the specified number of weeks	     * @throws ArithmeticException if the result overflows an int	     */	    public Weeks minus(int weeks) {	        return plus(FieldUtils.safeNegate(weeks));	    }	
/**	     * Returns a new instance with the specified number of weeks taken away.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param weeks  the amount of weeks to take away, may be negative, null means zero	     * @return the new period minus the specified number of weeks	     * @throws ArithmeticException if the result overflows an int	     */	    public Weeks minus(Weeks weeks) {	        if (weeks == null) {	            return this;	        }	        return minus(weeks.getValue());	    }	
/**	     * Returns a new instance with the weeks multiplied by the specified scalar.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param scalar  the amount to multiply by, may be negative	     * @return the new period multiplied by the specified scalar	     * @throws ArithmeticException if the result overflows an int	     */	    public Weeks multipliedBy(int scalar) {	        return Weeks.weeks(FieldUtils.safeMultiply(getValue(), scalar));	    }	
/**	     * Returns a new instance with the weeks divided by the specified divisor.	     * The calculation uses integer division, thus 3 divided by 2 is 1.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param divisor  the amount to divide by, may be negative	     * @return the new period divided by the specified divisor	     * @throws ArithmeticException if the divisor is zero	     */	    public Weeks dividedBy(int divisor) {	        if (divisor == 1) {	            return this;	        }	        return Weeks.weeks(getValue() / divisor);	    }	
/**	     * Returns a new instance with the weeks value negated.	     *	     * @return the new period with a negated value	     * @throws ArithmeticException if the result overflows an int	     */	    public Weeks negated() {	        return Weeks.weeks(FieldUtils.safeNegate(getValue()));	    }	
/**	     * Is this weeks instance greater than the specified number of weeks.	     *	     * @param other  the other period, null means zero	     * @return true if this weeks instance is greater than the specified one	     */	    public boolean isGreaterThan(Weeks other) {	        if (other == null) {	            return getValue() > 0;	        }	        return getValue() > other.getValue();	    }	
/**	     * Is this weeks instance less than the specified number of weeks.	     *	     * @param other  the other period, null means zero	     * @return true if this weeks instance is less than the specified one	     */	    public boolean isLessThan(Weeks other) {	        if (other == null) {	            return getValue() < 0;	        }	        return getValue() < other.getValue();	    }	
/**	     * Gets this instance as a String in the ISO8601 duration format.	     * <p>	     * For example, "P4W" represents 4 weeks.	     *	     * @return the value as an ISO8601 string	     */	    @ToString	    public String toString() {	        return "P" + String.valueOf(getValue()) + "W";	    }	
/**	     * Constructor.	     * 	     * @param name  the name to use	     */	    protected DateTimeFieldType(String name) {	        super();	        iName = name;	    }	
/**	     * Get the millis of second field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType millisOfSecond() {	        return MILLIS_OF_SECOND_TYPE;	    }	
/**	     * Get the millis of day field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType millisOfDay() {	        return MILLIS_OF_DAY_TYPE;	    }	
/**	     * Get the second of minute field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType secondOfMinute() {	        return SECOND_OF_MINUTE_TYPE;	    }	
/**	     * Get the second of day field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType secondOfDay() {	        return SECOND_OF_DAY_TYPE;	    }	
/**	     * Get the minute of hour field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType minuteOfHour() {	        return MINUTE_OF_HOUR_TYPE;	    }	
/**	     * Get the minute of day field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType minuteOfDay() {	        return MINUTE_OF_DAY_TYPE;	    }	
/**	     * Get the hour of day (0-23) field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType hourOfDay() {	        return HOUR_OF_DAY_TYPE;	    }	
/**	     * Get the hour of day (offset to 1-24) field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType clockhourOfDay() {	        return CLOCKHOUR_OF_DAY_TYPE;	    }	
/**	     * Get the hour of am/pm (0-11) field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType hourOfHalfday() {	        return HOUR_OF_HALFDAY_TYPE;	    }	
/**	     * Get the hour of am/pm (offset to 1-12) field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType clockhourOfHalfday() {	        return CLOCKHOUR_OF_HALFDAY_TYPE;	    }	
/**	     * Get the AM(0) PM(1) field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType halfdayOfDay() {	        return HALFDAY_OF_DAY_TYPE;	    }	
/**	     * Get the day of week field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType dayOfWeek() {	        return DAY_OF_WEEK_TYPE;	    }	
/**	     * Get the day of month field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType dayOfMonth() {	        return DAY_OF_MONTH_TYPE;	    }	
/**	     * Get the day of year field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType dayOfYear() {	        return DAY_OF_YEAR_TYPE;	    }	
/**	     * Get the week of a week based year field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType weekOfWeekyear() {	        return WEEK_OF_WEEKYEAR_TYPE;	    }	
/**	     * Get the year of a week based year field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType weekyear() {	        return WEEKYEAR_TYPE;	    }	
/**	     * Get the year of a week based year within a century field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType weekyearOfCentury() {	        return WEEKYEAR_OF_CENTURY_TYPE;	    }	
/**	     * Get the month of year field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType monthOfYear() {	        return MONTH_OF_YEAR_TYPE;	    }	
/**	     * Get the year field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType year() {	        return YEAR_TYPE;	    }	
/**	     * Get the year of era field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType yearOfEra() {	        return YEAR_OF_ERA_TYPE;	    }	
/**	     * Get the year of century field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType yearOfCentury() {	        return YEAR_OF_CENTURY_TYPE;	    }	
/**	     * Get the century of era field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType centuryOfEra() {	        return CENTURY_OF_ERA_TYPE;	    }	
/**	     * Get the era field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DateTimeFieldType era() {	        return ERA_TYPE;	    }	
/**	     * Get the name of the field.	     * <p>	     * By convention, names follow a pattern of "dddOfRrr", where "ddd" represents	     * the (singular) duration unit field name and "Rrr" represents the (singular)	     * duration range field name. If the range field is not applicable, then	     * the name of the field is simply the (singular) duration field name.	     * 	     * @return field name	     */	    public String getName() {	        return iName;	    }	
/**	     * Checks whether this field supported in the given Chronology.	     *	     * @param chronology  the chronology to use, null means ISOChronology in default zone	     * @return true if supported	     */	    public boolean isSupported(Chronology chronology) {	        return getField(chronology).isSupported();	    }	
/**	     * Get a suitable debug string.	     * 	     * @return debug string	     */	    public String toString() {	        return getName();	    }	
/**	         * Constructor.	         * 	         * @param name  the name to use	         * @param ordinal  the byte value for the oridinal index	         * @param unitType  the unit duration type	         * @param rangeType  the range duration type	         */	        StandardDateTimeFieldType(String name, byte ordinal,	                                  DurationFieldType unitType, DurationFieldType rangeType) {	            super(name);	            iOrdinal = ordinal;	            iUnitType = unitType;	            iRangeType = rangeType;	        }	
/** @inheritdoc */	        public DurationFieldType getDurationType() {	            return iUnitType;	        }	
/** @inheritdoc */	        public DurationFieldType getRangeDurationType() {	            return iRangeType;	        }	
/** @inheritdoc */	        public DateTimeField getField(Chronology chronology) {	            chronology = DateTimeUtils.getChronology(chronology);		            switch (iOrdinal) {	                case ERA:	                    return chronology.era();	                case YEAR_OF_ERA:	                    return chronology.yearOfEra();	                case CENTURY_OF_ERA:	                    return chronology.centuryOfEra();	                case YEAR_OF_CENTURY:	                    return chronology.yearOfCentury();	                case YEAR:	                    return chronology.year();	                case DAY_OF_YEAR:	                    return chronology.dayOfYear();	                case MONTH_OF_YEAR:	                    return chronology.monthOfYear();	                case DAY_OF_MONTH:	                    return chronology.dayOfMonth();	                case WEEKYEAR_OF_CENTURY:	                    return chronology.weekyearOfCentury();	                case WEEKYEAR:	                    return chronology.weekyear();	                case WEEK_OF_WEEKYEAR:	                    return chronology.weekOfWeekyear();	                case DAY_OF_WEEK:	                    return chronology.dayOfWeek();	                case HALFDAY_OF_DAY:	                    return chronology.halfdayOfDay();	                case HOUR_OF_HALFDAY:	                    return chronology.hourOfHalfday();	                case CLOCKHOUR_OF_HALFDAY:	                    return chronology.clockhourOfHalfday();	                case CLOCKHOUR_OF_DAY:	                    return chronology.clockhourOfDay();	                case HOUR_OF_DAY:	                    return chronology.hourOfDay();	                case MINUTE_OF_DAY:	                    return chronology.minuteOfDay();	                case MINUTE_OF_HOUR:	                    return chronology.minuteOfHour();	                case SECOND_OF_DAY:	                    return chronology.secondOfDay();	                case SECOND_OF_MINUTE:	                    return chronology.secondOfMinute();	                case MILLIS_OF_DAY:	                    return chronology.millisOfDay();	                case MILLIS_OF_SECOND:	                    return chronology.millisOfSecond();	                default:	                    // Shouldn't happen.	                    throw new InternalError();	            }	        }	
/**	         * Ensure a singleton is returned.	         * 	         * @return the singleton type	         */	        private Object readResolve() {	            switch (iOrdinal) {	                case ERA:	                    return ERA_TYPE;	                case YEAR_OF_ERA:	                    return YEAR_OF_ERA_TYPE;	                case CENTURY_OF_ERA:	                    return CENTURY_OF_ERA_TYPE;	                case YEAR_OF_CENTURY:	                    return YEAR_OF_CENTURY_TYPE;	                case YEAR:	                    return YEAR_TYPE;	                case DAY_OF_YEAR:	                    return DAY_OF_YEAR_TYPE;	                case MONTH_OF_YEAR:	                    return MONTH_OF_YEAR_TYPE;	                case DAY_OF_MONTH:	                    return DAY_OF_MONTH_TYPE;	                case WEEKYEAR_OF_CENTURY:	                    return WEEKYEAR_OF_CENTURY_TYPE;	                case WEEKYEAR:	                    return WEEKYEAR_TYPE;	                case WEEK_OF_WEEKYEAR:	                    return WEEK_OF_WEEKYEAR_TYPE;	                case DAY_OF_WEEK:	                    return DAY_OF_WEEK_TYPE;	                case HALFDAY_OF_DAY:	                    return HALFDAY_OF_DAY_TYPE;	                case HOUR_OF_HALFDAY:	                    return HOUR_OF_HALFDAY_TYPE;	                case CLOCKHOUR_OF_HALFDAY:	                    return CLOCKHOUR_OF_HALFDAY_TYPE;	                case CLOCKHOUR_OF_DAY:	                    return CLOCKHOUR_OF_DAY_TYPE;	                case HOUR_OF_DAY:	                    return HOUR_OF_DAY_TYPE;	                case MINUTE_OF_DAY:	                    return MINUTE_OF_DAY_TYPE;	                case MINUTE_OF_HOUR:	                    return MINUTE_OF_HOUR_TYPE;	                case SECOND_OF_DAY:	                    return SECOND_OF_DAY_TYPE;	                case SECOND_OF_MINUTE:	                    return SECOND_OF_MINUTE_TYPE;	                case MILLIS_OF_DAY:	                    return MILLIS_OF_DAY_TYPE;	                case MILLIS_OF_SECOND:	                    return MILLIS_OF_SECOND_TYPE;	                default:	                    // Shouldn't happen.	                    return this;	            }	        }	
/**	     * Parses a {@code LocalDateTime} from the specified string.	     * <p>	     * This uses {@link ISODateTimeFormat#localDateOptionalTimeParser()}.	     * 	     * @param str  the string to parse, not null	     * @since 2.0	     */	    @FromString	    public static LocalDateTime parse(String str) {	        return parse(str, ISODateTimeFormat.localDateOptionalTimeParser());	    }	
/**	     * Parses a {@code LocalDateTime} from the specified string using a formatter.	     * 	     * @param str  the string to parse, not null	     * @param formatter  the formatter to use, not null	     * @since 2.0	     */	    public static LocalDateTime parse(String str, DateTimeFormatter formatter) {	        return formatter.parseLocalDateTime(str);	    }	
/**	     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>	     * using exactly the same field values.	     * <p>	     * Each field is queried from the Calendar and assigned to the LocalDateTime.	     * This is useful if you have been using the Calendar as a local date,	     * ignoring the zone.	     * <p>	     * One advantage of this method is that this method is unaffected if the	     * version of the time zone data differs between the JDK and Joda-Time.	     * That is because the local field values are transferred, calculated using	     * the JDK time zone data and without using the Joda-Time time zone data.	     * <p>	     * This factory method ignores the type of the calendar and always	     * creates a LocalDateTime with ISO chronology. It is expected that you	     * will only pass in instances of <code>GregorianCalendar</code> however	     * this is not validated.	     *	     * @param calendar  the Calendar to extract fields from	     * @return the created LocalDateTime	     * @throws IllegalArgumentException if the calendar is null	     * @throws IllegalArgumentException if the date is invalid for the ISO chronology	     */	    public static LocalDateTime fromCalendarFields(Calendar calendar) {	        if (calendar == null) {	            throw new IllegalArgumentException("The calendar must not be null");	        }	        return new LocalDateTime(	            calendar.get(Calendar.YEAR),	            calendar.get(Calendar.MONTH) + 1,	            calendar.get(Calendar.DAY_OF_MONTH),	            calendar.get(Calendar.HOUR_OF_DAY),	            calendar.get(Calendar.MINUTE),	            calendar.get(Calendar.SECOND),	            calendar.get(Calendar.MILLISECOND)	        );	    }	
/**	     * Constructs a LocalDateTime from a <code>java.util.Date</code>	     * using exactly the same field values.	     * <p>	     * Each field is queried from the Date and assigned to the LocalDateTime.	     * This is useful if you have been using the Date as a local date,	     * ignoring the zone.	     * <p>	     * One advantage of this method is that this method is unaffected if the	     * version of the time zone data differs between the JDK and Joda-Time.	     * That is because the local field values are transferred, calculated using	     * the JDK time zone data and without using the Joda-Time time zone data.	     * <p>	     * This factory method always creates a LocalDateTime with ISO chronology.	     *	     * @param date  the Date to extract fields from	     * @return the created LocalDateTime	     * @throws IllegalArgumentException if the calendar is null	     * @throws IllegalArgumentException if the date is invalid for the ISO chronology	     */	    @SuppressWarnings("deprecation")	    public static LocalDateTime fromDateFields(Date date) {	        if (date == null) {	            throw new IllegalArgumentException("The date must not be null");	        }	        return new LocalDateTime(	            date.getYear() + 1900,	            date.getMonth() + 1,	            date.getDate(),	            date.getHours(),	            date.getMinutes(),	            date.getSeconds(),	            (int) (date.getTime() % 1000)	        );	    }	
/**	     * Constructs an instance set to the current local time evaluated using	     * ISO chronology in the default zone.	     * <p>	     * Once the constructor is completed, the zone is no longer used.	     */	    public LocalDateTime() {	        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());	    }	
/**	     * Constructs an instance set to the current local time evaluated using	     * ISO chronology in the specified zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     * Once the constructor is completed, the zone is no longer used.	     *	     * @param zone  the time zone, null means default zone	     */	    public LocalDateTime(DateTimeZone zone) {	        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));	    }	
/**	     * Constructs an instance set to the current local time evaluated using	     * specified chronology.	     * <p>	     * If the chronology is null, ISO chronology in the default time zone is used.	     * Once the constructor is completed, the zone is no longer used.	     *	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public LocalDateTime(Chronology chronology) {	        this(DateTimeUtils.currentTimeMillis(), chronology);	    }	
/**	     * Constructs an instance set to the local time defined by the specified	     * instant evaluated using ISO chronology in the default zone.	     * <p>	     * Once the constructor is completed, the zone is no longer used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     */	    public LocalDateTime(long instant) {	        this(instant, ISOChronology.getInstance());	    }	
/**	     * Constructs an instance set to the local time defined by the specified	     * instant evaluated using ISO chronology in the specified zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     * Once the constructor is completed, the zone is no longer used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param zone  the time zone, null means default zone	     */	    public LocalDateTime(long instant, DateTimeZone zone) {	        this(instant, ISOChronology.getInstance(zone));	    }	
/**	     * Constructs an instance set to the local time defined by the specified	     * instant evaluated using the specified chronology.	     * <p>	     * If the chronology is null, ISO chronology in the default zone is used.	     * Once the constructor is completed, the zone is no longer used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public LocalDateTime(long instant, Chronology chronology) {	        chronology = DateTimeUtils.getChronology(chronology);	        	        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);	        iLocalMillis = localMillis;	        iChronology = chronology.withUTC();	    }	
/**	     * Constructs an instance from an Object that represents a datetime.	     * <p>	     * If the object contains no chronology, <code>ISOChronology</code> is used.	     * If the object contains no time zone, the default zone is used.	     * Once the constructor is completed, the zone is no longer used.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePartial, ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.	     * The default String converter ignores the zone and only parses the field values.	     *	     * @param instant  the datetime object	     * @throws IllegalArgumentException if the instant is invalid	     */	    public LocalDateTime(Object instant) {	        this(instant, (Chronology) null);	    }	
/**	     * Constructs an instance from an Object that represents a datetime,	     * forcing the time zone to that specified.	     * <p>	     * If the object contains no chronology, <code>ISOChronology</code> is used.	     * If the specified time zone is null, the default zone is used.	     * Once the constructor is completed, the zone is no longer used.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePartial, ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.	     * The default String converter ignores the zone and only parses the field values.	     *	     * @param instant  the datetime object	     * @param zone  the time zone	     * @throws IllegalArgumentException if the instant is invalid	     */	    public LocalDateTime(Object instant, DateTimeZone zone) {	        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);	        Chronology chronology = converter.getChronology(instant, zone);	        chronology = DateTimeUtils.getChronology(chronology);	        iChronology = chronology.withUTC();	        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser());	        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);	    }	
/**	     * Constructs an instance from an Object that represents a datetime,	     * using the specified chronology.	     * <p>	     * If the chronology is null, ISO in the default time zone is used.	     * Once the constructor is completed, the zone is no longer used.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePartial, ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.	     * The default String converter ignores the zone and only parses the field values.	     *	     * @param instant  the datetime object	     * @param chronology  the chronology	     * @throws IllegalArgumentException if the instant is invalid	     */	    public LocalDateTime(Object instant, Chronology chronology) {	        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);	        chronology = converter.getChronology(instant, chronology);	        chronology = DateTimeUtils.getChronology(chronology);	        iChronology = chronology.withUTC();	        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser());	        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);	    }	
/**	     * Constructs an instance set to the specified date and time	     * using <code>ISOChronology</code>.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     */	    public LocalDateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour) {	        this(year, monthOfYear, dayOfMonth, hourOfDay,	            minuteOfHour, 0, 0, ISOChronology.getInstanceUTC());	    }	
/**	     * Constructs an instance set to the specified date and time	     * using <code>ISOChronology</code>.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     */	    public LocalDateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute) {	        this(year, monthOfYear, dayOfMonth, hourOfDay,	            minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC());	    }	
/**	     * Constructs an instance set to the specified date and time	     * using <code>ISOChronology</code>.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     */	    public LocalDateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute,	            int millisOfSecond) {	        this(year, monthOfYear, dayOfMonth, hourOfDay,	            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstanceUTC());	    }	
/**	     * Constructs an instance set to the specified date and time	     * using the specified chronology, whose zone is ignored.	     * <p>	     * If the chronology is null, <code>ISOChronology</code> is used.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public LocalDateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute,	            int millisOfSecond,	            Chronology chronology) {	        super();	        chronology = DateTimeUtils.getChronology(chronology).withUTC();	        long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,	            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	        iChronology = chronology;	        iLocalMillis = instant;	    }	
/**	     * Gets the number of fields in this partial, which is four.	     * The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.	     *	     * @return the field count, four	     */	    public int size() {	        return 4;	    }	
/**	     * Gets the field for a specific index in the chronology specified.	     * <p>	     * This method must not use any instance variables.	     *	     * @param index  the index to retrieve	     * @param chrono  the chronology to use	     * @return the field	     */	    protected DateTimeField getField(int index, Chronology chrono) {	        switch (index) {	            case YEAR:	                return chrono.year();	            case MONTH_OF_YEAR:	                return chrono.monthOfYear();	            case DAY_OF_MONTH:	                return chrono.dayOfMonth();	            case MILLIS_OF_DAY:	                return chrono.millisOfDay();	            default:	                throw new IndexOutOfBoundsException("Invalid index: " + index);	        }	    }	
/**	     * Gets the value of the field at the specifed index.	     * <p>	     * This method is required to support the <code>ReadablePartial</code>	     * interface. The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.	     *	     * @param index  the index, zero to two	     * @return the value	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public int getValue(int index) {	        switch (index) {	            case YEAR:	                return getChronology().year().get(getLocalMillis());	            case MONTH_OF_YEAR:	                return getChronology().monthOfYear().get(getLocalMillis());	            case DAY_OF_MONTH:	                return getChronology().dayOfMonth().get(getLocalMillis());	            case MILLIS_OF_DAY:	                return getChronology().millisOfDay().get(getLocalMillis());	            default:	                throw new IndexOutOfBoundsException("Invalid index: " + index);	        }	    }	
/**	     * Get the value of one of the fields of a datetime.	     * <p>	     * This method gets the value of the specified field.	     * For example:	     * <pre>	     * DateTime dt = new DateTime();	     * int year = dt.get(DateTimeFieldType.year());	     * </pre>	     *	     * @param type  a field type, usually obtained from DateTimeFieldType, not null	     * @return the value of that field	     * @throws IllegalArgumentException if the field type is null	     */	    public int get(DateTimeFieldType type) {	        if (type == null) {	            throw new IllegalArgumentException("The DateTimeFieldType must not be null");	        }	        return type.getField(getChronology()).get(getLocalMillis());	    }	
/**	     * Checks if the field type specified is supported by this	     * local datetime and chronology.	     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.	     *	     * @param type  a field type, usually obtained from DateTimeFieldType	     * @return true if the field type is supported	     */	    public boolean isSupported(DateTimeFieldType type) {	        if (type == null) {	            return false;	        }	        return type.getField(getChronology()).isSupported();	    }	
/**	     * Checks if the duration type specified is supported by this	     * local datetime and chronology.	     *	     * @param type  a duration type, usually obtained from DurationFieldType	     * @return true if the field type is supported	     */	    public boolean isSupported(DurationFieldType type) {	        if (type == null) {	            return false;	        }	        return type.getField(getChronology()).isSupported();	    }	
/**	     * Gets the milliseconds of the datetime instant from the Java epoch	     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).	     *	     * @return the number of milliseconds since 1970-01-01T00:00:00	     * @since 1.5 (previously private)	     */	    protected long getLocalMillis() {	        return iLocalMillis;	    }	
/**	     * Gets the chronology of the datetime.	     *	     * @return the Chronology that the datetime is using	     */	    public Chronology getChronology() {	        return iChronology;	    }	
/**	     * Compares this ReadablePartial with another returning true if the chronology,	     * field types and values are equal.	     *	     * @param partial  an object to check against	     * @return true if fields and values are equal	     */	    public boolean equals(Object partial) {	        // override to perform faster	        if (this == partial) {	            return true;	        }	        if (partial instanceof LocalDateTime) {	            LocalDateTime other = (LocalDateTime) partial;	            if (iChronology.equals(other.iChronology)) {	                return iLocalMillis == other.iLocalMillis;	            }	        }	        return super.equals(partial);	    }	
/**	     * Compares this partial with another returning an integer	     * indicating the order.	     * <p>	     * The fields are compared in order, from largest to smallest.	     * The first field that is non-equal is used to determine the result.	     * <p>	     * The specified object must be a partial instance whose field types	     * match those of this partial.	     * <p>	     * NOTE: This implementation violates the Comparable contract.	     * This method will accept any instance of ReadablePartial as input.	     * However, it is possible that some implementations of ReadablePartial	     * exist that do not extend AbstractPartial, and thus will throw a	     * ClassCastException if compared in the opposite direction.	     * The cause of this problem is that ReadablePartial doesn't define	     * the compareTo() method, however we can't change that until v2.0.	     *	     * @param partial  an object to check against	     * @return negative if this is less, zero if equal, positive if greater	     * @throws ClassCastException if the partial is the wrong class	     *  or if it has field types that don't match	     * @throws NullPointerException if the partial is null	     */	    public int compareTo(ReadablePartial partial) {	        // override to perform faster	        if (this == partial) {	            return 0;	        }	        if (partial instanceof LocalDateTime) {	            LocalDateTime other = (LocalDateTime) partial;	            if (iChronology.equals(other.iChronology)) {	                return (iLocalMillis < other.iLocalMillis ? -1 :	                            (iLocalMillis == other.iLocalMillis ? 0 : 1));		            }	        }	        return super.compareTo(partial);	    }	
/**	     * Converts this object to a DateTime using the default zone.	     * <p>	     * This method will throw an exception if the datetime that would be	     * created does not exist when the time zone is taken into account.	     * 	     * @return <code>this</code>	     */	    public DateTime toDateTime() {	        return toDateTime((DateTimeZone) null);	    }	
/**	     * Converts this object to a DateTime using the specified zone.	     * <p>	     * This method will throw an exception if the datetime that would be	     * created does not exist when the time zone is taken into account.	     * 	     * @param zone time zone to apply, or default if null	     * @return a DateTime using the same millis	     */	    public DateTime toDateTime(DateTimeZone zone) {	        zone = DateTimeUtils.getZone(zone);	        Chronology chrono = iChronology.withZone(zone);	        return new DateTime(	                getYear(), getMonthOfYear(), getDayOfMonth(),	                getHourOfDay(), getMinuteOfHour(),	                getSecondOfMinute(), getMillisOfSecond(), chrono);	    }	
/**	     * Converts this object to a LocalDate with the same date and chronology.	     *	     * @return a LocalDate with the same date and chronology	     */	    public LocalDate toLocalDate() {	        return new LocalDate(getLocalMillis(), getChronology());	    }	
/**	     * Converts this object to a LocalTime with the same time and chronology.	     *	     * @return a LocalTime with the same time and chronology	     */	    public LocalTime toLocalTime() {	        return new LocalTime(getLocalMillis(), getChronology());	    }	
/**	     * Get the date time as a <code>java.util.Date</code>.	     * <p>	     * The <code>Date</code> object created has exactly the same fields as this	     * date-time, except when the time would be invalid due to a daylight savings	     * gap. In that case, the time will be set to the earliest valid time after the gap.	     * <p>	     * In the case of a daylight savings overlap, the earlier instant is selected.	     * <p>	     * Converting to a JDK Date is full of complications as the JDK Date constructor	     * doesn't behave as you might expect around DST transitions. This method works	     * by taking a first guess and then adjusting. This also handles the situation	     * where the JDK time zone data differs from the Joda-Time time zone data.	     *	     * @return a Date initialised with this date-time, never null	     * @since 2.0	     */	    @SuppressWarnings("deprecation")	    public Date toDate() {	        int dom = getDayOfMonth();	        Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom,	                        getHourOfDay(), getMinuteOfHour(), getSecondOfMinute());	        date.setTime(date.getTime() + getMillisOfSecond());	        LocalDateTime check = LocalDateTime.fromDateFields(date);	        if (check.isBefore(this)) {	            // DST gap	            // move forward in units of one minute until equal/after	            while (check.isBefore(this)) {	                date.setTime(date.getTime() + 60000);	                check = LocalDateTime.fromDateFields(date);	            }	            // move back in units of one second until date wrong	            while (check.isBefore(this) == false) {	                date.setTime(date.getTime() - 1000);	                check = LocalDateTime.fromDateFields(date);	            }	            date.setTime(date.getTime() + 1000);	        } else if (check.equals(this)) {	            // check for DST overlap	            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());	            check = LocalDateTime.fromDateFields(earlier);	            if (check.equals(this)) {	                date = earlier;	            }	        }	        return date;	    }	
/**	     * Returns a copy of this datetime with different local millis.	     * <p>	     * The returned object will be a new instance of the same type.	     * Only the millis will change, the chronology is kept.	     * The returned object will be either be a new instance or <code>this</code>.	     *	     * @param newMillis  the new millis, from 1970-01-01T00:00:00	     * @return a copy of this datetime with different millis	     */	    LocalDateTime withLocalMillis(long newMillis) {	        return (newMillis == getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));	    }	
/**	     * Returns a copy of this datetime with the specified date,	     * retaining the time fields.	     * <p>	     * If the date is already the date passed in, then <code>this</code> is returned.	     * <p>	     * To set a single field use the properties, for example:	     * <pre>	     * DateTime set = dt.monthOfYear().setCopy(6);	     * </pre>	     *	     * @param year  the new year value	     * @param monthOfYear  the new monthOfYear value	     * @param dayOfMonth  the new dayOfMonth value	     * @return a copy of this datetime with a different date	     * @throws IllegalArgumentException if any value if invalid	     */	    public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) {	        Chronology chrono = getChronology();	        long instant = getLocalMillis();	        instant = chrono.year().set(instant, year);	        instant = chrono.monthOfYear().set(instant, monthOfYear);	        instant = chrono.dayOfMonth().set(instant, dayOfMonth);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime with the specified time,	     * retaining the date fields.	     * <p>	     * If the time is already the time passed in, then <code>this</code> is returned.	     * <p>	     * To set a single field use the properties, for example:	     * <pre>	     * LocalDateTime set = dt.hourOfDay().setCopy(6);	     * </pre>	     *	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     * @return a copy of this datetime with a different time	     * @throws IllegalArgumentException if any value if invalid	     */	    public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {	        Chronology chrono = getChronology();	        long instant = getLocalMillis();	        instant = chrono.hourOfDay().set(instant, hourOfDay);	        instant = chrono.minuteOfHour().set(instant, minuteOfHour);	        instant = chrono.secondOfMinute().set(instant, secondOfMinute);	        instant = chrono.millisOfSecond().set(instant, millisOfSecond);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime with the partial set of fields	     * replacing those from this instance.	     * <p>	     * For example, if the partial is a <code>TimeOfDay</code> then the time fields	     * would be changed in the returned instance.	     * If the partial is null, then <code>this</code> is returned.	     *	     * @param partial  the partial set of fields to apply to this datetime, null ignored	     * @return a copy of this datetime with a different set of fields	     * @throws IllegalArgumentException if any value is invalid	     */	    public LocalDateTime withFields(ReadablePartial partial) {	        if (partial == null) {	            return this;	        }	        return withLocalMillis(getChronology().set(partial, getLocalMillis()));	    }	
/**	     * Returns a copy of this datetime with the specified field set to a new value.	     * <p>	     * For example, if the field type is <code>hourOfDay</code> then the hour of day	     * field would be changed in the returned instance.	     * If the field type is null, then <code>this</code> is returned.	     * <p>	     * These three lines are equivalent:	     * <pre>	     * LocalDateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);	     * LocalDateTime updated = dt.dayOfMonth().setCopy(6);	     * LocalDateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);	     * </pre>	     *	     * @param fieldType  the field type to set, not null	     * @param value  the value to set	     * @return a copy of this datetime with the field set	     * @throws IllegalArgumentException if the value is null or invalid	     */	    public LocalDateTime withField(DateTimeFieldType fieldType, int value) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field must not be null");	        }	        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime with the value of the specified	     * field increased.	     * <p>	     * If the addition is zero or the field is null, then <code>this</code> is returned.	     * <p>	     * These three lines are equivalent:	     * <pre>	     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);	     * LocalDateTime added = dt.plusYears(6);	     * LocalDateTime added = dt.plus(Period.years(6));	     * </pre>	     *	     * @param fieldType  the field type to add to, not null	     * @param amount  the amount to add	     * @return a copy of this datetime with the field updated	     * @throws IllegalArgumentException if the value is null or invalid	     * @throws ArithmeticException if the result exceeds the internal capacity	     */	    public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field must not be null");	        }	        if (amount == 0) {	            return this;	        }	        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime with the specified duration added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     *	     * @param durationToAdd  the duration to add to this one, null means zero	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this datetime with the duration added	     * @throws ArithmeticException if the result exceeds the internal capacity	     */	    public LocalDateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {	        if (durationToAdd == null || scalar == 0) {	            return this;	        }	        long instant = getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime with the specified period added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * <p>	     * This method is typically used to add multiple copies of complex	     * period instances. Adding one field is best achieved using methods	     * like {@link #withFieldAdded(DurationFieldType, int)}	     * or {@link #plusYears(int)}.	     *	     * @param period  the period to add to this one, null means zero	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this datetime with the period added	     * @throws ArithmeticException if the result exceeds the internal capacity	     */	    public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar) {	        if (period == null || scalar == 0) {	            return this;	        }	        long instant = getChronology().add(period, getLocalMillis(), scalar);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime with the specified duration added.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     *	     * @param duration  the duration to add to this one, null means zero	     * @return a copy of this datetime with the duration added	     * @throws ArithmeticException if the result exceeds the internal capacity	     */	    public LocalDateTime plus(ReadableDuration duration) {	        return withDurationAdded(duration, 1);	    }	
/**	     * Returns a copy of this datetime with the specified period added.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to add complex period instances.	     * Adding one field is best achieved using methods	     * like {@link #plusYears(int)}.	     *	     * @param period  the period to add to this one, null means zero	     * @return a copy of this datetime with the period added	     * @throws ArithmeticException if the result exceeds the internal capacity	     */	    public LocalDateTime plus(ReadablePeriod period) {	        return withPeriodAdded(period, 1);	    }	
/**	     * Returns a copy of this datetime plus the specified number of years.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime added = dt.plusYears(6);	     * LocalDateTime added = dt.plus(Period.years(6));	     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);	     * </pre>	     *	     * @param years  the amount of years to add, may be negative	     * @return the new LocalDateTime plus the increased years	     */	    public LocalDateTime plusYears(int years) {	        if (years == 0) {	            return this;	        }	        long instant = getChronology().years().add(getLocalMillis(), years);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime plus the specified number of months.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime added = dt.plusMonths(6);	     * LocalDateTime added = dt.plus(Period.months(6));	     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);	     * </pre>	     *	     * @param months  the amount of months to add, may be negative	     * @return the new LocalDateTime plus the increased months	     */	    public LocalDateTime plusMonths(int months) {	        if (months == 0) {	            return this;	        }	        long instant = getChronology().months().add(getLocalMillis(), months);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime plus the specified number of weeks.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime added = dt.plusWeeks(6);	     * LocalDateTime added = dt.plus(Period.weeks(6));	     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);	     * </pre>	     *	     * @param weeks  the amount of weeks to add, may be negative	     * @return the new LocalDateTime plus the increased weeks	     */	    public LocalDateTime plusWeeks(int weeks) {	        if (weeks == 0) {	            return this;	        }	        long instant = getChronology().weeks().add(getLocalMillis(), weeks);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime plus the specified number of days.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime added = dt.plusDays(6);	     * LocalDateTime added = dt.plus(Period.days(6));	     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);	     * </pre>	     *	     * @param days  the amount of days to add, may be negative	     * @return the new LocalDateTime plus the increased days	     */	    public LocalDateTime plusDays(int days) {	        if (days == 0) {	            return this;	        }	        long instant = getChronology().days().add(getLocalMillis(), days);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime plus the specified number of hours.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime added = dt.plusHours(6);	     * LocalDateTime added = dt.plus(Period.hours(6));	     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);	     * </pre>	     *	     * @param hours  the amount of hours to add, may be negative	     * @return the new LocalDateTime plus the increased hours	     */	    public LocalDateTime plusHours(int hours) {	        if (hours == 0) {	            return this;	        }	        long instant = getChronology().hours().add(getLocalMillis(), hours);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime plus the specified number of minutes.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime added = dt.plusMinutes(6);	     * LocalDateTime added = dt.plus(Period.minutes(6));	     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);	     * </pre>	     *	     * @param minutes  the amount of minutes to add, may be negative	     * @return the new LocalDateTime plus the increased minutes	     */	    public LocalDateTime plusMinutes(int minutes) {	        if (minutes == 0) {	            return this;	        }	        long instant = getChronology().minutes().add(getLocalMillis(), minutes);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime plus the specified number of seconds.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime added = dt.plusSeconds(6);	     * LocalDateTime added = dt.plus(Period.seconds(6));	     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);	     * </pre>	     *	     * @param seconds  the amount of seconds to add, may be negative	     * @return the new LocalDateTime plus the increased seconds	     */	    public LocalDateTime plusSeconds(int seconds) {	        if (seconds == 0) {	            return this;	        }	        long instant = getChronology().seconds().add(getLocalMillis(), seconds);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime plus the specified number of millis.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime added = dt.plusMillis(6);	     * LocalDateTime added = dt.plus(Period.millis(6));	     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);	     * </pre>	     *	     * @param millis  the amount of millis to add, may be negative	     * @return the new LocalDateTime plus the increased millis	     */	    public LocalDateTime plusMillis(int millis) {	        if (millis == 0) {	            return this;	        }	        long instant = getChronology().millis().add(getLocalMillis(), millis);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime with the specified duration taken away.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     *	     * @param duration  the duration to reduce this instant by	     * @return a copy of this datetime with the duration taken away	     * @throws ArithmeticException if the result exceeds the internal capacity	     */	    public LocalDateTime minus(ReadableDuration duration) {	        return withDurationAdded(duration, -1);	    }	
/**	     * Returns a copy of this datetime with the specified period taken away.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to subtract complex period instances.	     * Subtracting one field is best achieved using methods	     * like {@link #minusYears(int)}.	     *	     * @param period  the period to reduce this instant by	     * @return a copy of this datetime with the period taken away	     * @throws ArithmeticException if the result exceeds the internal capacity	     */	    public LocalDateTime minus(ReadablePeriod period) {	        return withPeriodAdded(period, -1);	    }	
/**	     * Returns a copy of this datetime minus the specified number of years.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime subtracted = dt.minusYears(6);	     * LocalDateTime subtracted = dt.minus(Period.years(6));	     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);	     * </pre>	     *	     * @param years  the amount of years to subtract, may be negative	     * @return the new LocalDateTime minus the increased years	     */	    public LocalDateTime minusYears(int years) {	        if (years == 0) {	            return this;	        }	        long instant = getChronology().years().subtract(getLocalMillis(), years);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime minus the specified number of months.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime subtracted = dt.minusMonths(6);	     * LocalDateTime subtracted = dt.minus(Period.months(6));	     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);	     * </pre>	     *	     * @param months  the amount of months to subtract, may be negative	     * @return the new LocalDateTime minus the increased months	     */	    public LocalDateTime minusMonths(int months) {	        if (months == 0) {	            return this;	        }	        long instant = getChronology().months().subtract(getLocalMillis(), months);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime minus the specified number of weeks.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime subtracted = dt.minusWeeks(6);	     * LocalDateTime subtracted = dt.minus(Period.weeks(6));	     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);	     * </pre>	     *	     * @param weeks  the amount of weeks to subtract, may be negative	     * @return the new LocalDateTime minus the increased weeks	     */	    public LocalDateTime minusWeeks(int weeks) {	        if (weeks == 0) {	            return this;	        }	        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime minus the specified number of days.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime subtracted = dt.minusDays(6);	     * LocalDateTime subtracted = dt.minus(Period.days(6));	     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);	     * </pre>	     *	     * @param days  the amount of days to subtract, may be negative	     * @return the new LocalDateTime minus the increased days	     */	    public LocalDateTime minusDays(int days) {	        if (days == 0) {	            return this;	        }	        long instant = getChronology().days().subtract(getLocalMillis(), days);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime minus the specified number of hours.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime subtracted = dt.minusHours(6);	     * LocalDateTime subtracted = dt.minus(Period.hours(6));	     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);	     * </pre>	     *	     * @param hours  the amount of hours to subtract, may be negative	     * @return the new LocalDateTime minus the increased hours	     */	    public LocalDateTime minusHours(int hours) {	        if (hours == 0) {	            return this;	        }	        long instant = getChronology().hours().subtract(getLocalMillis(), hours);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime minus the specified number of minutes.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime subtracted = dt.minusMinutes(6);	     * LocalDateTime subtracted = dt.minus(Period.minutes(6));	     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);	     * </pre>	     *	     * @param minutes  the amount of minutes to subtract, may be negative	     * @return the new LocalDateTime minus the increased minutes	     */	    public LocalDateTime minusMinutes(int minutes) {	        if (minutes == 0) {	            return this;	        }	        long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime minus the specified number of seconds.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime subtracted = dt.minusSeconds(6);	     * LocalDateTime subtracted = dt.minus(Period.seconds(6));	     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);	     * </pre>	     *	     * @param seconds  the amount of seconds to subtract, may be negative	     * @return the new LocalDateTime minus the increased seconds	     */	    public LocalDateTime minusSeconds(int seconds) {	        if (seconds == 0) {	            return this;	        }	        long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this datetime minus the specified number of millis.	     * <p>	     * This LocalDateTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalDateTime subtracted = dt.minusMillis(6);	     * LocalDateTime subtracted = dt.minus(Period.millis(6));	     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);	     * </pre>	     *	     * @param millis  the amount of millis to subtract, may be negative	     * @return the new LocalDateTime minus the increased millis	     */	    public LocalDateTime minusMillis(int millis) {	        if (millis == 0) {	            return this;	        }	        long instant = getChronology().millis().subtract(getLocalMillis(), millis);	        return withLocalMillis(instant);	    }	
/**	     * Gets the property object for the specified type, which contains many	     * useful methods.	     *	     * @param fieldType  the field type to get the chronology for	     * @return the property object	     * @throws IllegalArgumentException if the field is null or unsupported	     */	    public Property property(DateTimeFieldType fieldType) {	        if (fieldType == null) {	            throw new IllegalArgumentException("The DateTimeFieldType must not be null");	        }	        if (isSupported(fieldType) == false) {	            throw new IllegalArgumentException("Field '" + fieldType + "' is not supported");	        }	        return new Property(this, fieldType.getField(getChronology()));	    }	
/**	     * Get the era field value.	     *	     * @return the era	     */	    public int getEra() {	        return getChronology().era().get(getLocalMillis());	    }	
/**	     * Get the year of era field value.	     *	     * @return the year of era	     */	    public int getCenturyOfEra() {	        return getChronology().centuryOfEra().get(getLocalMillis());	    }	
/**	     * Get the year of era field value.	     *	     * @return the year of era	     */	    public int getYearOfEra() {	        return getChronology().yearOfEra().get(getLocalMillis());	    }	
/**	     * Get the year of century field value.	     *	     * @return the year of century	     */	    public int getYearOfCentury() {	        return getChronology().yearOfCentury().get(getLocalMillis());	    }	
/**	     * Get the year field value.	     *	     * @return the year	     */	    public int getYear() {	        return getChronology().year().get(getLocalMillis());	    }	
/**	     * Get the weekyear field value.	     * <p>	     * The weekyear is the year that matches with the weekOfWeekyear field.	     * In the standard ISO8601 week algorithm, the first week of the year	     * is that in which at least 4 days are in the year. As a result of this	     * definition, day 1 of the first week may be in the previous year.	     * The weekyear allows you to query the effective year for that day.	     *	     * @return the weekyear	     */	    public int getWeekyear() {	        return getChronology().weekyear().get(getLocalMillis());	    }	
/**	     * Get the month of year field value.	     *	     * @return the month of year	     */	    public int getMonthOfYear() {	        return getChronology().monthOfYear().get(getLocalMillis());	    }	
/**	     * Get the week of weekyear field value.	     *	     * @return the week of a week based year	     */	    public int getWeekOfWeekyear() {	        return getChronology().weekOfWeekyear().get(getLocalMillis());	    }	
/**	     * Get the day of year field value.	     *	     * @return the day of year	     */	    public int getDayOfYear() {	        return getChronology().dayOfYear().get(getLocalMillis());	    }	
/**	     * Get the day of month field value.	     * <p>	     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.	     *	     * @return the day of month	     */	    public int getDayOfMonth() {	        return getChronology().dayOfMonth().get(getLocalMillis());	    }	
/**	     * Get the day of week field value.	     * <p>	     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.	     *	     * @return the day of week	     */	    public int getDayOfWeek() {	        return getChronology().dayOfWeek().get(getLocalMillis());	    }	
/**	     * Get the hour of day field value.	     *	     * @return the hour of day	     */	    public int getHourOfDay() {	        return getChronology().hourOfDay().get(getLocalMillis());	    }	
/**	     * Get the minute of hour field value.	     *	     * @return the minute of hour	     */	    public int getMinuteOfHour() {	        return getChronology().minuteOfHour().get(getLocalMillis());	    }	
/**	     * Get the second of minute field value.	     *	     * @return the second of minute	     */	    public int getSecondOfMinute() {	        return getChronology().secondOfMinute().get(getLocalMillis());	    }	
/**	     * Get the millis of second field value.	     *	     * @return the millis of second	     */	    public int getMillisOfSecond() {	        return getChronology().millisOfSecond().get(getLocalMillis());	    }	
/**	     * Get the millis of day field value.	     *	     * @return the millis of day	     */	    public int getMillisOfDay() {	        return getChronology().millisOfDay().get(getLocalMillis());	    }	
/**	     * Returns a copy of this datetime with the era field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * era changed.	     *	     * @param era  the era to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withEra(int era) {	        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));	    }	
/**	     * Returns a copy of this datetime with the century of era field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * century of era changed.	     *	     * @param centuryOfEra  the centurey of era to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withCenturyOfEra(int centuryOfEra) {	        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));	    }	
/**	     * Returns a copy of this datetime with the year of era field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * year of era changed.	     *	     * @param yearOfEra  the year of era to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withYearOfEra(int yearOfEra) {	        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));	    }	
/**	     * Returns a copy of this datetime with the year of century field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * year of century changed.	     *	     * @param yearOfCentury  the year of century to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withYearOfCentury(int yearOfCentury) {	        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));	    }	
/**	     * Returns a copy of this datetime with the year field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * year changed.	     *	     * @param year  the year to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withYear(int year) {	        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));	    }	
/**	     * Returns a copy of this datetime with the weekyear field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * weekyear changed.	     *	     * @param weekyear  the weekyear to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withWeekyear(int weekyear) {	        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));	    }	
/**	     * Returns a copy of this datetime with the month of year field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * month of year changed.	     *	     * @param monthOfYear  the month of year to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withMonthOfYear(int monthOfYear) {	        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));	    }	
/**	     * Returns a copy of this datetime with the week of weekyear field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * week of weekyear changed.	     *	     * @param weekOfWeekyear  the week of weekyear to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear) {	        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));	    }	
/**	     * Returns a copy of this datetime with the day of year field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * day of year changed.	     *	     * @param dayOfYear  the day of year to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withDayOfYear(int dayOfYear) {	        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));	    }	
/**	     * Returns a copy of this datetime with the day of month field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * day of month changed.	     *	     * @param dayOfMonth  the day of month to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withDayOfMonth(int dayOfMonth) {	        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));	    }	
/**	     * Returns a copy of this datetime with the day of week field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * day of week changed.	     *	     * @param dayOfWeek  the day of week to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withDayOfWeek(int dayOfWeek) {	        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));	    }	
/**	     * Returns a copy of this datetime with the hour of day field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * hour of day changed.	     *	     * @param hour  the hour of day to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withHourOfDay(int hour) {	        return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));	    }	
/**	     * Returns a copy of this datetime with the minute of hour field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * minute of hour changed.	     *	     * @param minute  the minute of hour to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withMinuteOfHour(int minute) {	        return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute));	    }	
/**	     * Returns a copy of this datetime with the second of minute field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * second of minute changed.	     *	     * @param second  the second of minute to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withSecondOfMinute(int second) {	        return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second));	    }	
/**	     * Returns a copy of this datetime with the millis of second field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * millis of second changed.	     *	     * @param millis  the millis of second to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withMillisOfSecond(int millis) {	        return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis));	    }	
/**	     * Returns a copy of this datetime with the millis of day field updated.	     * <p>	     * LocalDateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * millis of day changed.	     *	     * @param millis  the millis of day to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalDateTime withMillisOfDay(int millis) {	        return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis));	    }	
/**	     * Get the era property which provides access to advanced functionality.	     *	     * @return the era property	     */	    public Property era() {	        return new Property(this, getChronology().era());	    }	
/**	     * Get the century of era property which provides access to advanced functionality.	     *	     * @return the year of era property	     */	    public Property centuryOfEra() {	        return new Property(this, getChronology().centuryOfEra());	    }	
/**	     * Get the year of century property which provides access to advanced functionality.	     *	     * @return the year of era property	     */	    public Property yearOfCentury() {	        return new Property(this, getChronology().yearOfCentury());	    }	
/**	     * Get the year of era property which provides access to advanced functionality.	     *	     * @return the year of era property	     */	    public Property yearOfEra() {	        return new Property(this, getChronology().yearOfEra());	    }	
/**	     * Get the year property which provides access to advanced functionality.	     *	     * @return the year property	     */	    public Property year() {	        return new Property(this, getChronology().year());	    }	
/**	     * Get the weekyear property which provides access to advanced functionality.	     *	     * @return the weekyear property	     */	    public Property weekyear() {	        return new Property(this, getChronology().weekyear());	    }	
/**	     * Get the month of year property which provides access to advanced functionality.	     *	     * @return the month of year property	     */	    public Property monthOfYear() {	        return new Property(this, getChronology().monthOfYear());	    }	
/**	     * Get the week of a week based year property which provides access to advanced functionality.	     *	     * @return the week of a week based year property	     */	    public Property weekOfWeekyear() {	        return new Property(this, getChronology().weekOfWeekyear());	    }	
/**	     * Get the day of year property which provides access to advanced functionality.	     *	     * @return the day of year property	     */	    public Property dayOfYear() {	        return new Property(this, getChronology().dayOfYear());	    }	
/**	     * Get the day of month property which provides access to advanced functionality.	     *	     * @return the day of month property	     */	    public Property dayOfMonth() {	        return new Property(this, getChronology().dayOfMonth());	    }	
/**	     * Get the day of week property which provides access to advanced functionality.	     *	     * @return the day of week property	     */	    public Property dayOfWeek() {	        return new Property(this, getChronology().dayOfWeek());	    }	
/**	     * Get the hour of day field property which provides access to advanced functionality.	     * 	     * @return the hour of day property	     */	    public Property hourOfDay() {	        return new Property(this, getChronology().hourOfDay());	    }	
/**	     * Get the minute of hour field property which provides access to advanced functionality.	     * 	     * @return the minute of hour property	     */	    public Property minuteOfHour() {	        return new Property(this, getChronology().minuteOfHour());	    }	
/**	     * Get the second of minute field property which provides access to advanced functionality.	     * 	     * @return the second of minute property	     */	    public Property secondOfMinute() {	        return new Property(this, getChronology().secondOfMinute());	    }	
/**	     * Get the millis of second property which provides access to advanced functionality.	     * 	     * @return the millis of second property	     */	    public Property millisOfSecond() {	        return new Property(this, getChronology().millisOfSecond());	    }	
/**	     * Get the millis of day property which provides access to advanced functionality.	     * 	     * @return the millis of day property	     */	    public Property millisOfDay() {	        return new Property(this, getChronology().millisOfDay());	    }	
/**	     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSS).	     * 	     * @return ISO8601 time formatted string.	     */	    @ToString	    public String toString() {	        return ISODateTimeFormat.dateTime().print(this);	    }	
/**	     * Output the date using the specified format pattern.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @see org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern) {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).print(this);	    }	
/**	     * Output the date using the specified format pattern.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @param locale  Locale to use, null means default	     * @see org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern, Locale locale) throws IllegalArgumentException {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);	    }	
/**	         * Constructor.	         * 	         * @param instant  the instant to set	         * @param field  the field to use	         */	        Property(LocalDateTime instant, DateTimeField field) {	            super();	            iInstant = instant;	            iField = field;	        }	
/**	         * Writes the property in a safe serialization format.	         */	        private void writeObject(ObjectOutputStream oos) throws IOException {	            oos.writeObject(iInstant);	            oos.writeObject(iField.getType());	        }	
/**	         * Reads the property from a safe serialization format.	         */	        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {	            iInstant = (LocalDateTime) oos.readObject();	            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();	            iField = type.getField(iInstant.getChronology());	        }	
/**	         * Gets the field being used.	         * 	         * @return the field	         */	        public DateTimeField getField() {	            return iField;	        }	
/**	         * Gets the milliseconds of the datetime that this property is linked to.	         * 	         * @return the milliseconds	         */	        protected long getMillis() {	            return iInstant.getLocalMillis();	        }	
/**	         * Gets the chronology of the datetime that this property is linked to.	         * 	         * @return the chronology	         * @since 1.4	         */	        protected Chronology getChronology() {	            return iInstant.getChronology();	        }	
/**	         * Gets the LocalDateTime object linked to this property.	         * 	         * @return the linked LocalDateTime	         */	        public LocalDateTime getLocalDateTime() {	            return iInstant;	        }	
/**	         * Adds to this field in a copy of this LocalDateTime.	         * <p>	         * The LocalDateTime attached to this property is unchanged by this call.	         *	         * @param value  the value to add to the field in the copy	         * @return a copy of the LocalDateTime with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public LocalDateTime addToCopy(int value) {	            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));	        }	
/**	         * Adds to this field in a copy of this LocalDateTime.	         * <p>	         * The LocalDateTime attached to this property is unchanged by this call.	         *	         * @param value  the value to add to the field in the copy	         * @return a copy of the LocalDateTime with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public LocalDateTime addToCopy(long value) {	            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));	        }	
/**	         * Adds to this field, possibly wrapped, in a copy of this LocalDateTime.	         * A field wrapped operation only changes this field.	         * Thus 31st January addWrapField one day goes to the 1st January.	         * <p>	         * The LocalDateTime attached to this property is unchanged by this call.	         *	         * @param value  the value to add to the field in the copy	         * @return a copy of the LocalDateTime with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public LocalDateTime addWrapFieldToCopy(int value) {	            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));	        }	
/**	         * Sets this field in a copy of the LocalDateTime.	         * <p>	         * The LocalDateTime attached to this property is unchanged by this call.	         *	         * @param value  the value to set the field in the copy to	         * @return a copy of the LocalDateTime with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public LocalDateTime setCopy(int value) {	            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));	        }	
/**	         * Sets this field in a copy of the LocalDateTime to a parsed text value.	         * <p>	         * The LocalDateTime attached to this property is unchanged by this call.	         *	         * @param text  the text value to set	         * @param locale  optional locale to use for selecting a text symbol	         * @return a copy of the LocalDateTime with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public LocalDateTime setCopy(String text, Locale locale) {	            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));	        }	
/**	         * Sets this field in a copy of the LocalDateTime to a parsed text value.	         * <p>	         * The LocalDateTime attached to this property is unchanged by this call.	         *	         * @param text  the text value to set	         * @return a copy of the LocalDateTime with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public LocalDateTime setCopy(String text) {	            return setCopy(text, null);	        }	
/**	         * Returns a new LocalDateTime with this field set to the maximum value	         * for this field.	         * <p>	         * This operation is useful for obtaining a LocalDateTime on the last day	         * of the month, as month lengths vary.	         * <pre>	         * LocalDateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();	         * </pre>	         * <p>	         * The LocalDateTime attached to this property is unchanged by this call.	         *	         * @return a copy of the LocalDateTime with this field set to its maximum	         */	        public LocalDateTime withMaximumValue() {	            return setCopy(getMaximumValue());	        }	
/**	         * Returns a new LocalDateTime with this field set to the minimum value	         * for this field.	         * <p>	         * The LocalDateTime attached to this property is unchanged by this call.	         *	         * @return a copy of the LocalDateTime with this field set to its minimum	         */	        public LocalDateTime withMinimumValue() {	            return setCopy(getMinimumValue());	        }	
/**	         * Rounds to the lowest whole unit of this field on a copy of this	         * LocalDateTime.	         * <p>	         * For example, rounding floor on the hourOfDay field of a LocalDateTime	         * where the time is 10:30 would result in new LocalDateTime with the	         * time of 10:00.	         *	         * @return a copy of the LocalDateTime with the field value changed	         */	        public LocalDateTime roundFloorCopy() {	            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));	        }	
/**	         * Rounds to the highest whole unit of this field on a copy of this	         * LocalDateTime.	         * <p>	         * For example, rounding floor on the hourOfDay field of a LocalDateTime	         * where the time is 10:30 would result in new LocalDateTime with the	         * time of 11:00.	         *	         * @return a copy of the LocalDateTime with the field value changed	         */	        public LocalDateTime roundCeilingCopy() {	            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));	        }	
/**	         * Rounds to the nearest whole unit of this field on a copy of this	         * LocalDateTime, favoring the floor if halfway.	         *	         * @return a copy of the LocalDateTime with the field value changed	         */	        public LocalDateTime roundHalfFloorCopy() {	            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));	        }	
/**	         * Rounds to the nearest whole unit of this field on a copy of this	         * LocalDateTime, favoring the ceiling if halfway.	         *	         * @return a copy of the LocalDateTime with the field value changed	         */	        public LocalDateTime roundHalfCeilingCopy() {	            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));	        }	
/**	         * Rounds to the nearest whole unit of this field on a copy of this	         * LocalDateTime.  If halfway, the ceiling is favored over the floor	         * only if it makes this field's value even.	         *	         * @return a copy of the LocalDateTime with the field value changed	         */	        public LocalDateTime roundHalfEvenCopy() {	            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));	        }	
/**	     * Parses a {@code Duration} from the specified string.	     * <p>	     * This parses the format {@code PTa.bS}, as per {@link #toString()}.	     * 	     * @param str  the string to parse, not null	     * @since 2.0	     */	    @FromString	    public static Duration parse(String str) {	        return new Duration(str);	    }	
/**	     * Create a duration with the specified number of days assuming that	     * there are the standard number of milliseconds in a day.	     * <p>	     * This method assumes that there are 24 hours in a day,	     * 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in	     * a second. This will be true for most days, however days with Daylight	     * Savings changes will not have 24 hours, so use this method with care.	     * <p>	     * A Duration is a representation of an amount of time. If you want to express	     * the concepts of 'days' you should consider using the {@link Days} class.	     *	     * @param days  the number of standard days in this duration	     * @return the duration, never null	     * @throws ArithmeticException if the days value is too large	     * @since 1.6	     */	    public static Duration standardDays(long days) {	        if (days == 0) {	            return ZERO;	        }	        return new Duration(FieldUtils.safeMultiply(days, DateTimeConstants.MILLIS_PER_DAY));	    }	
/**	     * Create a duration with the specified number of hours assuming that	     * there are the standard number of milliseconds in an hour.	     * <p>	     * This method assumes that there are 60 minutes in an hour,	     * 60 seconds in a minute and 1000 milliseconds in a second.	     * All currently supplied chronologies use this definition.	     * <p>	     * A Duration is a representation of an amount of time. If you want to express	     * the concepts of 'hours' you should consider using the {@link Hours} class.	     *	     * @param hours  the number of standard hours in this duration	     * @return the duration, never null	     * @throws ArithmeticException if the hours value is too large	     * @since 1.6	     */	    public static Duration standardHours(long hours) {	        if (hours == 0) {	            return ZERO;	        }	        return new Duration(FieldUtils.safeMultiply(hours, DateTimeConstants.MILLIS_PER_HOUR));	    }	
/**	     * Create a duration with the specified number of minutes assuming that	     * there are the standard number of milliseconds in a minute.	     * <p>	     * This method assumes that there are 60 seconds in a minute and	     * 1000 milliseconds in a second.	     * All currently supplied chronologies use this definition.	     * <p>	     * A Duration is a representation of an amount of time. If you want to express	     * the concepts of 'minutes' you should consider using the {@link Minutes} class.	     *	     * @param minutes  the number of standard minutes in this duration	     * @return the duration, never null	     * @throws ArithmeticException if the minutes value is too large	     * @since 1.6	     */	    public static Duration standardMinutes(long minutes) {	        if (minutes == 0) {	            return ZERO;	        }	        return new Duration(FieldUtils.safeMultiply(minutes, DateTimeConstants.MILLIS_PER_MINUTE));	    }	
/**	     * Create a duration with the specified number of seconds assuming that	     * there are the standard number of milliseconds in a second.	     * <p>	     * This method assumes that there are 1000 milliseconds in a second.	     * All currently supplied chronologies use this definition.	     * <p>	     * A Duration is a representation of an amount of time. If you want to express	     * the concepts of 'seconds' you should consider using the {@link Seconds} class.	     *	     * @param seconds  the number of standard seconds in this duration	     * @return the duration, never null	     * @throws ArithmeticException if the seconds value is too large	     * @since 1.6	     */	    public static Duration standardSeconds(long seconds) {	        if (seconds == 0) {	            return ZERO;	        }	        return new Duration(FieldUtils.safeMultiply(seconds, DateTimeConstants.MILLIS_PER_SECOND));	    }	
/**	     * Create a duration with the specified number of milliseconds.	     *	     * @param millis  the number of standard milliseconds in this duration	     * @return the duration, never null	     * @since 2.0	     */	    public static Duration millis(long millis) {	        if (millis == 0) {	            return ZERO;	        }	        return new Duration(millis);	    }	
/**	     * Creates a duration from the given millisecond duration.	     *	     * @param duration  the duration, in milliseconds	     */	    public Duration(long duration) {	        super(duration);	    }	
/**	     * Creates a duration from the given interval endpoints.	     *	     * @param startInstant  interval start, in milliseconds	     * @param endInstant  interval end, in milliseconds	     * @throws ArithmeticException if the duration exceeds a 64 bit long	     */	    public Duration(long startInstant, long endInstant) {	        super(startInstant, endInstant);	    }	
/**	     * Creates a duration from the given interval endpoints.	     *	     * @param start  interval start, null means now	     * @param end  interval end, null means now	     * @throws ArithmeticException if the duration exceeds a 64 bit long	     */	    public Duration(ReadableInstant start, ReadableInstant end) {	        super(start, end);	    }	
/**	     * Creates a duration from the specified object using the	     * {@link org.joda.time.convert.ConverterManager ConverterManager}.	     *	     * @param duration  duration to convert	     * @throws IllegalArgumentException if duration is invalid	     */	    public Duration(Object duration) {	        super(duration);	    }	
/**	     * Gets the length of this duration in days assuming that there are the	     * standard number of milliseconds in a day.	     * <p>	     * This method assumes that there are 24 hours in a day,	     * 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in	     * a second. This will be true for most days, however days with Daylight	     * Savings changes will not have 24 hours, so use this method with care.	     * <p>	     * This returns <code>getMillis() / MILLIS_PER_DAY</code>.	     * The result is an integer division, thus excess milliseconds are truncated.	     *	     * @return the length of the duration in standard seconds	     * @since 2.0	     */	    public long getStandardDays() {	        return getMillis() / DateTimeConstants.MILLIS_PER_DAY;	    }	
/**	     * Gets the length of this duration in hours assuming that there are the	     * standard number of milliseconds in an hour.	     * <p>	     * This method assumes that there are 60 minutes in an hour,	     * 60 seconds in a minute and 1000 milliseconds in a second.	     * All currently supplied chronologies use this definition.	     * <p>	     * This returns <code>getMillis() / MILLIS_PER_HOUR</code>.	     * The result is an integer division, thus excess milliseconds are truncated.	     *	     * @return the length of the duration in standard seconds	     * @since 2.0	     */	    public long getStandardHours() {	        return getMillis() / DateTimeConstants.MILLIS_PER_HOUR;	    }	
/**	     * Gets the length of this duration in minutes assuming that there are the	     * standard number of milliseconds in a minute.	     * <p>	     * This method assumes that there are 60 seconds in a minute and	     * 1000 milliseconds in a second.	     * All currently supplied chronologies use this definition.	     * <p>	     * This returns <code>getMillis() / 60000</code>.	     * The result is an integer division, thus excess milliseconds are truncated.	     *	     * @return the length of the duration in standard seconds	     * @since 2.0	     */	    public long getStandardMinutes() {	        return getMillis() / DateTimeConstants.MILLIS_PER_MINUTE;	    }	
/**	     * Gets the length of this duration in seconds assuming that there are the	     * standard number of milliseconds in a second.	     * <p>	     * This method assumes that there are 1000 milliseconds in a second.	     * All currently supplied chronologies use this definition.	     * <p>	     * This returns <code>getMillis() / 1000</code>.	     * The result is an integer division, so 2999 millis returns 2 seconds.	     *	     * @return the length of the duration in standard seconds	     * @since 1.6	     */	    public long getStandardSeconds() {	        return getMillis() / DateTimeConstants.MILLIS_PER_SECOND;	    }	
/**	     * Get this duration as an immutable <code>Duration</code> object	     * by returning <code>this</code>.	     * 	     * @return <code>this</code>	     */	    public Duration toDuration() {	        return this;	    }	
/**	     * Converts this duration to a period in days assuming that there are the	     * standard number of milliseconds in a day.	     * <p>	     * This method assumes that there are 24 hours in a day,	     * 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in	     * a second. This will be true for most days, however days with Daylight	     * Savings changes will not have 24 hours, so use this method with care.	     * 	     * @return a period representing the number of standard days in this period, never null	     * @throws ArithmeticException if the number of days is too large to be represented	     * @since 2.0	     */	    public Days toStandardDays() {	        long days = getStandardDays();	        return Days.days(FieldUtils.safeToInt(days));	    }	
/**	     * Converts this duration to a period in hours assuming that there are the	     * standard number of milliseconds in an hour.	     * <p>	     * This method assumes that there are 60 minutes in an hour,	     * 60 seconds in a minute and 1000 milliseconds in a second.	     * All currently supplied chronologies use this definition.	     * 	     * @return a period representing the number of standard hours in this period, never null	     * @throws ArithmeticException if the number of hours is too large to be represented	     * @since 2.0	     */	    public Hours toStandardHours() {	        long hours = getStandardHours();	        return Hours.hours(FieldUtils.safeToInt(hours));	    }	
/**	     * Converts this duration to a period in minutes assuming that there are the	     * standard number of milliseconds in a minute.	     * <p>	     * This method assumes that there are 60 seconds in a minute and	     * 1000 milliseconds in a second.	     * All currently supplied chronologies use this definition.	     * 	     * @return a period representing the number of standard minutes in this period, never null	     * @throws ArithmeticException if the number of minutes is too large to be represented	     * @since 2.0	     */	    public Minutes toStandardMinutes() {	        long minutes = getStandardMinutes();	        return Minutes.minutes(FieldUtils.safeToInt(minutes));	    }	
/**	     * Converts this duration to a period in seconds assuming that there are the	     * standard number of milliseconds in a second.	     * <p>	     * This method assumes that there are 1000 milliseconds in a second.	     * All currently supplied chronologies use this definition.	     * 	     * @return a period representing the number of standard seconds in this period, never null	     * @throws ArithmeticException if the number of seconds is too large to be represented	     * @since 1.6	     */	    public Seconds toStandardSeconds() {	        long seconds = getStandardSeconds();	        return Seconds.seconds(FieldUtils.safeToInt(seconds));	    }	
/**	     * Creates a new Duration instance with a different milisecond length.	     * 	     * @param duration  the new length of the duration	     * @return the new duration instance	     */	    public Duration withMillis(long duration) {	        if (duration == getMillis()) {	            return this;	        }	        return new Duration(duration);	    }	
/**	     * Returns a new duration with this length plus that specified multiplied by the scalar.	     * This instance is immutable and is not altered.	     * <p>	     * If the addition is zero, this instance is returned.	     * 	     * @param durationToAdd  the duration to add to this one	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return the new duration instance	     */	    public Duration withDurationAdded(long durationToAdd, int scalar) {	        if (durationToAdd == 0 || scalar == 0) {	            return this;	        }	        long add = FieldUtils.safeMultiply(durationToAdd, scalar);	        long duration = FieldUtils.safeAdd(getMillis(), add);	        return new Duration(duration);	    }	
/**	     * Returns a new duration with this length plus that specified multiplied by the scalar.	     * This instance is immutable and is not altered.	     * <p>	     * If the addition is zero, this instance is returned.	     * 	     * @param durationToAdd  the duration to add to this one, null means zero	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return the new duration instance	     */	    public Duration withDurationAdded(ReadableDuration durationToAdd, int scalar) {	        if (durationToAdd == null || scalar == 0) {	            return this;	        }	        return withDurationAdded(durationToAdd.getMillis(), scalar);	    }	
/**	     * Returns a new duration with this length plus that specified.	     * This instance is immutable and is not altered.	     * <p>	     * If the addition is zero, this instance is returned.	     * 	     * @param amount  the duration to add to this one	     * @return the new duration instance	     */	    public Duration plus(long amount) {	        return withDurationAdded(amount, 1);	    }	
/**	     * Returns a new duration with this length plus that specified.	     * This instance is immutable and is not altered.	     * <p>	     * If the amount is zero, this instance is returned.	     * 	     * @param amount  the duration to add to this one, null means zero	     * @return the new duration instance	     */	    public Duration plus(ReadableDuration amount) {	        if (amount == null) {	            return this;	        }	        return withDurationAdded(amount.getMillis(), 1);	    }	
/**	     * Returns a new duration with this length minus that specified.	     * This instance is immutable and is not altered.	     * <p>	     * If the addition is zero, this instance is returned.	     * 	     * @param amount  the duration to take away from this one	     * @return the new duration instance	     */	    public Duration minus(long amount) {	        return withDurationAdded(amount, -1);	    }	
/**	     * Returns a new duration with this length minus that specified.	     * This instance is immutable and is not altered.	     * <p>	     * If the amount is zero, this instance is returned.	     * 	     * @param amount  the duration to take away from this one, null means zero	     * @return the new duration instance	     */	    public Duration minus(ReadableDuration amount) {	        if (amount == null) {	            return this;	        }	        return withDurationAdded(amount.getMillis(), -1);	    }	
/**	     * Restrictive constructor	     */	    protected DateTimeUtils() {	        super();	    }	
/**	     * Gets the current time in milliseconds.	     * <p>	     * By default this returns <code>System.currentTimeMillis()</code>.	     * This may be changed using other methods in this class.	     * 	     * @return the current time in milliseconds from 1970-01-01T00:00:00Z	     */	    public static final long currentTimeMillis() {	        return cMillisProvider.getMillis();	    }	
/**	     * Resets the current time to return the system time.	     * <p>	     * This method changes the behaviour of {@link #currentTimeMillis()}.	     * Whenever the current time is queried, {@link System#currentTimeMillis()} is used.	     * 	     * @throws SecurityException if the application does not have sufficient security rights	     */	    public static final void setCurrentMillisSystem() throws SecurityException {	        checkPermission();	        cMillisProvider = SYSTEM_MILLIS_PROVIDER;	    }	
/**	     * Sets the current time to return a fixed millisecond time.	     * <p>	     * This method changes the behaviour of {@link #currentTimeMillis()}.	     * Whenever the current time is queried, the same millisecond time will be returned.	     * 	     * @param fixedMillis  the fixed millisecond time to use	     * @throws SecurityException if the application does not have sufficient security rights	     */	    public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {	        checkPermission();	        cMillisProvider = new FixedMillisProvider(fixedMillis);	    }	
/**	     * Sets the current time to return the system time plus an offset.	     * <p>	     * This method changes the behaviour of {@link #currentTimeMillis()}.	     * Whenever the current time is queried, {@link System#currentTimeMillis()} is used	     * and then offset by adding the millisecond value specified here.	     * 	     * @param offsetMillis  the fixed millisecond time to use	     * @throws SecurityException if the application does not have sufficient security rights	     */	    public static final void setCurrentMillisOffset(long offsetMillis) throws SecurityException {	        checkPermission();	        if (offsetMillis == 0) {	            cMillisProvider = SYSTEM_MILLIS_PROVIDER;	        } else {	            cMillisProvider = new OffsetMillisProvider(offsetMillis);	        }	    }	
/**	     * Sets the provider of the current time to class specified.	     * <p>	     * This method changes the behaviour of {@link #currentTimeMillis()}.	     * Whenever the current time is queried, the specified class will be called.	     * 	     * @param millisProvider  the provider of the current time to use, not null	     * @throws SecurityException if the application does not have sufficient security rights	     * @since 2.0	     */	    public static final void setCurrentMillisProvider(MillisProvider millisProvider) throws SecurityException {	        if (millisProvider == null) {	            throw new IllegalArgumentException("The MillisProvider must not be null");	        }	        checkPermission();	        cMillisProvider = millisProvider;	    }	
/**	     * Checks whether the provider may be changed using permission 'CurrentTime.setProvider'.	     * 	     * @throws SecurityException if the provider may not be changed	     */	    private static void checkPermission() throws SecurityException {	        SecurityManager sm = System.getSecurityManager();	        if (sm != null) {	            sm.checkPermission(new JodaTimePermission("CurrentTime.setProvider"));	        }	    }	
/**	     * Gets the millisecond instant from the specified instant object handling null.	     * <p>	     * If the instant object is <code>null</code>, the {@link #currentTimeMillis()}	     * will be returned. Otherwise, the millis from the object are returned.	     * 	     * @param instant  the instant to examine, null means now	     * @return the time in milliseconds from 1970-01-01T00:00:00Z	     */	    public static final long getInstantMillis(ReadableInstant instant) {	        if (instant == null) {	            return DateTimeUtils.currentTimeMillis();	        }	        return instant.getMillis();	    }	
/**	     * Gets the chronology from the specified instant object handling null.	     * <p>	     * If the instant object is <code>null</code>, or the instant's chronology is	     * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.	     * Otherwise, the chronology from the object is returned.	     * 	     * @param instant  the instant to examine, null means ISO in the default zone	     * @return the chronology, never null	     */	    public static final Chronology getInstantChronology(ReadableInstant instant) {	        if (instant == null) {	            return ISOChronology.getInstance();	        }	        Chronology chrono = instant.getChronology();	        if (chrono == null) {	            return ISOChronology.getInstance();	        }	        return chrono;	    }	
/**	     * Gets the chronology from the specified instant based interval handling null.	     * <p>	     * The chronology is obtained from the start if that is not null, or from the	     * end if the start is null. The result is additionally checked, and if still	     * null then {@link ISOChronology#getInstance()} will be returned.	     * 	     * @param start  the instant to examine and use as the primary source of the chronology	     * @param end  the instant to examine and use as the secondary source of the chronology	     * @return the chronology, never null	     */	    public static final Chronology getIntervalChronology(ReadableInstant start, ReadableInstant end) {	        Chronology chrono = null;	        if (start != null) {	            chrono = start.getChronology();	        } else if (end != null) {	            chrono = end.getChronology();	        }	        if (chrono == null) {	            chrono = ISOChronology.getInstance();	        }	        return chrono;	    }	
/**	     * Gets the chronology from the specified interval object handling null.	     * <p>	     * If the interval object is <code>null</code>, or the interval's chronology is	     * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.	     * Otherwise, the chronology from the object is returned.	     * 	     * @param interval  the interval to examine, null means ISO in the default zone	     * @return the chronology, never null	     */	    public static final Chronology getIntervalChronology(ReadableInterval interval) {	        if (interval == null) {	            return ISOChronology.getInstance();	        }	        Chronology chrono = interval.getChronology();	        if (chrono == null) {	            return ISOChronology.getInstance();	        }	        return chrono;	    }	
/**	     * Gets the interval handling null.	     * <p>	     * If the interval is <code>null</code>, an interval representing now	     * to now in the {@link ISOChronology#getInstance() ISOChronology}	     * will be returned. Otherwise, the interval specified is returned.	     * 	     * @param interval  the interval to use, null means now to now	     * @return the interval, never null	     * @since 1.1	     */	    public static final ReadableInterval getReadableInterval(ReadableInterval interval) {	        if (interval == null) {	            long now = DateTimeUtils.currentTimeMillis();	            interval = new Interval(now, now);	        }	        return interval;	    }	
/**	     * Gets the chronology handling null.	     * <p>	     * If the chronology is <code>null</code>, {@link ISOChronology#getInstance()}	     * will be returned. Otherwise, the chronology is returned.	     * 	     * @param chrono  the chronology to use, null means ISO in the default zone	     * @return the chronology, never null	     */	    public static final Chronology getChronology(Chronology chrono) {	        if (chrono == null) {	            return ISOChronology.getInstance();	        }	        return chrono;	    }	
/**	     * Gets the zone handling null.	     * <p>	     * If the zone is <code>null</code>, {@link DateTimeZone#getDefault()}	     * will be returned. Otherwise, the zone specified is returned.	     * 	     * @param zone  the time zone to use, null means the default zone	     * @return the time zone, never null	     */	    public static final DateTimeZone getZone(DateTimeZone zone) {	        if (zone == null) {	            return DateTimeZone.getDefault();	        }	        return zone;	    }	
/**	     * Gets the period type handling null.	     * <p>	     * If the zone is <code>null</code>, {@link PeriodType#standard()}	     * will be returned. Otherwise, the type specified is returned.	     * 	     * @param type  the time zone to use, null means the standard type	     * @return the type to use, never null	     */	    public static final PeriodType getPeriodType(PeriodType type) {	        if (type == null) {	            return PeriodType.standard();	        }	        return type;	    }	
/**	     * Gets the millisecond duration from the specified duration object handling null.	     * <p>	     * If the duration object is <code>null</code>, zero will be returned.	     * Otherwise, the millis from the object are returned.	     * 	     * @param duration  the duration to examine, null means zero	     * @return the duration in milliseconds	     */	    public static final long getDurationMillis(ReadableDuration duration) {	        if (duration == null) {	            return 0L;	        }	        return duration.getMillis();	    }	
/**	     * Checks whether the partial is contiguous.	     * <p>	     * A partial is contiguous if one field starts where another ends.	     * <p>	     * For example <code>LocalDate</code> is contiguous because DayOfMonth has	     * the same range (Month) as the unit of the next field (MonthOfYear), and	     * MonthOfYear has the same range (Year) as the unit of the next field (Year).	     * <p>	     * Similarly, <code>LocalTime</code> is contiguous, as it consists of	     * MillisOfSecond, SecondOfMinute, MinuteOfHour and HourOfDay (note how	     * the names of each field 'join up').	     * <p>	     * However, a Year/HourOfDay partial is not contiguous because the range	     * field Day is not equal to the next field Year.	     * Similarly, a DayOfWeek/DayOfMonth partial is not contiguous because	     * the range Month is not equal to the next field Day.	     * 	     * @param partial  the partial to check	     * @return true if the partial is contiguous	     * @throws IllegalArgumentException if the partial is null	     * @since 1.1	     */	    public static final boolean isContiguous(ReadablePartial partial) {	        if (partial == null) {	            throw new IllegalArgumentException("Partial must not be null");	        }	        DurationFieldType lastType = null;	        for (int i = 0; i < partial.size(); i++) {	            DateTimeField loopField = partial.getField(i);	            if (i > 0) {	                if (loopField.getRangeDurationField().getType() != lastType) {	                    return false;	                }	            }	            lastType = loopField.getDurationField().getType();	        }	        return true;	    }	
/**	     * Gets the {@link DateFormatSymbols} based on the given locale.	     * <p>	     * If JDK 6 or newer is being used, DateFormatSymbols.getInstance(locale) will	     * be used in order to allow the use of locales defined as extensions.	     * Otherwise, new DateFormatSymbols(locale) will be used.	     * See JDK 6 {@link DateFormatSymbols} for further information.	     * 	     * @param locale  the {@link Locale} used to get the correct {@link DateFormatSymbols}	     * @return the symbols	     * @since 2.0	     */	    public static final DateFormatSymbols getDateFormatSymbols(Locale locale) {	        try {        		        	Method method = DateFormatSymbols.class.getMethod("getInstance", new Class[] {Locale.class});        		        	return (DateFormatSymbols) method.invoke(null, new Object[] {locale});        		        } catch (Exception ex) {	        	return new DateFormatSymbols(locale);	        } 	    }	
/**	         * Gets the current time.	         * @return the current time in millis	         */	        public long getMillis() {	            return System.currentTimeMillis();	        }	
/**	         * Constructor.	         * @param offsetMillis  the millis offset	         */	        FixedMillisProvider(long fixedMillis) {	            iMillis = fixedMillis;	        }	
/**	         * Gets the current time.	         * @return the current time in millis	         */	        public long getMillis() {	            return iMillis;	        }	
/**	         * Constructor.	         * @param offsetMillis  the millis offset	         */	        OffsetMillisProvider(long offsetMillis) {	            iMillis = offsetMillis;	        }	
/**	         * Gets the current time.	         * @return the current time in millis	         */	        public long getMillis() {	            return System.currentTimeMillis() + iMillis;	        }	
/**	     * Parses a {@code MutablePeriod} from the specified string.	     * <p>	     * This uses {@link ISOPeriodFormat#standard()}.	     * 	     * @param str  the string to parse, not null	     * @since 2.0	     */	    @FromString	    public static MutablePeriod parse(String str) {	        return parse(str, ISOPeriodFormat.standard());	    }	
/**	     * Parses a {@code MutablePeriod} from the specified string using a formatter.	     * 	     * @param str  the string to parse, not null	     * @param formatter  the formatter to use, not null	     * @since 2.0	     */	    public static MutablePeriod parse(String str, PeriodFormatter formatter) {	        return formatter.parsePeriod(str).toMutablePeriod();	    }	
/**	     * Creates a zero-length period using the standard period type.	     */	    public MutablePeriod() {	        super(0L, null, null);	    }	
/**	     * Creates a zero-length period using the specified period type.	     *	     * @param type  which set of fields this period supports	     */	    public MutablePeriod(PeriodType type) {	        super(0L, type, null);	    }	
/**	     * Create a period from a set of field values using the standard set of fields.	     *	     * @param hours  amount of hours in this period	     * @param minutes  amount of minutes in this period	     * @param seconds  amount of seconds in this period	     * @param millis  amount of milliseconds in this period	     */	    public MutablePeriod(int hours, int minutes, int seconds, int millis) {	        super(0, 0, 0, 0, hours, minutes, seconds, millis, PeriodType.standard());	    }	
/**	     * Create a period from a set of field values using the standard set of fields.	     *	     * @param years  amount of years in this period	     * @param months  amount of months in this period	     * @param weeks  amount of weeks in this period	     * @param days  amount of days in this period	     * @param hours  amount of hours in this period	     * @param minutes  amount of minutes in this period	     * @param seconds  amount of seconds in this period	     * @param millis  amount of milliseconds in this period	     */	    public MutablePeriod(int years, int months, int weeks, int days,	                  int hours, int minutes, int seconds, int millis) {	        super(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());	    }	
/**	     * Create a period from a set of field values.	     *	     * @param years  amount of years in this period, which must be zero if unsupported	     * @param months  amount of months in this period, which must be zero if unsupported	     * @param weeks  amount of weeks in this period, which must be zero if unsupported	     * @param days  amount of days in this period, which must be zero if unsupported	     * @param hours  amount of hours in this period, which must be zero if unsupported	     * @param minutes  amount of minutes in this period, which must be zero if unsupported	     * @param seconds  amount of seconds in this period, which must be zero if unsupported	     * @param millis  amount of milliseconds in this period, which must be zero if unsupported	     * @param type  which set of fields this period supports, null means AllType	     * @throws IllegalArgumentException if an unsupported field's value is non-zero	     */	    public MutablePeriod(int years, int months, int weeks, int days,	                    int hours, int minutes, int seconds, int millis, PeriodType type) {	        super(years, months, weeks, days, hours, minutes, seconds, millis, type);	    }	
/**	     * Creates a period from the given millisecond duration using the standard	     * set of fields.	     * <p>	     * Only precise fields in the period type will be used.	     * For the standard period type this is the time fields only.	     * Thus the year, month, week and day fields will not be populated.	     * <p>	     * If the duration is small, less than one day, then this method will perform	     * as you might expect and split the fields evenly.	     * <p>	     * If the duration is larger than one day then all the remaining duration will	     * be stored in the largest available precise field, hours in this case.	     * <p>	     * For example, a duration equal to (365 + 60 + 5) days will be converted to	     * ((365 + 60 + 5) * 24) hours by this constructor.	     * <p>	     * For more control over the conversion process, you have two options:	     * <ul>	     * <li>convert the duration to an {@link Interval}, and from there obtain the period	     * <li>specify a period type that contains precise definitions of the day and larger	     * fields, such as the UTC or precise types.	     * </ul>	     *	     * @param duration  the duration, in milliseconds	     */	    public MutablePeriod(long duration) {	        super(duration, null, null);	    }	
/**	     * Creates a period from the given millisecond duration.	     * <p>	     * Only precise fields in the period type will be used.	     * Imprecise fields will not be populated.	     * <p>	     * If the duration is small then this method will perform	     * as you might expect and split the fields evenly.	     * <p>	     * If the duration is large then all the remaining duration will	     * be stored in the largest available precise field.	     * For details as to which fields are precise, review the period type javadoc.	     *	     * @param duration  the duration, in milliseconds	     * @param type  which set of fields this period supports, null means standard	     */	    public MutablePeriod(long duration, PeriodType type) {	        super(duration, type, null);	    }	
/**	     * Creates a period from the given millisecond duration using the standard	     * set of fields.	     * <p>	     * Only precise fields in the period type will be used.	     * Imprecise fields will not be populated.	     * <p>	     * If the duration is small then this method will perform	     * as you might expect and split the fields evenly.	     * <p>	     * If the duration is large then all the remaining duration will	     * be stored in the largest available precise field.	     * For details as to which fields are precise, review the period type javadoc.	     *	     * @param duration  the duration, in milliseconds	     * @param chronology  the chronology to use to split the duration, null means ISO default	     */	    public MutablePeriod(long duration, Chronology chronology) {	        super(duration, null, chronology);	    }	
/**	     * Creates a period from the given millisecond duration.	     * <p>	     * Only precise fields in the period type will be used.	     * Imprecise fields will not be populated.	     * <p>	     * If the duration is small then this method will perform	     * as you might expect and split the fields evenly.	     * <p>	     * If the duration is large then all the remaining duration will	     * be stored in the largest available precise field.	     * For details as to which fields are precise, review the period type javadoc.	     *	     * @param duration  the duration, in milliseconds	     * @param type  which set of fields this period supports, null means standard	     * @param chronology  the chronology to use to split the duration, null means ISO default	     */	    public MutablePeriod(long duration, PeriodType type, Chronology chronology) {	        super(duration, type, chronology);	    }	
/**	     * Creates a period from the given interval endpoints using the standard	     * set of fields.	     *	     * @param startInstant  interval start, in milliseconds	     * @param endInstant  interval end, in milliseconds	     */	    public MutablePeriod(long startInstant, long endInstant) {	        super(startInstant, endInstant, null, null);	    }	
/**	     * Creates a period from the given interval endpoints.	     *	     * @param startInstant  interval start, in milliseconds	     * @param endInstant  interval end, in milliseconds	     * @param type  which set of fields this period supports, null means standard	     */	    public MutablePeriod(long startInstant, long endInstant, PeriodType type) {	        super(startInstant, endInstant, type, null);	    }	
/**	     * Creates a period from the given interval endpoints using the standard	     * set of fields.	     *	     * @param startInstant  interval start, in milliseconds	     * @param endInstant  interval end, in milliseconds	     * @param chrono  the chronology to use, null means ISO in default zone	     */	    public MutablePeriod(long startInstant, long endInstant, Chronology chrono) {	        super(startInstant, endInstant, null, chrono);	    }	
/**	     * Creates a period from the given interval endpoints.	     *	     * @param startInstant  interval start, in milliseconds	     * @param endInstant  interval end, in milliseconds	     * @param type  which set of fields this period supports, null means standard	     * @param chrono  the chronology to use, null means ISO in default zone	     */	    public MutablePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) {	        super(startInstant, endInstant, type, chrono);	    }	
/**	     * Creates a period from the given interval endpoints using the standard	     * set of fields.	     * <p>	     * The chronology of the start instant is used, unless that is null when the	     * chronology of the end instant is used instead.	     *	     * @param startInstant  interval start, null means now	     * @param endInstant  interval end, null means now	     */	    public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant) {	        super(startInstant, endInstant, null);	    }	
/**	     * Creates a period from the given interval endpoints.	     * <p>	     * The chronology of the start instant is used, unless that is null when the	     * chronology of the end instant is used instead.	     *	     * @param startInstant  interval start, null means now	     * @param endInstant  interval end, null means now	     * @param type  which set of fields this period supports, null means AllType	     */	    public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {	        super(startInstant, endInstant, type);	    }	
/**	     * Creates a period from the given start point and the duration.	     *	     * @param startInstant  the interval start, null means now	     * @param duration  the duration of the interval, null means zero-length	     */	    public MutablePeriod(ReadableInstant startInstant, ReadableDuration duration) {	        super(startInstant, duration, null);	    }	
/**	     * Creates a period from the given start point and the duration.	     *	     * @param startInstant  the interval start, null means now	     * @param duration  the duration of the interval, null means zero-length	     * @param type  which set of fields this period supports, null means standard	     */	    public MutablePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {	        super(startInstant, duration, type);	    }	
/**	     * Creates a period from the given duration and end point.	     *	     * @param duration  the duration of the interval, null means zero-length	     * @param endInstant  the interval end, null means now	     */	    public MutablePeriod(ReadableDuration duration, ReadableInstant endInstant) {	        super(duration, endInstant, null);	    }	
/**	     * Creates a period from the given duration and end point.	     *	     * @param duration  the duration of the interval, null means zero-length	     * @param endInstant  the interval end, null means now	     * @param type  which set of fields this period supports, null means standard	     */	    public MutablePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {	        super(duration, endInstant, type);	    }	
/**	     * Creates a period by converting or copying from another object.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePeriod, ReadableInterval and String.	     * The String formats are described by {@link ISOPeriodFormat#standard()}.	     *	     * @param period  period to convert	     * @throws IllegalArgumentException if period is invalid	     * @throws UnsupportedOperationException if an unsupported field's value is non-zero	     */	    public MutablePeriod(Object period) {	        super(period, null, null);	    }	
/**	     * Creates a period by converting or copying from another object.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePeriod, ReadableInterval and String.	     * The String formats are described by {@link ISOPeriodFormat#standard()}.	     *	     * @param period  period to convert	     * @param type  which set of fields this period supports, null means use converter	     * @throws IllegalArgumentException if period is invalid	     * @throws UnsupportedOperationException if an unsupported field's value is non-zero	     */	    public MutablePeriod(Object period, PeriodType type) {	        super(period, type, null);	    }	
/**	     * Creates a period by converting or copying from another object.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePeriod, ReadableInterval and String.	     * The String formats are described by {@link ISOPeriodFormat#standard()}.	     *	     * @param period  period to convert	     * @param chrono  the chronology to use, null means ISO in default zone	     * @throws IllegalArgumentException if period is invalid	     * @throws UnsupportedOperationException if an unsupported field's value is non-zero	     */	    public MutablePeriod(Object period, Chronology chrono) {	        super(period, null, chrono);	    }	
/**	     * Creates a period by converting or copying from another object.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePeriod, ReadableInterval and String.	     * The String formats are described by {@link ISOPeriodFormat#standard()}.	     *	     * @param period  period to convert	     * @param type  which set of fields this period supports, null means use converter	     * @param chrono  the chronology to use, null means ISO in default zone	     * @throws IllegalArgumentException if period is invalid	     * @throws UnsupportedOperationException if an unsupported field's value is non-zero	     */	    public MutablePeriod(Object period, PeriodType type, Chronology chrono) {	        super(period, type, chrono);	    }	
/**	     * Clears the period, setting all values back to zero.	     */	    public void clear() {	        super.setValues(new int[size()]);	    }	
/**	     * Sets the value of one of the fields by index.	     *	     * @param index  the field index	     * @param value  the new value for the field	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public void setValue(int index, int value) {	        super.setValue(index, value);	    }	
/**	     * Sets the value of one of the fields.	     * <p>	     * The field type specified must be one of those that is supported by the period.	     *	     * @param field  a DurationFieldType instance that is supported by this period, not null	     * @param value  the new value for the field	     * @throws IllegalArgumentException if the field is null or not supported	     */	    public void set(DurationFieldType field, int value) {	        super.setField(field, value);	    }	
/**	     * Sets all the fields in one go from another ReadablePeriod.	     * 	     * @param period  the period to set, null means zero length period	     * @throws IllegalArgumentException if an unsupported field's value is non-zero	     */	    public void setPeriod(ReadablePeriod period) {	        super.setPeriod(period);	    }	
/**	     * Sets all the fields in one go.	     * 	     * @param years  amount of years in this period, which must be zero if unsupported	     * @param months  amount of months in this period, which must be zero if unsupported	     * @param weeks  amount of weeks in this period, which must be zero if unsupported	     * @param days  amount of days in this period, which must be zero if unsupported	     * @param hours  amount of hours in this period, which must be zero if unsupported	     * @param minutes  amount of minutes in this period, which must be zero if unsupported	     * @param seconds  amount of seconds in this period, which must be zero if unsupported	     * @param millis  amount of milliseconds in this period, which must be zero if unsupported	     * @throws IllegalArgumentException if an unsupported field's value is non-zero	     */	    public void setPeriod(int years, int months, int weeks, int days,	                          int hours, int minutes, int seconds, int millis) {	        super.setPeriod(years, months, weeks, days, hours, minutes, seconds, millis);	    }	
/**	     * Sets all the fields in one go from an interval using the ISO chronology	     * and dividing the fields using the period type.	     * 	     * @param interval  the interval to set, null means zero length	     * @throws ArithmeticException if the set exceeds the capacity of the period	     */	    public void setPeriod(ReadableInterval interval) {	        if (interval == null) {	            setPeriod(0L);	        } else {	            Chronology chrono = DateTimeUtils.getChronology(interval.getChronology());	            setPeriod(interval.getStartMillis(), interval.getEndMillis(), chrono);	        }	    }	
/**	     * Sets all the fields in one go from two instants representing an interval.	     * <p>	     * The chronology of the start instant is used, unless that is null when the	     * chronology of the end instant is used instead.	     * 	     * @param start  the start instant, null means now	     * @param end  the end instant, null means now	     * @throws ArithmeticException if the set exceeds the capacity of the period	     */	    public void setPeriod(ReadableInstant start, ReadableInstant end) {	        if (start == end) {	            setPeriod(0L);	        } else {	            long startMillis = DateTimeUtils.getInstantMillis(start);	            long endMillis = DateTimeUtils.getInstantMillis(end);	            Chronology chrono = DateTimeUtils.getIntervalChronology(start, end);	            setPeriod(startMillis, endMillis, chrono);	        }	    }	
/**	     * Sets all the fields in one go from a millisecond interval using ISOChronology	     * and dividing the fields using the period type.	     * 	     * @param startInstant  interval start, in milliseconds	     * @param endInstant  interval end, in milliseconds	     * @throws ArithmeticException if the set exceeds the capacity of the period	     */	    public void setPeriod(long startInstant, long endInstant) {	        setPeriod(startInstant, endInstant, null);	    }	
/**	     * Sets all the fields in one go from a millisecond interval.	     * 	     * @param startInstant  interval start, in milliseconds	     * @param endInstant  interval end, in milliseconds	     * @param chrono  the chronology to use, not null	     * @throws ArithmeticException if the set exceeds the capacity of the period	     */	    public void setPeriod(long startInstant, long endInstant, Chronology chrono) {	        chrono = DateTimeUtils.getChronology(chrono);	        setValues(chrono.get(this, startInstant, endInstant));	    }	
/**	     * Sets all the fields in one go from a duration dividing the	     * fields using the period type.	     * <p>	     * When dividing the duration, only precise fields in the period type will be used.	     * For large durations, all the remaining duration will be stored in the largest	     * available precise field.	     * 	     * @param duration  the duration to set, null means zero length	     * @throws ArithmeticException if the set exceeds the capacity of the period	     */	    public void setPeriod(ReadableDuration duration) {	        setPeriod(duration, null);	    }	
/**	     * Sets all the fields in one go from a duration dividing the	     * fields using the period type.	     * <p>	     * When dividing the duration, only precise fields in the period type will be used.	     * For large durations, all the remaining duration will be stored in the largest	     * available precise field.	     * 	     * @param duration  the duration to set, null means zero length	     * @param chrono  the chronology to use, null means ISO default	     * @throws ArithmeticException if the set exceeds the capacity of the period	     */	    public void setPeriod(ReadableDuration duration, Chronology chrono) {	        long durationMillis = DateTimeUtils.getDurationMillis(duration);	        setPeriod(durationMillis, chrono);	    }	
/**	     * Sets all the fields in one go from a millisecond duration dividing the	     * fields using the period type.	     * <p>	     * When dividing the duration, only precise fields in the period type will be used.	     * For large durations, all the remaining duration will be stored in the largest	     * available precise field.	     * 	     * @param duration  the duration, in milliseconds	     * @throws ArithmeticException if the set exceeds the capacity of the period	     */	    public void setPeriod(long duration) {	        setPeriod(duration, null);	    }	
/**	     * Sets all the fields in one go from a millisecond duration.	     * <p>	     * When dividing the duration, only precise fields in the period type will be used.	     * For large durations, all the remaining duration will be stored in the largest	     * available precise field.	     * 	     * @param duration  the duration, in milliseconds	     * @param chrono  the chronology to use, not null	     * @throws ArithmeticException if the set exceeds the capacity of the period	     */	    public void setPeriod(long duration, Chronology chrono) {	        chrono = DateTimeUtils.getChronology(chrono);	        setValues(chrono.get(this, duration));	    }	
/**	     * Adds to the value of one of the fields.	     * <p>	     * The field type specified must be one of those that is supported by the period.	     *	     * @param field  a DurationFieldType instance that is supported by this period, not null	     * @param value  the value to add to the field	     * @throws IllegalArgumentException if the field is null or not supported	     */	    public void add(DurationFieldType field, int value) {	        super.addField(field, value);	    }	
/**	     * Adds a period to this one by adding each field in turn.	     * 	     * @param period  the period to add, null means add nothing	     * @throws IllegalArgumentException if the period being added contains a field	     * not supported by this period	     * @throws ArithmeticException if the addition exceeds the capacity of the period	     */	    public void add(ReadablePeriod period) {	        super.addPeriod(period);	    }	
/**	     * Adds to each field of this period.	     * 	     * @param years  amount of years to add to this period, which must be zero if unsupported	     * @param months  amount of months to add to this period, which must be zero if unsupported	     * @param weeks  amount of weeks to add to this period, which must be zero if unsupported	     * @param days  amount of days to add to this period, which must be zero if unsupported	     * @param hours  amount of hours to add to this period, which must be zero if unsupported	     * @param minutes  amount of minutes to add to this period, which must be zero if unsupported	     * @param seconds  amount of seconds to add to this period, which must be zero if unsupported	     * @param millis  amount of milliseconds to add to this period, which must be zero if unsupported	     * @throws IllegalArgumentException if the period being added contains a field	     * not supported by this period	     * @throws ArithmeticException if the addition exceeds the capacity of the period	     */	    public void add(int years, int months, int weeks, int days,	                       int hours, int minutes, int seconds, int millis) {	        setPeriod(	            FieldUtils.safeAdd(getYears(), years),	            FieldUtils.safeAdd(getMonths(), months),	            FieldUtils.safeAdd(getWeeks(), weeks),	            FieldUtils.safeAdd(getDays(), days),	            FieldUtils.safeAdd(getHours(), hours),	            FieldUtils.safeAdd(getMinutes(), minutes),	            FieldUtils.safeAdd(getSeconds(), seconds),	            FieldUtils.safeAdd(getMillis(), millis)	        );	    }	
/**	     * Adds an interval to this one by dividing the interval into	     * fields and calling {@link #add(ReadablePeriod)}.	     * 	     * @param interval  the interval to add, null means add nothing	     * @throws ArithmeticException if the addition exceeds the capacity of the period	     */	    public void add(ReadableInterval interval) {	        if (interval != null) {	            add(interval.toPeriod(getPeriodType()));	        }	    }	
/**	     * Adds a duration to this one by dividing the duration into	     * fields and calling {@link #add(ReadablePeriod)}.	     * 	     * @param duration  the duration to add, null means add nothing	     * @throws ArithmeticException if the addition exceeds the capacity of the period	     */	    public void add(ReadableDuration duration) {	        if (duration != null) {	            add(new Period(duration.getMillis(), getPeriodType()));	        }	    }	
/**	     * Adds a millisecond duration to this one by dividing the duration into	     * fields and calling {@link #add(ReadablePeriod)}.	     * <p>	     * When dividing the duration, only precise fields in the period type will be used.	     * For large durations, all the remaining duration will be stored in the largest	     * available precise field.	     * 	     * @param duration  the duration, in milliseconds	     * @throws ArithmeticException if the addition exceeds the capacity of the period	     */	    public void add(long duration) {	        add(new Period(duration, getPeriodType()));	    }	
/**	     * Adds a millisecond duration to this one by dividing the duration into	     * fields and calling {@link #add(ReadablePeriod)}.	     * <p>	     * When dividing the duration, only precise fields in the period type will be used.	     * For large durations, all the remaining duration will be stored in the largest	     * available precise field.	     * 	     * @param duration  the duration, in milliseconds	     * @param chrono  the chronology to use, null means ISO default	     * @throws ArithmeticException if the addition exceeds the capacity of the period	     */	    public void add(long duration, Chronology chrono) {	        add(new Period(duration, getPeriodType(), chrono));	    }	
/**	     * Merges all the fields from the specified period into this one.	     * <p>	     * Fields that are not present in the specified period are left unaltered.	     * 	     * @param period  the period to set, null ignored	     * @throws IllegalArgumentException if an unsupported field's value is non-zero	     */	    public void mergePeriod(ReadablePeriod period) {	        super.mergePeriod(period);	    }	
/**	     * Gets the years field part of the period.	     * 	     * @return the number of years in the period, zero if unsupported	     */	    public int getYears() {	        return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);	    }	
/**	     * Gets the months field part of the period.	     * 	     * @return the number of months in the period, zero if unsupported	     */	    public int getMonths() {	        return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);	    }	
/**	     * Gets the weeks field part of the period.	     * 	     * @return the number of weeks in the period, zero if unsupported	     */	    public int getWeeks() {	        return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);	    }	
/**	     * Gets the days field part of the period.	     * 	     * @return the number of days in the period, zero if unsupported	     */	    public int getDays() {	        return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);	    }	
/**	     * Gets the hours field part of the period.	     * 	     * @return the number of hours in the period, zero if unsupported	     */	    public int getHours() {	        return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);	    }	
/**	     * Gets the minutes field part of the period.	     * 	     * @return the number of minutes in the period, zero if unsupported	     */	    public int getMinutes() {	        return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);	    }	
/**	     * Gets the seconds field part of the period.	     * 	     * @return the number of seconds in the period, zero if unsupported	     */	    public int getSeconds() {	        return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);	    }	
/**	     * Gets the millis field part of the period.	     * 	     * @return the number of millis in the period, zero if unsupported	     */	    public int getMillis() {	        return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);	    }	
/**	     * Sets the number of years of the period.	     * 	     * @param years  the number of years	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     */	    public void setYears(int years) {	        super.setField(DurationFieldType.years(), years);	    }	
/**	     * Adds the specified years to the number of years in the period.	     * 	     * @param years  the number of years	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     * @throws ArithmeticException if the addition exceeds the capacity of the period	     */	    public void addYears(int years) {	        super.addField(DurationFieldType.years(), years);	    }	
/**	     * Sets the number of months of the period.	     * 	     * @param months  the number of months	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     */	    public void setMonths(int months) {	        super.setField(DurationFieldType.months(), months);	    }	
/**	     * Adds the specified months to the number of months in the period.	     * 	     * @param months  the number of months	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     * @throws ArithmeticException if the addition exceeds the capacity of the period	     */	    public void addMonths(int months) {	        super.addField(DurationFieldType.months(), months);	    }	
/**	     * Sets the number of weeks of the period.	     * 	     * @param weeks  the number of weeks	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     */	    public void setWeeks(int weeks) {	        super.setField(DurationFieldType.weeks(), weeks);	    }	
/**	     * Adds the specified weeks to the number of weeks in the period.	     * 	     * @param weeks  the number of weeks	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     * @throws ArithmeticException if the addition exceeds the capacity of the period	     */	    public void addWeeks(int weeks) {	        super.addField(DurationFieldType.weeks(), weeks);	    }	
/**	     * Sets the number of days of the period.	     * 	     * @param days  the number of days	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     */	    public void setDays(int days) {	        super.setField(DurationFieldType.days(), days);	    }	
/**	     * Adds the specified days to the number of days in the period.	     * 	     * @param days  the number of days	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     * @throws ArithmeticException if the addition exceeds the capacity of the period	     */	    public void addDays(int days) {	        super.addField(DurationFieldType.days(), days);	    }	
/**	     * Sets the number of hours of the period.	     * 	     * @param hours  the number of hours	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     */	    public void setHours(int hours) {	        super.setField(DurationFieldType.hours(), hours);	    }	
/**	     * Adds the specified hours to the number of hours in the period.	     * 	     * @param hours  the number of hours	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     * @throws ArithmeticException if the addition exceeds the capacity of the period	     */	    public void addHours(int hours) {	        super.addField(DurationFieldType.hours(), hours);	    }	
/**	     * Sets the number of minutes of the period.	     * 	     * @param minutes  the number of minutes	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     */	    public void setMinutes(int minutes) {	        super.setField(DurationFieldType.minutes(), minutes);	    }	
/**	     * Adds the specified minutes to the number of minutes in the period.	     * 	     * @param minutes  the number of minutes	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     * @throws ArithmeticException if the addition exceeds the capacity of the period	     */	    public void addMinutes(int minutes) {	        super.addField(DurationFieldType.minutes(), minutes);	    }	
/**	     * Sets the number of seconds of the period.	     * 	     * @param seconds  the number of seconds	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     */	    public void setSeconds(int seconds) {	        super.setField(DurationFieldType.seconds(), seconds);	    }	
/**	     * Adds the specified seconds to the number of seconds in the period.	     * 	     * @param seconds  the number of seconds	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     * @throws ArithmeticException if the addition exceeds the capacity of the period	     */	    public void addSeconds(int seconds) {	        super.addField(DurationFieldType.seconds(), seconds);	    }	
/**	     * Sets the number of millis of the period.	     * 	     * @param millis  the number of millis	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     */	    public void setMillis(int millis) {	        super.setField(DurationFieldType.millis(), millis);	    }	
/**	     * Adds the specified millis to the number of millis in the period.	     * 	     * @param millis  the number of millis	     * @throws IllegalArgumentException if field is not supported and the value is non-zero	     * @throws ArithmeticException if the addition exceeds the capacity of the period	     */	    public void addMillis(int millis) {	        super.addField(DurationFieldType.millis(), millis);	    }	
/**	     * Clone this object without having to cast the returned object.	     *	     * @return a clone of the this object.	     */	    public MutablePeriod copy() {	        return (MutablePeriod) clone();	    }	
/**	     * Clone this object.	     *	     * @return a clone of this object.	     */	    public Object clone() {	        try {	            return super.clone();	        } catch (CloneNotSupportedException ex) {	            throw new InternalError("Clone error");	        }	    }	
/**	     * Parses a {@code LocalTime} from the specified string.	     * <p>	     * This uses {@link ISODateTimeFormat#localTimeParser()}.	     * 	     * @param str  the string to parse, not null	     * @since 2.0	     */	    @FromString	    public static LocalTime parse(String str) {	        return parse(str, ISODateTimeFormat.localTimeParser());	    }	
/**	     * Parses a {@code LocalTime} from the specified string using a formatter.	     * 	     * @param str  the string to parse, not null	     * @param formatter  the formatter to use, not null	     * @since 2.0	     */	    public static LocalTime parse(String str, DateTimeFormatter formatter) {	        return formatter.parseLocalTime(str);	    }	
/**	     * Constructs a LocalTime from the specified millis of day using the	     * ISO chronology.	     * <p>	     * The millisOfDay value may exceed the number of millis in one day,	     * but additional days will be ignored.	     * This method uses the UTC time zone internally.	     *	     * @param millisOfDay  the number of milliseconds into a day to convert	     */	    public static LocalTime fromMillisOfDay(long millisOfDay) {	        return fromMillisOfDay(millisOfDay, null);	    }	
/**	     * Constructs a LocalTime from the specified millis of day using the	     * specified chronology.	     * <p>	     * The millisOfDay value may exceed the number of millis in one day,	     * but additional days will be ignored.	     * This method uses the UTC time zone internally.	     *	     * @param millisOfDay  the number of milliseconds into a day to convert	     * @param chrono  the chronology, null means ISO chronology	     */	    public static LocalTime fromMillisOfDay(long millisOfDay, Chronology chrono) {	        chrono = DateTimeUtils.getChronology(chrono).withUTC();	        return new LocalTime(millisOfDay, chrono);	    }	
/**	     * Constructs a LocalTime from a <code>java.util.Calendar</code>	     * using exactly the same field values.	     * <p>	     * Each field is queried from the Calendar and assigned to the LocalTime.	     * This is useful if you have been using the Calendar as a local time,	     * ignoring the zone.	     * <p>	     * One advantage of this method is that this method is unaffected if the	     * version of the time zone data differs between the JDK and Joda-Time.	     * That is because the local field values are transferred, calculated using	     * the JDK time zone data and without using the Joda-Time time zone data.	     * <p>	     * This factory method ignores the type of the calendar and always	     * creates a LocalTime with ISO chronology. It is expected that you	     * will only pass in instances of <code>GregorianCalendar</code> however	     * this is not validated.	     *	     * @param calendar  the Calendar to extract fields from	     * @return the created LocalTime	     * @throws IllegalArgumentException if the calendar is null	     * @throws IllegalArgumentException if the date is invalid for the ISO chronology	     */	    public static LocalTime fromCalendarFields(Calendar calendar) {	        if (calendar == null) {	            throw new IllegalArgumentException("The calendar must not be null");	        }	        return new LocalTime(	            calendar.get(Calendar.HOUR_OF_DAY),	            calendar.get(Calendar.MINUTE),	            calendar.get(Calendar.SECOND),	            calendar.get(Calendar.MILLISECOND)	        );	    }	
/**	     * Constructs a LocalTime from a <code>java.util.Date</code>	     * using exactly the same field values.	     * <p>	     * Each field is queried from the Date and assigned to the LocalTime.	     * This is useful if you have been using the Date as a local time,	     * ignoring the zone.	     * <p>	     * One advantage of this method is that this method is unaffected if the	     * version of the time zone data differs between the JDK and Joda-Time.	     * That is because the local field values are transferred, calculated using	     * the JDK time zone data and without using the Joda-Time time zone data.	     * <p>	     * This factory method always creates a LocalTime with ISO chronology.	     *	     * @param date  the Date to extract fields from	     * @return the created LocalTime	     * @throws IllegalArgumentException if the calendar is null	     * @throws IllegalArgumentException if the date is invalid for the ISO chronology	     */	    @SuppressWarnings("deprecation")	    public static LocalTime fromDateFields(Date date) {	        if (date == null) {	            throw new IllegalArgumentException("The date must not be null");	        }	        return new LocalTime(	            date.getHours(),	            date.getMinutes(),	            date.getSeconds(),	            (((int) (date.getTime() % 1000)) + 1000) % 1000	        );	    }	
/**	     * Constructs an instance set to the current local time evaluated using	     * ISO chronology in the default zone.	     * <p>	     * Once the constructor is completed, the zone is no longer used.	     */	    public LocalTime() {	        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());	    }	
/**	     * Constructs an instance set to the current local time evaluated using	     * ISO chronology in the specified zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     * Once the constructor is completed, the zone is no longer used.	     *	     * @param zone  the time zone, null means default zone	     */	    public LocalTime(DateTimeZone zone) {	        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));	    }	
/**	     * Constructs an instance set to the current local time evaluated using	     * specified chronology and zone.	     * <p>	     * If the chronology is null, ISO chronology in the default time zone is used.	     * Once the constructor is completed, the zone is no longer used.	     *	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public LocalTime(Chronology chronology) {	        this(DateTimeUtils.currentTimeMillis(), chronology);	    }	
/**	     * Constructs an instance set to the local time defined by the specified	     * instant evaluated using ISO chronology in the default zone.	     * <p>	     * Once the constructor is completed, the zone is no longer used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     */	    public LocalTime(long instant) {	        this(instant, ISOChronology.getInstance());	    }	
/**	     * Constructs an instance set to the local time defined by the specified	     * instant evaluated using ISO chronology in the specified zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     * Once the constructor is completed, the zone is no longer used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param zone  the time zone, null means default zone	     */	    public LocalTime(long instant, DateTimeZone zone) {	        this(instant, ISOChronology.getInstance(zone));	    }	
/**	     * Constructs an instance set to the local time defined by the specified	     * instant evaluated using the specified chronology.	     * <p>	     * If the chronology is null, ISO chronology in the default zone is used.	     * Once the constructor is completed, the zone is no longer used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public LocalTime(long instant, Chronology chronology) {	        chronology = DateTimeUtils.getChronology(chronology);	        	        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);	        chronology = chronology.withUTC();	        iLocalMillis = chronology.millisOfDay().get(localMillis);	        iChronology = chronology;	    }	
/**	     * Constructs an instance from an Object that represents a datetime.	     * <p>	     * If the object contains no chronology, <code>ISOChronology</code> is used.	     * If the object contains no time zone, the default zone is used.	     * Once the constructor is completed, the zone is no longer used.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePartial, ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.	     * The default String converter ignores the zone and only parses the field values.	     *	     * @param instant  the datetime object	     * @throws IllegalArgumentException if the instant is invalid	     */	    public LocalTime(Object instant) {	        this(instant, (Chronology) null);	    }	
/**	     * Constructs an instance from an Object that represents a datetime,	     * forcing the time zone to that specified.	     * <p>	     * If the object contains no chronology, <code>ISOChronology</code> is used.	     * If the specified time zone is null, the default zone is used.	     * Once the constructor is completed, the zone is no longer used.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePartial, ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.	     * The default String converter ignores the zone and only parses the field values.	     *	     * @param instant  the datetime object	     * @param zone  the time zone	     * @throws IllegalArgumentException if the instant is invalid	     */	    public LocalTime(Object instant, DateTimeZone zone) {	        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);	        Chronology chronology = converter.getChronology(instant, zone);	        chronology = DateTimeUtils.getChronology(chronology);	        iChronology = chronology.withUTC();	        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localTimeParser());	        iLocalMillis = iChronology.getDateTimeMillis(0L, values[0], values[1], values[2], values[3]);	    }	
/**	     * Constructs an instance from an Object that represents a datetime,	     * using the specified chronology.	     * <p>	     * If the chronology is null, ISO in the default time zone is used.	     * Once the constructor is completed, the zone is no longer used.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePartial, ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.	     * The default String converter ignores the zone and only parses the field values.	     *	     * @param instant  the datetime object	     * @param chronology  the chronology	     * @throws IllegalArgumentException if the instant is invalid	     */	    public LocalTime(Object instant, Chronology chronology) {	        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);	        chronology = converter.getChronology(instant, chronology);	        chronology = DateTimeUtils.getChronology(chronology);	        iChronology = chronology.withUTC();	        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localTimeParser());	        iLocalMillis = iChronology.getDateTimeMillis(0L, values[0], values[1], values[2], values[3]);	    }	
/**	     * Constructs an instance set to the specified time	     * using <code>ISOChronology</code>.	     *	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     */	    public LocalTime(	            int hourOfDay,	            int minuteOfHour) {	        this(hourOfDay, minuteOfHour, 0, 0, ISOChronology.getInstanceUTC());	    }	
/**	     * Constructs an instance set to the specified time	     * using <code>ISOChronology</code>.	     *	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     */	    public LocalTime(	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute) {	        this(hourOfDay, minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC());	    }	
/**	     * Constructs an instance set to the specified time	     * using <code>ISOChronology</code>.	     *	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     */	    public LocalTime(	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute,	            int millisOfSecond) {	        this(hourOfDay, minuteOfHour, secondOfMinute,	                millisOfSecond, ISOChronology.getInstanceUTC());	    }	
/**	     * Constructs an instance set to the specified time	     * using the specified chronology, whose zone is ignored.	     * <p>	     * If the chronology is null, <code>ISOChronology</code> is used.	     *	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public LocalTime(	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute,	            int millisOfSecond,	            Chronology chronology) {	        super();	        chronology = DateTimeUtils.getChronology(chronology).withUTC();	        long instant = chronology.getDateTimeMillis(	            0L, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	        iChronology = chronology;	        iLocalMillis = instant;	    }	
/**	     * Gets the number of fields in this partial, which is four.	     * The supported fields are HourOfDay, MinuteOfHour, SecondOfMinute	     * and MillisOfSecond.	     *	     * @return the field count, four	     */	    public int size() {	        return 4;	    }	
/**	     * Gets the field for a specific index in the chronology specified.	     * <p>	     * This method must not use any instance variables.	     *	     * @param index  the index to retrieve	     * @param chrono  the chronology to use	     * @return the field	     */	    protected DateTimeField getField(int index, Chronology chrono) {	        switch (index) {	            case HOUR_OF_DAY:	                return chrono.hourOfDay();	            case MINUTE_OF_HOUR:	                return chrono.minuteOfHour();	            case SECOND_OF_MINUTE:	                return chrono.secondOfMinute();	            case MILLIS_OF_SECOND:	                return chrono.millisOfSecond();	            default:	                throw new IndexOutOfBoundsException("Invalid index: " + index);	        }	    }	
/**	     * Gets the value of the field at the specifed index.	     * <p>	     * This method is required to support the <code>ReadablePartial</code>	     * interface. The supported fields are HourOfDay, MinuteOfHour,	     * SecondOfMinute and MillisOfSecond.	     *	     * @param index  the index, zero to three	     * @return the value	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public int getValue(int index) {	        switch (index) {	            case HOUR_OF_DAY:	                return getChronology().hourOfDay().get(getLocalMillis());	            case MINUTE_OF_HOUR:	                return getChronology().minuteOfHour().get(getLocalMillis());	            case SECOND_OF_MINUTE:	                return getChronology().secondOfMinute().get(getLocalMillis());	            case MILLIS_OF_SECOND:	                return getChronology().millisOfSecond().get(getLocalMillis());	            default:	                throw new IndexOutOfBoundsException("Invalid index: " + index);	        }	    }	
/**	     * Get the value of one of the fields of time.	     * <p>	     * This method gets the value of the specified field.	     * For example:	     * <pre>	     * DateTime dt = new DateTime();	     * int hourOfDay = dt.get(DateTimeFieldType.hourOfDay());	     * </pre>	     *	     * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null	     * @return the value of that field	     * @throws IllegalArgumentException if the field type is null	     */	    public int get(DateTimeFieldType fieldType) {	        if (fieldType == null) {	            throw new IllegalArgumentException("The DateTimeFieldType must not be null");	        }	        if (isSupported(fieldType) == false) {	            throw new IllegalArgumentException("Field '" + fieldType + "' is not supported");	        }	        return fieldType.getField(getChronology()).get(getLocalMillis());	    }	
/**	     * Checks if the field type specified is supported by this	     * local time and chronology.	     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.	     *	     * @param type  a field type, usually obtained from DateTimeFieldType	     * @return true if the field type is supported	     */	    public boolean isSupported(DateTimeFieldType type) {	        if (type == null) {	            return false;	        }	        if (isSupported(type.getDurationType()) == false) {	            return false;	        }	        DurationFieldType range = type.getRangeDurationType();	        return (isSupported(range) || range == DurationFieldType.days());	    }	
/**	     * Checks if the duration type specified is supported by this	     * local time and chronology.	     *	     * @param type  a duration type, usually obtained from DurationFieldType	     * @return true if the field type is supported	     */	    public boolean isSupported(DurationFieldType type) {	        if (type == null) {	            return false;	        }	        DurationField field = type.getField(getChronology());	        if (TIME_DURATION_TYPES.contains(type) ||	            field.getUnitMillis() < getChronology().days().getUnitMillis()) {	            return field.isSupported();	        }	        return false;	    }	
/**	     * Gets the local milliseconds from the Java epoch	     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).	     * 	     * @return the number of milliseconds since 1970-01-01T00:00:00	     * @since 1.5 (previously private)	     */	    protected long getLocalMillis() {	        return iLocalMillis;	    }	
/**	     * Gets the chronology of the time.	     * 	     * @return the Chronology that the time is using	     */	    public Chronology getChronology() {	        return iChronology;	    }	
/**	     * Compares this ReadablePartial with another returning true if the chronology,	     * field types and values are equal.	     *	     * @param partial  an object to check against	     * @return true if fields and values are equal	     */	    public boolean equals(Object partial) {	        // override to perform faster	        if (this == partial) {	            return true;	        }	        if (partial instanceof LocalTime) {	            LocalTime other = (LocalTime) partial;	            if (iChronology.equals(other.iChronology)) {	                return iLocalMillis == other.iLocalMillis;	            }	        }	        return super.equals(partial);	    }	
/**	     * Compares this partial with another returning an integer	     * indicating the order.	     * <p>	     * The fields are compared in order, from largest to smallest.	     * The first field that is non-equal is used to determine the result.	     * <p>	     * The specified object must be a partial instance whose field types	     * match those of this partial.	     * <p>	     * NOTE: This implementation violates the Comparable contract.	     * This method will accept any instance of ReadablePartial as input.	     * However, it is possible that some implementations of ReadablePartial	     * exist that do not extend AbstractPartial, and thus will throw a	     * ClassCastException if compared in the opposite direction.	     * The cause of this problem is that ReadablePartial doesn't define	     * the compareTo() method, however we can't change that until v2.0.	     *	     * @param partial  an object to check against	     * @return negative if this is less, zero if equal, positive if greater	     * @throws ClassCastException if the partial is the wrong class	     *  or if it has field types that don't match	     * @throws NullPointerException if the partial is null	     */	    public int compareTo(ReadablePartial partial) {	        // override to perform faster	        if (this == partial) {	            return 0;	        }	        if (partial instanceof LocalTime) {	            LocalTime other = (LocalTime) partial;	            if (iChronology.equals(other.iChronology)) {	                return (iLocalMillis < other.iLocalMillis ? -1 :	                            (iLocalMillis == other.iLocalMillis ? 0 : 1));		            }	        }	        return super.compareTo(partial);	    }	
/**	     * Returns a copy of this time with different local millis.	     * <p>	     * The returned object will be a new instance of the same type.	     * Only the millis will change, the chronology is kept.	     * The returned object will be either be a new instance or <code>this</code>.	     *	     * @param newMillis  the new millis, from 1970-01-01T00:00:00	     * @return a copy of this time with different millis	     */	    LocalTime withLocalMillis(long newMillis) {	        return (newMillis == getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));	    }	
/**	     * Returns a copy of this time with the partial set of fields replacing	     * those from this instance.	     * <p>	     * For example, if the partial contains an hour and minute then those two	     * fields will be changed in the returned instance.	     * Unsupported fields are ignored.	     * If the partial is null, then <code>this</code> is returned.	     *	     * @param partial  the partial set of fields to apply to this time, null ignored	     * @return a copy of this time with a different set of fields	     * @throws IllegalArgumentException if any value is invalid	     */	    public LocalTime withFields(ReadablePartial partial) {	        if (partial == null) {	            return this;	        }	        return withLocalMillis(getChronology().set(partial, getLocalMillis()));	    }	
/**	     * Returns a copy of this time with the specified field set	     * to a new value.	     * <p>	     * For example, if the field type is <code>hourOfDay</code> then the hour of day	     * field would be changed in the returned instance.	     * If the field type is null, then <code>this</code> is returned.	     * <p>	     * These lines are equivalent:	     * <pre>	     * LocalTime updated = dt.withHourOfDay(6);	     * LocalTime updated = dt.withField(DateTimeFieldType.hourOfDay(), 6);	     * </pre>	     *	     * @param fieldType  the field type to set, not null	     * @param value  the value to set	     * @return a copy of this time with the field set	     * @throws IllegalArgumentException if the value is null or invalid	     */	    public LocalTime withField(DateTimeFieldType fieldType, int value) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field must not be null");	        }	        if (isSupported(fieldType) == false) {	            throw new IllegalArgumentException("Field '" + fieldType + "' is not supported");	        }	        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this time with the value of the specified	     * field increased.	     * <p>	     * If the addition is zero or the field is null, then <code>this</code>	     * is returned.	     * <p>	     * If the addition causes the maximum value of the field to be exceeded,	     * then the value will wrap. Thus 23:59 plus two minutes yields 00:01.	     * <p>	     * These lines are equivalent:	     * <pre>	     * LocalTime added = dt.plusHours(6);	     * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);	     * </pre>	     *	     * @param fieldType  the field type to add to, not null	     * @param amount  the amount to add	     * @return a copy of this time with the field updated	     * @throws IllegalArgumentException if the value is null or invalid	     * @throws ArithmeticException if the result exceeds the internal capacity	     */	    public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field must not be null");	        }	        if (isSupported(fieldType) == false) {	            throw new IllegalArgumentException("Field '" + fieldType + "' is not supported");	        }	        if (amount == 0) {	            return this;	        }	        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this time with the specified period added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * <p>	     * This method is typically used to add multiple copies of complex	     * period instances. Adding one field is best achieved using methods	     * like {@link #withFieldAdded(DurationFieldType, int)}	     * or {@link #plusHours(int)}.	     *	     * @param period  the period to add to this one, null means zero	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this time with the period added	     * @throws ArithmeticException if the result exceeds the internal capacity	     */	    public LocalTime withPeriodAdded(ReadablePeriod period, int scalar) {	        if (period == null || scalar == 0) {	            return this;	        }	        long instant = getChronology().add(period, getLocalMillis(), scalar);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this time with the specified period added.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to add complex period instances.	     * Adding one field is best achieved using methods	     * like {@link #plusHours(int)}.	     * 	     * @param period  the period to add to this one, null means zero	     * @return a copy of this time with the period added	     * @throws ArithmeticException if the result exceeds the internal capacity	     */	    public LocalTime plus(ReadablePeriod period) {	        return withPeriodAdded(period, 1);	    }	
/**	     * Returns a copy of this time plus the specified number of hours.	     * <p>	     * This LocalTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalTime added = dt.plusHours(6);	     * LocalTime added = dt.plus(Period.hours(6));	     * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);	     * </pre>	     *	     * @param hours  the amount of hours to add, may be negative	     * @return the new LocalTime plus the increased hours	     */	    public LocalTime plusHours(int hours) {	        if (hours == 0) {	            return this;	        }	        long instant = getChronology().hours().add(getLocalMillis(), hours);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this time plus the specified number of minutes.	     * <p>	     * This LocalTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalTime added = dt.plusMinutes(6);	     * LocalTime added = dt.plus(Period.minutes(6));	     * LocalTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);	     * </pre>	     *	     * @param minutes  the amount of minutes to add, may be negative	     * @return the new LocalTime plus the increased minutes	     */	    public LocalTime plusMinutes(int minutes) {	        if (minutes == 0) {	            return this;	        }	        long instant = getChronology().minutes().add(getLocalMillis(), minutes);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this time plus the specified number of seconds.	     * <p>	     * This LocalTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalTime added = dt.plusSeconds(6);	     * LocalTime added = dt.plus(Period.seconds(6));	     * LocalTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);	     * </pre>	     *	     * @param seconds  the amount of seconds to add, may be negative	     * @return the new LocalTime plus the increased seconds	     */	    public LocalTime plusSeconds(int seconds) {	        if (seconds == 0) {	            return this;	        }	        long instant = getChronology().seconds().add(getLocalMillis(), seconds);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this time plus the specified number of millis.	     * <p>	     * This LocalTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalTime added = dt.plusMillis(6);	     * LocalTime added = dt.plus(Period.millis(6));	     * LocalTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);	     * </pre>	     *	     * @param millis  the amount of millis to add, may be negative	     * @return the new LocalTime plus the increased millis	     */	    public LocalTime plusMillis(int millis) {	        if (millis == 0) {	            return this;	        }	        long instant = getChronology().millis().add(getLocalMillis(), millis);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this time with the specified period taken away.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to subtract complex period instances.	     * Subtracting one field is best achieved using methods	     * like {@link #minusHours(int)}.	     * 	     * @param period  the period to reduce this instant by	     * @return a copy of this time with the period taken away	     * @throws ArithmeticException if the result exceeds the internal capacity	     */	    public LocalTime minus(ReadablePeriod period) {	        return withPeriodAdded(period, -1);	    }	
/**	     * Returns a copy of this time minus the specified number of hours.	     * <p>	     * This LocalTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalTime subtracted = dt.minusHours(6);	     * LocalTime subtracted = dt.minus(Period.hours(6));	     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);	     * </pre>	     *	     * @param hours  the amount of hours to subtract, may be negative	     * @return the new LocalTime minus the increased hours	     */	    public LocalTime minusHours(int hours) {	        if (hours == 0) {	            return this;	        }	        long instant = getChronology().hours().subtract(getLocalMillis(), hours);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this time minus the specified number of minutes.	     * <p>	     * This LocalTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalTime subtracted = dt.minusMinutes(6);	     * LocalTime subtracted = dt.minus(Period.minutes(6));	     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);	     * </pre>	     *	     * @param minutes  the amount of minutes to subtract, may be negative	     * @return the new LocalTime minus the increased minutes	     */	    public LocalTime minusMinutes(int minutes) {	        if (minutes == 0) {	            return this;	        }	        long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this time minus the specified number of seconds.	     * <p>	     * This LocalTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalTime subtracted = dt.minusSeconds(6);	     * LocalTime subtracted = dt.minus(Period.seconds(6));	     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);	     * </pre>	     *	     * @param seconds  the amount of seconds to subtract, may be negative	     * @return the new LocalTime minus the increased seconds	     */	    public LocalTime minusSeconds(int seconds) {	        if (seconds == 0) {	            return this;	        }	        long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);	        return withLocalMillis(instant);	    }	
/**	     * Returns a copy of this time minus the specified number of millis.	     * <p>	     * This LocalTime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * LocalTime subtracted = dt.minusMillis(6);	     * LocalTime subtracted = dt.minus(Period.millis(6));	     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);	     * </pre>	     *	     * @param millis  the amount of millis to subtract, may be negative	     * @return the new LocalTime minus the increased millis	     */	    public LocalTime minusMillis(int millis) {	        if (millis == 0) {	            return this;	        }	        long instant = getChronology().millis().subtract(getLocalMillis(), millis);	        return withLocalMillis(instant);	    }	
/**	     * Gets the property object for the specified type, which contains	     * many useful methods.	     *	     * @param fieldType  the field type to get the chronology for	     * @return the property object	     * @throws IllegalArgumentException if the field is null or unsupported	     */	    public Property property(DateTimeFieldType fieldType) {	        if (fieldType == null) {	            throw new IllegalArgumentException("The DateTimeFieldType must not be null");	        }	        if (isSupported(fieldType) == false) {	            throw new IllegalArgumentException("Field '" + fieldType + "' is not supported");	        }	        return new Property(this, fieldType.getField(getChronology()));	    }	
/**	     * Get the hour of day field value.	     *	     * @return the hour of day	     */	    public int getHourOfDay() {	        return getChronology().hourOfDay().get(getLocalMillis());	    }	
/**	     * Get the minute of hour field value.	     *	     * @return the minute of hour	     */	    public int getMinuteOfHour() {	        return getChronology().minuteOfHour().get(getLocalMillis());	    }	
/**	     * Get the second of minute field value.	     *	     * @return the second of minute	     */	    public int getSecondOfMinute() {	        return getChronology().secondOfMinute().get(getLocalMillis());	    }	
/**	     * Get the millis of second field value.	     *	     * @return the millis of second	     */	    public int getMillisOfSecond() {	        return getChronology().millisOfSecond().get(getLocalMillis());	    }	
/**	     * Get the millis of day field value.	     *	     * @return the millis of day	     */	    public int getMillisOfDay() {	        return getChronology().millisOfDay().get(getLocalMillis());	    }	
/**	     * Returns a copy of this time with the hour of day field updated.	     * <p>	     * LocalTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * hour of day changed.	     *	     * @param hour  the hour of day to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalTime withHourOfDay(int hour) {	        return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));	    }	
/**	     * Returns a copy of this time with the minute of hour field updated.	     * <p>	     * LocalTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * minute of hour changed.	     *	     * @param minute  the minute of hour to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalTime withMinuteOfHour(int minute) {	        return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute));	    }	
/**	     * Returns a copy of this time with the second of minute field updated.	     * <p>	     * LocalTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * second of minute changed.	     *	     * @param second  the second of minute to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalTime withSecondOfMinute(int second) {	        return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second));	    }	
/**	     * Returns a copy of this time with the millis of second field updated.	     * <p>	     * LocalTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * millis of second changed.	     *	     * @param millis  the millis of second to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalTime withMillisOfSecond(int millis) {	        return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis));	    }	
/**	     * Returns a copy of this time with the millis of day field updated.	     * <p>	     * LocalTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * millis of day changed.	     *	     * @param millis  the millis of day to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     */	    public LocalTime withMillisOfDay(int millis) {	        return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis));	    }	
/**	     * Get the hour of day field property which provides access to advanced functionality.	     * 	     * @return the hour of day property	     */	    public Property hourOfDay() {	        return new Property(this, getChronology().hourOfDay());	    }	
/**	     * Get the minute of hour field property which provides access to advanced functionality.	     * 	     * @return the minute of hour property	     */	    public Property minuteOfHour() {	        return new Property(this, getChronology().minuteOfHour());	    }	
/**	     * Get the second of minute field property which provides access to advanced functionality.	     * 	     * @return the second of minute property	     */	    public Property secondOfMinute() {	        return new Property(this, getChronology().secondOfMinute());	    }	
/**	     * Get the millis of second property which provides access to advanced functionality.	     * 	     * @return the millis of second property	     */	    public Property millisOfSecond() {	        return new Property(this, getChronology().millisOfSecond());	    }	
/**	     * Get the millis of day property which provides access to advanced functionality.	     * 	     * @return the millis of day property	     */	    public Property millisOfDay() {	        return new Property(this, getChronology().millisOfDay());	    }	
/**	     * Converts this LocalTime to a full datetime using the default time zone	     * setting the time fields from this instance and the date fields from	     * the current date.	     *	     * @return this time as a datetime using todays date	     */	    public DateTime toDateTimeToday() {	        return toDateTimeToday(null);	    }	
/**	     * Converts this LocalTime to a full datetime using the specified time zone	     * setting the time fields from this instance and the date fields from	     * the current time.	     * <p>	     * This method uses the chronology from this instance plus the time zone	     * specified.	     *	     * @param zone  the zone to use, null means default	     * @return this time as a datetime using todays date	     */	    public DateTime toDateTimeToday(DateTimeZone zone) {	        Chronology chrono = getChronology().withZone(zone);	        long instantMillis = DateTimeUtils.currentTimeMillis();	        long resolved = chrono.set(this, instantMillis);	        return new DateTime(resolved, chrono);	    }	
/**	     * Output the time in ISO8601 format (HH:mm:ss.SSSZZ).	     * 	     * @return ISO8601 time formatted string.	     */	    @ToString	    public String toString() {	        return ISODateTimeFormat.time().print(this);	    }	
/**	     * Output the time using the specified format pattern.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @see org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern) {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).print(this);	    }	
/**	     * Output the time using the specified format pattern.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @param locale  Locale to use, null means default	     * @see org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern, Locale locale) throws IllegalArgumentException {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);	    }	
/**	         * Constructor.	         * 	         * @param instant  the instant to set	         * @param field  the field to use	         */	        Property(LocalTime instant, DateTimeField field) {	            super();	            iInstant = instant;	            iField = field;	        }	
/**	         * Writes the property in a safe serialization format.	         */	        private void writeObject(ObjectOutputStream oos) throws IOException {	            oos.writeObject(iInstant);	            oos.writeObject(iField.getType());	        }	
/**	         * Reads the property from a safe serialization format.	         */	        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {	            iInstant = (LocalTime) oos.readObject();	            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();	            iField = type.getField(iInstant.getChronology());	        }	
/**	         * Gets the field being used.	         * 	         * @return the field	         */	        public DateTimeField getField() {	            return iField;	        }	
/**	         * Gets the milliseconds of the time that this property is linked to.	         * 	         * @return the milliseconds	         */	        protected long getMillis() {	            return iInstant.getLocalMillis();	        }	
/**	         * Gets the chronology of the datetime that this property is linked to.	         * 	         * @return the chronology	         * @since 1.4	         */	        protected Chronology getChronology() {	            return iInstant.getChronology();	        }	
/**	         * Gets the LocalTime object linked to this property.	         * 	         * @return the linked LocalTime	         */	        public LocalTime getLocalTime() {	            return iInstant;	        }	
/**	         * Adds to this field in a copy of this LocalTime.	         * <p>	         * The LocalTime attached to this property is unchanged by this call.	         *	         * @param value  the value to add to the field in the copy	         * @return a copy of the LocalTime with the field value changed	         */	        public LocalTime addCopy(int value) {	            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));	        }	
/**	         * Adds to this field in a copy of this LocalTime.	         * If the addition exceeds the maximum value (eg. 23:59) it will	         * wrap to the minimum value (eg. 00:00).	         * <p>	         * The LocalTime attached to this property is unchanged by this call.	         *	         * @param value  the value to add to the field in the copy	         * @return a copy of the LocalTime with the field value changed	         */	        public LocalTime addCopy(long value) {	            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));	        }	
/**	         * Adds to this field in a copy of this LocalTime.	         * If the addition exceeds the maximum value (eg. 23:59) then	         * an exception will be thrown.	         * Contrast this behaviour to {@link #addCopy(int)}.	         * <p>	         * The LocalTime attached to this property is unchanged by this call.	         *	         * @param value  the value to add to the field in the copy	         * @return a copy of the LocalTime with the field value changed	         * @throws IllegalArgumentException if the result is invalid	         */	        public LocalTime addNoWrapToCopy(int value) {	            long millis = iField.add(iInstant.getLocalMillis(), value);	            long rounded = iInstant.getChronology().millisOfDay().get(millis);	            if (rounded != millis) {	                throw new IllegalArgumentException("The addition exceeded the boundaries of LocalTime");	            }	            return iInstant.withLocalMillis(millis);	        }	
/**	         * Adds to this field, possibly wrapped, in a copy of this LocalTime.	         * A field wrapped operation only changes this field.	         * Thus 10:59 plusWrapField one minute goes to 10:00.	         * <p>	         * The LocalTime attached to this property is unchanged by this call.	         *	         * @param value  the value to add to the field in the copy	         * @return a copy of the LocalTime with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public LocalTime addWrapFieldToCopy(int value) {	            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));	        }	
/**	         * Sets this field in a copy of the LocalTime.	         * <p>	         * The LocalTime attached to this property is unchanged by this call.	         *	         * @param value  the value to set the field in the copy to	         * @return a copy of the LocalTime with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public LocalTime setCopy(int value) {	            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));	        }	
/**	         * Sets this field in a copy of the LocalTime to a parsed text value.	         * <p>	         * The LocalTime attached to this property is unchanged by this call.	         *	         * @param text  the text value to set	         * @param locale  optional locale to use for selecting a text symbol	         * @return a copy of the LocalTime with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public LocalTime setCopy(String text, Locale locale) {	            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));	        }	
/**	         * Sets this field in a copy of the LocalTime to a parsed text value.	         * <p>	         * The LocalTime attached to this property is unchanged by this call.	         *	         * @param text  the text value to set	         * @return a copy of the LocalTime with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public LocalTime setCopy(String text) {	            return setCopy(text, null);	        }	
/**	         * Returns a new LocalTime with this field set to the maximum value	         * for this field.	         * <p>	         * The LocalTime attached to this property is unchanged by this call.	         *	         * @return a copy of the LocalTime with this field set to its maximum	         */	        public LocalTime withMaximumValue() {	            return setCopy(getMaximumValue());	        }	
/**	         * Returns a new LocalTime with this field set to the minimum value	         * for this field.	         * <p>	         * The LocalTime attached to this property is unchanged by this call.	         *	         * @return a copy of the LocalTime with this field set to its minimum	         */	        public LocalTime withMinimumValue() {	            return setCopy(getMinimumValue());	        }	
/**	         * Rounds to the lowest whole unit of this field on a copy of this	         * LocalTime.	         * <p>	         * For example, rounding floor on the hourOfDay field of a LocalTime	         * where the time is 10:30 would result in new LocalTime with the	         * time of 10:00.	         *	         * @return a copy of the LocalTime with the field value changed	         */	        public LocalTime roundFloorCopy() {	            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));	        }	
/**	         * Rounds to the highest whole unit of this field on a copy of this	         * LocalTime.	         * <p>	         * For example, rounding floor on the hourOfDay field of a LocalTime	         * where the time is 10:30 would result in new LocalTime with the	         * time of 11:00.	         *	         * @return a copy of the LocalTime with the field value changed	         */	        public LocalTime roundCeilingCopy() {	            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));	        }	
/**	         * Rounds to the nearest whole unit of this field on a copy of this	         * LocalTime, favoring the floor if halfway.	         *	         * @return a copy of the LocalTime with the field value changed	         */	        public LocalTime roundHalfFloorCopy() {	            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));	        }	
/**	         * Rounds to the nearest whole unit of this field on a copy of this	         * LocalTime, favoring the ceiling if halfway.	         *	         * @return a copy of the LocalTime with the field value changed	         */	        public LocalTime roundHalfCeilingCopy() {	            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));	        }	
/**	         * Rounds to the nearest whole unit of this field on a copy of this	         * LocalTime.  If halfway, the ceiling is favored over the floor	         * only if it makes this field's value even.	         *	         * @return a copy of the LocalTime with the field value changed	         */	        public LocalTime roundHalfEvenCopy() {	            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));	        }	
/**	     * Obtains an instance of <code>Years</code> that may be cached.	     * <code>Years</code> is immutable, so instances can be cached and shared.	     * This factory method provides access to shared instances.	     *	     * @param years  the number of years to obtain an instance for	     * @return the instance of Years	     */	    public static Years years(int years) {	        switch (years) {	            case 0:	                return ZERO;	            case 1:	                return ONE;	            case 2:	                return TWO;	            case 3:	                return THREE;	            case Integer.MAX_VALUE:	                return MAX_VALUE;	            case Integer.MIN_VALUE:	                return MIN_VALUE;	            default:	                return new Years(years);	        }	    }	
/**	     * Creates a <code>Years</code> representing the number of whole years	     * between the two specified datetimes. This method corectly handles	     * any daylight savings time changes that may occur during the interval.	     *	     * @param start  the start instant, must not be null	     * @param end  the end instant, must not be null	     * @return the period in years	     * @throws IllegalArgumentException if the instants are null or invalid	     */	    public static Years yearsBetween(ReadableInstant start, ReadableInstant end) {	        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.years());	        return Years.years(amount);	    }	
/**	     * Creates a <code>Years</code> representing the number of whole years	     * between the two specified partial datetimes.	     * <p>	     * The two partials must contain the same fields, for example you can specify	     * two <code>LocalDate</code> objects.	     *	     * @param start  the start partial date, must not be null	     * @param end  the end partial date, must not be null	     * @return the period in years	     * @throws IllegalArgumentException if the partials are null or invalid	     */	    public static Years yearsBetween(ReadablePartial start, ReadablePartial end) {	        if (start instanceof LocalDate && end instanceof LocalDate)   {	            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());	            int years = chrono.years().getDifference(	                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());	            return Years.years(years);	        }	        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);	        return Years.years(amount);	    }	
/**	     * Creates a <code>Years</code> representing the number of whole years	     * in the specified interval. This method corectly handles any daylight	     * savings time changes that may occur during the interval.	     *	     * @param interval  the interval to extract years from, null returns zero	     * @return the period in years	     * @throws IllegalArgumentException if the partials are null or invalid	     */	    public static Years yearsIn(ReadableInterval interval) {	        if (interval == null)   {	            return Years.ZERO;	        }	        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.years());	        return Years.years(amount);	    }	
/**	     * Creates a new <code>Years</code> by parsing a string in the ISO8601 format 'PnY'.	     * <p>	     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the	     * years component may be non-zero. If any other component is non-zero, an exception	     * will be thrown.	     *	     * @param periodStr  the period string, null returns zero	     * @return the period in years	     * @throws IllegalArgumentException if the string format is invalid	     */	    @FromString	    public static Years parseYears(String periodStr) {	        if (periodStr == null) {	            return Years.ZERO;	        }	        Period p = PARSER.parsePeriod(periodStr);	        return Years.years(p.getYears());	    }	
/**	     * Creates a new instance representing a number of years.	     * You should consider using the factory method {@link #years(int)}	     * instead of the constructor.	     *	     * @param years  the number of years to represent	     */	    private Years(int years) {	        super(years);	    }	
/**	     * Resolves singletons.	     * 	     * @return the singleton instance	     */	    private Object readResolve() {	        return Years.years(getValue());	    }	
/**	     * Gets the duration field type, which is <code>years</code>.	     *	     * @return the period type	     */	    public DurationFieldType getFieldType() {	        return DurationFieldType.years();	    }	
/**	     * Gets the period type, which is <code>years</code>.	     *	     * @return the period type	     */	    public PeriodType getPeriodType() {	        return PeriodType.years();	    }	
/**	     * Gets the number of years that this period represents.	     *	     * @return the number of years in the period	     */	    public int getYears() {	        return getValue();	    }	
/**	     * Returns a new instance with the specified number of years added.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param years  the amount of years to add, may be negative	     * @return the new period plus the specified number of years	     * @throws ArithmeticException if the result overflows an int	     */	    public Years plus(int years) {	        if (years == 0) {	            return this;	        }	        return Years.years(FieldUtils.safeAdd(getValue(), years));	    }	
/**	     * Returns a new instance with the specified number of years added.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param years  the amount of years to add, may be negative, null means zero	     * @return the new period plus the specified number of years	     * @throws ArithmeticException if the result overflows an int	     */	    public Years plus(Years years) {	        if (years == null) {	            return this;	        }	        return plus(years.getValue());	    }	
/**	     * Returns a new instance with the specified number of years taken away.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param years  the amount of years to take away, may be negative	     * @return the new period minus the specified number of years	     * @throws ArithmeticException if the result overflows an int	     */	    public Years minus(int years) {	        return plus(FieldUtils.safeNegate(years));	    }	
/**	     * Returns a new instance with the specified number of years taken away.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param years  the amount of years to take away, may be negative, null means zero	     * @return the new period minus the specified number of years	     * @throws ArithmeticException if the result overflows an int	     */	    public Years minus(Years years) {	        if (years == null) {	            return this;	        }	        return minus(years.getValue());	    }	
/**	     * Returns a new instance with the years multiplied by the specified scalar.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param scalar  the amount to multiply by, may be negative	     * @return the new period multiplied by the specified scalar	     * @throws ArithmeticException if the result overflows an int	     */	    public Years multipliedBy(int scalar) {	        return Years.years(FieldUtils.safeMultiply(getValue(), scalar));	    }	
/**	     * Returns a new instance with the years divided by the specified divisor.	     * The calculation uses integer division, thus 3 divided by 2 is 1.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param divisor  the amount to divide by, may be negative	     * @return the new period divided by the specified divisor	     * @throws ArithmeticException if the divisor is zero	     */	    public Years dividedBy(int divisor) {	        if (divisor == 1) {	            return this;	        }	        return Years.years(getValue() / divisor);	    }	
/**	     * Returns a new instance with the years value negated.	     *	     * @return the new period with a negated value	     * @throws ArithmeticException if the result overflows an int	     */	    public Years negated() {	        return Years.years(FieldUtils.safeNegate(getValue()));	    }	
/**	     * Is this years instance greater than the specified number of years.	     *	     * @param other  the other period, null means zero	     * @return true if this years instance is greater than the specified one	     */	    public boolean isGreaterThan(Years other) {	        if (other == null) {	            return getValue() > 0;	        }	        return getValue() > other.getValue();	    }	
/**	     * Is this years instance less than the specified number of years.	     *	     * @param other  the other period, null means zero	     * @return true if this years instance is less than the specified one	     */	    public boolean isLessThan(Years other) {	        if (other == null) {	            return getValue() < 0;	        }	        return getValue() < other.getValue();	    }	
/**	     * Gets this instance as a String in the ISO8601 duration format.	     * <p>	     * For example, "P4Y" represents 4 years.	     *	     * @return the value as an ISO8601 string	     */	    @ToString	    public String toString() {	        return "P" + String.valueOf(getValue()) + "Y";	    }	
/**	     * Parses a {@code Interval} from the specified string.	     * <p>	     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}	     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',	     * 'datetime/period' or 'period/datetime'.	     * 	     * @param str  the string to parse, not null	     * @since 2.0	     */	    public static Interval parse(String str) {	        return new Interval(str);	    }	
/**	     * Constructs an interval from a start and end instant with the ISO	     * default chronology in the default time zone.	     * 	     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.	     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.	     * @throws IllegalArgumentException if the end is before the start	     */	    public Interval(long startInstant, long endInstant) {	        super(startInstant, endInstant, null);	    }	
/**	     * Constructs an interval from a start and end instant with the ISO	     * default chronology in the specified time zone.	     * 	     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.	     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.	     * @param zone  the time zone to use, null means default zone	     * @throws IllegalArgumentException if the end is before the start	     * @since 1.5	     */	    public Interval(long startInstant, long endInstant, DateTimeZone zone) {	        super(startInstant, endInstant, ISOChronology.getInstance(zone));	    }	
/**	     * Constructs an interval from a start and end instant with the	     * specified chronology.	     * 	     * @param chronology  the chronology to use, null is ISO default	     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.	     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.	     * @throws IllegalArgumentException if the end is before the start	     */	    public Interval(long startInstant, long endInstant, Chronology chronology) {	        super(startInstant, endInstant, chronology);	    }	
/**	     * Constructs an interval from a start and end instant.	     * <p>	     * The chronology used is that of the start instant.	     * 	     * @param start  start of this interval, null means now	     * @param end  end of this interval, null means now	     * @throws IllegalArgumentException if the end is before the start	     */	    public Interval(ReadableInstant start, ReadableInstant end) {	        super(start, end);	    }	
/**	     * Constructs an interval from a start instant and a duration.	     * 	     * @param start  start of this interval, null means now	     * @param duration  the duration of this interval, null means zero length	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the end instant exceeds the capacity of a long	     */	    public Interval(ReadableInstant start, ReadableDuration duration) {	        super(start, duration);	    }	
/**	     * Constructs an interval from a millisecond duration and an end instant.	     * 	     * @param duration  the duration of this interval, null means zero length	     * @param end  end of this interval, null means now	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the start instant exceeds the capacity of a long	     */	    public Interval(ReadableDuration duration, ReadableInstant end) {	        super(duration, end);	    }	
/**	     * Constructs an interval from a start instant and a time period.	     * <p>	     * When forming the interval, the chronology from the instant is used	     * if present, otherwise the chronology of the period is used.	     * 	     * @param start  start of this interval, null means now	     * @param period  the period of this interval, null means zero length	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the end instant exceeds the capacity of a long	     */	    public Interval(ReadableInstant start, ReadablePeriod period) {	        super(start, period);	    }	
/**	     * Constructs an interval from a time period and an end instant.	     * <p>	     * When forming the interval, the chronology from the instant is used	     * if present, otherwise the chronology of the period is used.	     * 	     * @param period  the period of this interval, null means zero length	     * @param end  end of this interval, null means now	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the start instant exceeds the capacity of a long	     */	    public Interval(ReadablePeriod period, ReadableInstant end) {	        super(period, end);	    }	
/**	     * Constructs a time interval by converting or copying from another object.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInterval and String.	     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}	     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',	     * 'datetime/period' or 'period/datetime'.	     * 	     * @param interval  the time interval to copy	     * @throws IllegalArgumentException if the interval is invalid	     */	    public Interval(Object interval) {	        super(interval, null);	    }	
/**	     * Constructs a time interval by converting or copying from another object,	     * overriding the chronology.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInterval and String.	     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}	     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',	     * 'datetime/period' or 'period/datetime'.	     * 	     * @param interval  the time interval to copy	     * @param chronology  the chronology to use, null means ISO default	     * @throws IllegalArgumentException if the interval is invalid	     */	    public Interval(Object interval, Chronology chronology) {	        super(interval, chronology);	    }	
/**	     * Get this interval as an immutable <code>Interval</code> object	     * by returning <code>this</code>.	     *	     * @return <code>this</code>	     */	    public Interval toInterval() {	        return this;	    }	
/**	     * Gets the overlap between this interval and another interval.	     * <p>	     * Intervals are inclusive of the start instant and exclusive of the end.	     * An interval overlaps another if it shares some common part of the	     * datetime continuum. This method returns the amount of the overlap,	     * only if the intervals actually do overlap.	     * If the intervals do not overlap, then null is returned.	     * <p>	     * When two intervals are compared the result is one of three states:	     * (a) they abut, (b) there is a gap between them, (c) they overlap.	     * The abuts state takes precedence over the other two, thus a zero duration	     * interval at the start of a larger interval abuts and does not overlap.	     * <p>	     * The chronology of the returned interval is the same as that of	     * this interval (the chronology of the interval parameter is not used).	     * Note that the use of the chronology was only correctly implemented	     * in version 1.3.	     *	     * @param interval  the interval to examine, null means now	     * @return the overlap interval, null if no overlap	     * @since 1.1	     */	    public Interval overlap(ReadableInterval interval) {	        interval = DateTimeUtils.getReadableInterval(interval);	        if (overlaps(interval) == false) {	            return null;	        }	        long start = Math.max(getStartMillis(), interval.getStartMillis());	        long end = Math.min(getEndMillis(), interval.getEndMillis());	        return new Interval(start, end, getChronology());	    }	
/**	     * Gets the gap between this interval and another interval.	     * The other interval can be either before or after this interval.	     * <p>	     * Intervals are inclusive of the start instant and exclusive of the end.	     * An interval has a gap to another interval if there is a non-zero	     * duration between them. This method returns the amount of the gap only	     * if the intervals do actually have a gap between them.	     * If the intervals overlap or abut, then null is returned.	     * <p>	     * When two intervals are compared the result is one of three states:	     * (a) they abut, (b) there is a gap between them, (c) they overlap.	     * The abuts state takes precedence over the other two, thus a zero duration	     * interval at the start of a larger interval abuts and does not overlap.	     * <p>	     * The chronology of the returned interval is the same as that of	     * this interval (the chronology of the interval parameter is not used).	     * Note that the use of the chronology was only correctly implemented	     * in version 1.3.	     *	     * @param interval  the interval to examine, null means now	     * @return the gap interval, null if no gap	     * @since 1.1	     */	    public Interval gap(ReadableInterval interval) {	        interval = DateTimeUtils.getReadableInterval(interval);	        long otherStart = interval.getStartMillis();	        long otherEnd = interval.getEndMillis();	        long thisStart = getStartMillis();	        long thisEnd = getEndMillis();	        if (thisStart > otherEnd) {	            return new Interval(otherEnd, thisStart, getChronology());	        } else if (otherStart > thisEnd) {	            return new Interval(thisEnd, otherStart, getChronology());	        } else {	            return null;	        }	    }	
/**	     * Does this interval abut with the interval specified.	     * <p>	     * Intervals are inclusive of the start instant and exclusive of the end.	     * An interval abuts if it starts immediately after, or ends immediately	     * before this interval without overlap.	     * A zero duration interval abuts with itself.	     * <p>	     * When two intervals are compared the result is one of three states:	     * (a) they abut, (b) there is a gap between them, (c) they overlap.	     * The abuts state takes precedence over the other two, thus a zero duration	     * interval at the start of a larger interval abuts and does not overlap.	     * <p>	     * For example:	     * <pre>	     * [09:00 to 10:00) abuts [08:00 to 08:30)  = false (completely before)	     * [09:00 to 10:00) abuts [08:00 to 09:00)  = true	     * [09:00 to 10:00) abuts [08:00 to 09:01)  = false (overlaps)	     * 	     * [09:00 to 10:00) abuts [09:00 to 09:00)  = true	     * [09:00 to 10:00) abuts [09:00 to 09:01)  = false (overlaps)	     * 	     * [09:00 to 10:00) abuts [10:00 to 10:00)  = true	     * [09:00 to 10:00) abuts [10:00 to 10:30)  = true	     * 	     * [09:00 to 10:00) abuts [10:30 to 11:00)  = false (completely after)	     * 	     * [14:00 to 14:00) abuts [14:00 to 14:00)  = true	     * [14:00 to 14:00) abuts [14:00 to 15:00)  = true	     * [14:00 to 14:00) abuts [13:00 to 14:00)  = true	     * </pre>	     *	     * @param interval  the interval to examine, null means now	     * @return true if the interval abuts	     * @since 1.1	     */	    public boolean abuts(ReadableInterval interval) {	        if (interval == null) {	            long now = DateTimeUtils.currentTimeMillis();	            return (getStartMillis() == now || getEndMillis() == now);	        } else {	            return (interval.getEndMillis() == getStartMillis() ||	                    getEndMillis() == interval.getStartMillis());	        }	    }	
/**	     * Creates a new interval with the same start and end, but a different chronology.	     *	     * @param chronology  the chronology to use, null means ISO default	     * @return an interval with a different chronology	     */	    public Interval withChronology(Chronology chronology) {	        if (getChronology() == chronology) {	            return this;	        }	        return new Interval(getStartMillis(), getEndMillis(), chronology);	    }	
/**	     * Creates a new interval with the specified start millisecond instant.	     *	     * @param startInstant  the start instant for the new interval	     * @return an interval with the end from this interval and the specified start	     * @throws IllegalArgumentException if the resulting interval has end before start	     */	    public Interval withStartMillis(long startInstant) {	        if (startInstant == getStartMillis()) {	            return this;	        }	        return new Interval(startInstant, getEndMillis(), getChronology());	    }	
/**	     * Creates a new interval with the specified start instant.	     *	     * @param start  the start instant for the new interval, null means now	     * @return an interval with the end from this interval and the specified start	     * @throws IllegalArgumentException if the resulting interval has end before start	     */	    public Interval withStart(ReadableInstant start) {	        long startMillis = DateTimeUtils.getInstantMillis(start);	        return withStartMillis(startMillis);	    }	
/**	     * Creates a new interval with the specified start millisecond instant.	     *	     * @param endInstant  the end instant for the new interval	     * @return an interval with the start from this interval and the specified end	     * @throws IllegalArgumentException if the resulting interval has end before start	     */	    public Interval withEndMillis(long endInstant) {	        if (endInstant == getEndMillis()) {	            return this;	        }	        return new Interval(getStartMillis(), endInstant, getChronology());	    }	
/**	     * Creates a new interval with the specified end instant.	     *	     * @param end  the end instant for the new interval, null means now	     * @return an interval with the start from this interval and the specified end	     * @throws IllegalArgumentException if the resulting interval has end before start	     */	    public Interval withEnd(ReadableInstant end) {	        long endMillis = DateTimeUtils.getInstantMillis(end);	        return withEndMillis(endMillis);	    }	
/**	     * Creates a new interval with the specified duration after the start instant.	     *	     * @param duration  the duration to add to the start to get the new end instant, null means zero	     * @return an interval with the start from this interval and a calculated end	     * @throws IllegalArgumentException if the duration is negative	     */	    public Interval withDurationAfterStart(ReadableDuration duration) {	        long durationMillis = DateTimeUtils.getDurationMillis(duration);	        if (durationMillis == toDurationMillis()) {	            return this;	        }	        Chronology chrono = getChronology();	        long startMillis = getStartMillis();	        long endMillis = chrono.add(startMillis, durationMillis, 1);	        return new Interval(startMillis, endMillis, chrono);	    }	
/**	     * Creates a new interval with the specified duration before the end instant.	     *	     * @param duration  the duration to add to the start to get the new end instant, null means zero	     * @return an interval with the start from this interval and a calculated end	     * @throws IllegalArgumentException if the duration is negative	     */	    public Interval withDurationBeforeEnd(ReadableDuration duration) {	        long durationMillis = DateTimeUtils.getDurationMillis(duration);	        if (durationMillis == toDurationMillis()) {	            return this;	        }	        Chronology chrono = getChronology();	        long endMillis = getEndMillis();	        long startMillis = chrono.add(endMillis, durationMillis, -1);	        return new Interval(startMillis, endMillis, chrono);	    }	
/**	     * Creates a new interval with the specified period after the start instant.	     *	     * @param period  the period to add to the start to get the new end instant, null means zero	     * @return an interval with the start from this interval and a calculated end	     * @throws IllegalArgumentException if the period is negative	     */	    public Interval withPeriodAfterStart(ReadablePeriod period) {	        if (period == null) {	            return withDurationAfterStart(null);	        }	        Chronology chrono = getChronology();	        long startMillis = getStartMillis();	        long endMillis = chrono.add(period, startMillis, 1);	        return new Interval(startMillis, endMillis, chrono);	    }	
/**	     * Creates a new interval with the specified period before the end instant.	     *	     * @param period  the period to add to the start to get the new end instant, null means zero	     * @return an interval with the start from this interval and a calculated end	     * @throws IllegalArgumentException if the period is negative	     */	    public Interval withPeriodBeforeEnd(ReadablePeriod period) {	        if (period == null) {	            return withDurationBeforeEnd(null);	        }	        Chronology chrono = getChronology();	        long endMillis = getEndMillis();	        long startMillis = chrono.add(period, endMillis, -1);	        return new Interval(startMillis, endMillis, chrono);	    }	
/**	     * Constructs a TimeOfDay from a <code>java.util.Calendar</code>	     * using exactly the same field values avoiding any time zone effects.	     * <p>	     * Each field is queried from the Calendar and assigned to the TimeOfDay.	     * This is useful to ensure that the field values are the same in the	     * created TimeOfDay no matter what the time zone is. For example, if	     * the Calendar states that the time is 04:29, then the created TimeOfDay	     * will always have the time 04:29 irrespective of time zone issues.	     * <p>	     * This factory method ignores the type of the calendar and always	     * creates a TimeOfDay with ISO chronology.	     *	     * @param calendar  the Calendar to extract fields from	     * @return the created TimeOfDay	     * @throws IllegalArgumentException if the calendar is null	     * @throws IllegalArgumentException if the time is invalid for the ISO chronology	     * @since 1.2	     */	    public static TimeOfDay fromCalendarFields(Calendar calendar) {	        if (calendar == null) {	            throw new IllegalArgumentException("The calendar must not be null");	        }	        return new TimeOfDay(	            calendar.get(Calendar.HOUR_OF_DAY),	            calendar.get(Calendar.MINUTE),	            calendar.get(Calendar.SECOND),	            calendar.get(Calendar.MILLISECOND)	        );	    }	
/**	     * Constructs a TimeOfDay from a <code>java.util.Date</code>	     * using exactly the same field values avoiding any time zone effects.	     * <p>	     * Each field is queried from the Date and assigned to the TimeOfDay.	     * This is useful to ensure that the field values are the same in the	     * created TimeOfDay no matter what the time zone is. For example, if	     * the Calendar states that the time is 04:29, then the created TimeOfDay	     * will always have the time 04:29 irrespective of time zone issues.	     * <p>	     * This factory method always creates a TimeOfDay with ISO chronology.	     *	     * @param date  the Date to extract fields from	     * @return the created TimeOfDay	     * @throws IllegalArgumentException if the calendar is null	     * @throws IllegalArgumentException if the date is invalid for the ISO chronology	     * @since 1.2	     */	    public static TimeOfDay fromDateFields(Date date) {	        if (date == null) {	            throw new IllegalArgumentException("The date must not be null");	        }	        return new TimeOfDay(	            date.getHours(),	            date.getMinutes(),	            date.getSeconds(),	            (((int) (date.getTime() % 1000)) + 1000) % 1000	        );	    }	
/**	     * Constructs a TimeOfDay from the specified millis of day using the	     * ISO chronology.	     * <p>	     * The millisOfDay value may exceed the number of millis in one day,	     * but additional days will be ignored.	     * This method uses the UTC time zone internally.	     *	     * @param millisOfDay  the number of milliseconds into a day to convert	     */	    public static TimeOfDay fromMillisOfDay(long millisOfDay) {	        return fromMillisOfDay(millisOfDay, null);	    }	
/**	     * Constructs a TimeOfDay from the specified millis of day using the	     * specified chronology.	     * <p>	     * The millisOfDay value may exceed the number of millis in one day,	     * but additional days will be ignored.	     * This method uses the UTC time zone internally.	     *	     * @param millisOfDay  the number of milliseconds into a day to convert	     * @param chrono  the chronology, null means ISO chronology	     */	    public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) {	        chrono = DateTimeUtils.getChronology(chrono);	        chrono = chrono.withUTC();	        return new TimeOfDay(millisOfDay, chrono);	    }	
/**	     * Constructs a TimeOfDay with the current time, using ISOChronology in	     * the default zone to extract the fields.	     * <p>	     * The constructor uses the default time zone, resulting in the local time	     * being initialised. Once the constructor is complete, all further calculations	     * are performed without reference to a timezone (by switching to UTC).	     */	    public TimeOfDay() {	        super();	    }	
/**	     * Constructs a TimeOfDay with the current time, using ISOChronology in	     * the specified zone to extract the fields.	     * <p>	     * The constructor uses the specified time zone to obtain the current time.	     * Once the constructor is complete, all further calculations	     * are performed without reference to a timezone (by switching to UTC).	     * 	     * @param zone  the zone to use, null means default zone	     * @since 1.1	     */	    public TimeOfDay(DateTimeZone zone) {	        super(ISOChronology.getInstance(zone));	    }	
/**	     * Constructs a TimeOfDay with the current time, using the specified chronology	     * and zone to extract the fields.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a timezone (by switching to UTC).	     *	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    public TimeOfDay(Chronology chronology) {	        super(chronology);	    }	
/**	     * Constructs a TimeOfDay extracting the partial fields from the specified	     * milliseconds using the ISOChronology in the default zone.	     * <p>	     * The constructor uses the default time zone, resulting in the local time	     * being initialised. Once the constructor is complete, all further calculations	     * are performed without reference to a timezone (by switching to UTC).	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     */	    public TimeOfDay(long instant) {	        super(instant);	    }	
/**	     * Constructs a TimeOfDay extracting the partial fields from the specified	     * milliseconds using the chronology provided.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a timezone (by switching to UTC).	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    public TimeOfDay(long instant, Chronology chronology) {	        super(instant, chronology);	    }	
/**	     * Constructs a TimeOfDay from an Object that represents a time.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#timeParser()}.	     * <p>	     * The chronology used will be derived from the object, defaulting to ISO.	     * <p>	     * NOTE: Prior to v1.3 the string format was described by	     * {@link ISODateTimeFormat#dateTimeParser()}. Dates are now rejected.	     *	     * @param instant  the datetime object, null means now	     * @throws IllegalArgumentException if the instant is invalid	     */	    public TimeOfDay(Object instant) {	        super(instant, null, ISODateTimeFormat.timeParser());	    }	
/**	     * Constructs a TimeOfDay from an Object that represents a time, using the	     * specified chronology.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#timeParser()}.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a timezone (by switching to UTC).	     * The specified chronology overrides that of the object.	     * <p>	     * NOTE: Prior to v1.3 the string format was described by	     * {@link ISODateTimeFormat#dateTimeParser()}. Dates are now rejected.	     *	     * @param instant  the datetime object, null means now	     * @param chronology  the chronology, null means ISO default	     * @throws IllegalArgumentException if the instant is invalid	     */	    public TimeOfDay(Object instant, Chronology chronology) {	        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser());	    }	
/**	     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds	     * using <code>ISOChronology</code> in the default zone.	     * <p>	     * The constructor uses the no time zone initialising the fields as provided.	     * Once the constructor is complete, all further calculations	     * are performed without reference to a timezone (by switching to UTC).	     *	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     */	    public TimeOfDay(int hourOfDay, int minuteOfHour) {	        this(hourOfDay, minuteOfHour, 0, 0, null);	    }	
/**	     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a timezone (by switching to UTC).	     *	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) {	        this(hourOfDay, minuteOfHour, 0, 0, chronology);	    }	
/**	     * Constructs a TimeOfDay with specified time field values and zero milliseconds	     * using <code>ISOChronology</code> in the default zone.	     * <p>	     * The constructor uses the no time zone initialising the fields as provided.	     * Once the constructor is complete, all further calculations	     * are performed without reference to a timezone (by switching to UTC).	     *	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     */	    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) {	        this(hourOfDay, minuteOfHour, secondOfMinute, 0, null);	    }	
/**	     * Constructs a TimeOfDay with specified time field values and zero milliseconds.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a timezone (by switching to UTC).	     *	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) {	        this(hourOfDay, minuteOfHour, secondOfMinute, 0, chronology);	    }	
/**	     * Constructs a TimeOfDay with specified time field values using	     * <code>ISOChronology</code> in the default zone.	     * <p>	     * The constructor uses the no time zone initialising the fields as provided.	     * Once the constructor is complete, all further calculations	     * are performed without reference to a timezone (by switching to UTC).	     *	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     */	    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {	        this(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, null);	    }	
/**	     * Constructs a TimeOfDay with specified time field values and chronology.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a timezone (by switching to UTC).	     *	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    public TimeOfDay(int hourOfDay, int minuteOfHour,	            int secondOfMinute, int millisOfSecond, Chronology chronology) {	        super(new int[] {hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond}, chronology);	    }	
/**	     * Constructs a TimeOfDay with chronology from this instance and new values.	     *	     * @param partial  the partial to base this new instance on	     * @param values  the new set of values	     */	    TimeOfDay(TimeOfDay partial, int[] values) {	        super(partial, values);	    }	
/**	     * Constructs a TimeOfDay with values from this instance and a new chronology.	     *	     * @param partial  the partial to base this new instance on	     * @param chrono  the new chronology	     */	    TimeOfDay(TimeOfDay partial, Chronology chrono) {	        super(partial, chrono);	    }	
/**	     * Gets the number of fields in this partial.	     * 	     * @return the field count	     */	    public int size() {	        return 4;	    }	
/**	     * Gets the field for a specific index in the chronology specified.	     * <p>	     * This method must not use any instance variables.	     * 	     * @param index  the index to retrieve	     * @param chrono  the chronology to use	     * @return the field	     */	    protected DateTimeField getField(int index, Chronology chrono) {	        switch (index) {	            case HOUR_OF_DAY:	                return chrono.hourOfDay();	            case MINUTE_OF_HOUR:	                return chrono.minuteOfHour();	            case SECOND_OF_MINUTE:	                return chrono.secondOfMinute();	            case MILLIS_OF_SECOND:	                return chrono.millisOfSecond();	            default:	                throw new IndexOutOfBoundsException("Invalid index: " + index);	        }	    }	
/**	     * Gets the field type at the specified index.	     *	     * @param index  the index to retrieve	     * @return the field at the specified index	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public DateTimeFieldType getFieldType(int index) {	        return FIELD_TYPES[index];	    }	
/**	     * Gets an array of the field type of each of the fields that this partial supports.	     * <p>	     * The fields are returned largest to smallest, Hour, Minute, Second, Millis.	     *	     * @return the array of field types (cloned), largest to smallest	     */	    public DateTimeFieldType[] getFieldTypes() {	        return (DateTimeFieldType[]) FIELD_TYPES.clone();	    }	
/**	     * Returns a copy of this time with the specified chronology.	     * This instance is immutable and unaffected by this method call.	     * <p>	     * This method retains the values of the fields, thus the result will	     * typically refer to a different instant.	     * <p>	     * The time zone of the specified chronology is ignored, as TimeOfDay	     * operates without a time zone.	     *	     * @param newChronology  the new chronology, null means ISO	     * @return a copy of this datetime with a different chronology	     * @throws IllegalArgumentException if the values are invalid for the new chronology	     */	    public TimeOfDay withChronologyRetainFields(Chronology newChronology) {	        newChronology = DateTimeUtils.getChronology(newChronology);	        newChronology = newChronology.withUTC();	        if (newChronology == getChronology()) {	            return this;	        } else {	            TimeOfDay newTimeOfDay = new TimeOfDay(this, newChronology);	            newChronology.validate(newTimeOfDay, getValues());	            return newTimeOfDay;	        }	    }	
/**	     * Returns a copy of this time with the specified field set to a new value.	     * <p>	     * For example, if the field type is <code>minuteOfHour</code> then the day	     * would be changed in the returned instance.	     * <p>	     * These three lines are equivalent:	     * <pre>	     * TimeOfDay updated = tod.withField(DateTimeFieldType.minuteOfHour(), 6);	     * TimeOfDay updated = tod.minuteOfHour().setCopy(6);	     * TimeOfDay updated = tod.property(DateTimeFieldType.minuteOfHour()).setCopy(6);	     * </pre>	     *	     * @param fieldType  the field type to set, not null	     * @param value  the value to set	     * @return a copy of this instance with the field set	     * @throws IllegalArgumentException if the value is null or invalid	     */	    public TimeOfDay withField(DateTimeFieldType fieldType, int value) {	        int index = indexOfSupported(fieldType);	        if (value == getValue(index)) {	            return this;	        }	        int[] newValues = getValues();	        newValues = getField(index).set(this, index, newValues, value);	        return new TimeOfDay(this, newValues);	    }	
/**	     * Returns a copy of this time with the value of the specified field increased,	     * wrapping to what would be a new day if required.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * <p>	     * These three lines are equivalent:	     * <pre>	     * TimeOfDay added = tod.withFieldAdded(DurationFieldType.minutes(), 6);	     * TimeOfDay added = tod.plusMinutes(6);	     * TimeOfDay added = tod.minuteOfHour().addToCopy(6);	     * </pre>	     * 	     * @param fieldType  the field type to add to, not null	     * @param amount  the amount to add	     * @return a copy of this instance with the field updated	     * @throws IllegalArgumentException if the value is null or invalid	     * @throws ArithmeticException if the new datetime exceeds the capacity	     */	    public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) {	        int index = indexOfSupported(fieldType);	        if (amount == 0) {	            return this;	        }	        int[] newValues = getValues();	        newValues = getField(index).addWrapPartial(this, index, newValues, amount);	        return new TimeOfDay(this, newValues);	    }	
/**	     * Returns a copy of this time with the specified period added,	     * wrapping to what would be a new day if required.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * Fields in the period that aren't present in the partial are ignored.	     * <p>	     * This method is typically used to add multiple copies of complex	     * period instances. Adding one field is best achieved using methods	     * like {@link #withFieldAdded(DurationFieldType, int)}	     * or {@link #plusHours(int)}.	     * 	     * @param period  the period to add to this one, null means zero	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this instance with the period added	     * @throws ArithmeticException if the new datetime exceeds the capacity	     */	    public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) {	        if (period == null || scalar == 0) {	            return this;	        }	        int[] newValues = getValues();	        for (int i = 0; i < period.size(); i++) {	            DurationFieldType fieldType = period.getFieldType(i);	            int index = indexOf(fieldType);	            if (index >= 0) {	                newValues = getField(index).addWrapPartial(this, index, newValues,	                        FieldUtils.safeMultiply(period.getValue(i), scalar));	            }	        }	        return new TimeOfDay(this, newValues);	    }	
/**	     * Returns a copy of this time with the specified period added,	     * wrapping to what would be a new day if required.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to add complex period instances.	     * Adding one field is best achieved using methods	     * like {@link #plusHours(int)}.	     * 	     * @param period  the duration to add to this one, null means zero	     * @return a copy of this instance with the period added	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public TimeOfDay plus(ReadablePeriod period) {	        return withPeriodAdded(period, 1);	    }	
/**	     * Returns a copy of this time plus the specified number of hours.	     * <p>	     * This time instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * TimeOfDay added = dt.plusHours(6);	     * TimeOfDay added = dt.plus(Period.hours(6));	     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.hours(), 6);	     * </pre>	     *	     * @param hours  the amount of hours to add, may be negative	     * @return the new time plus the increased hours	     * @since 1.1	     */	    public TimeOfDay plusHours(int hours) {	        return withFieldAdded(DurationFieldType.hours(), hours);	    }	
/**	     * Returns a copy of this time plus the specified number of minutes.	     * <p>	     * This time instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * TimeOfDay added = dt.plusMinutes(6);	     * TimeOfDay added = dt.plus(Period.minutes(6));	     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.minutes(), 6);	     * </pre>	     *	     * @param minutes  the amount of minutes to add, may be negative	     * @return the new time plus the increased minutes	     * @since 1.1	     */	    public TimeOfDay plusMinutes(int minutes) {	        return withFieldAdded(DurationFieldType.minutes(), minutes);	    }	
/**	     * Returns a copy of this time plus the specified number of seconds.	     * <p>	     * This time instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * TimeOfDay added = dt.plusSeconds(6);	     * TimeOfDay added = dt.plus(Period.seconds(6));	     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.seconds(), 6);	     * </pre>	     *	     * @param seconds  the amount of seconds to add, may be negative	     * @return the new time plus the increased seconds	     * @since 1.1	     */	    public TimeOfDay plusSeconds(int seconds) {	        return withFieldAdded(DurationFieldType.seconds(), seconds);	    }	
/**	     * Returns a copy of this time plus the specified number of millis.	     * <p>	     * This time instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * TimeOfDay added = dt.plusMillis(6);	     * TimeOfDay added = dt.plus(Period.millis(6));	     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.millis(), 6);	     * </pre>	     *	     * @param millis  the amount of millis to add, may be negative	     * @return the new time plus the increased millis	     * @since 1.1	     */	    public TimeOfDay plusMillis(int millis) {	        return withFieldAdded(DurationFieldType.millis(), millis);	    }	
/**	     * Returns a copy of this time with the specified period taken away,	     * wrapping to what would be a new day if required.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to subtract complex period instances.	     * Subtracting one field is best achieved using methods	     * like {@link #minusHours(int)}.	     * 	     * @param period  the period to reduce this instant by	     * @return a copy of this instance with the period taken away	     * @throws ArithmeticException if the new time exceeds capacity	     */	    public TimeOfDay minus(ReadablePeriod period) {	        return withPeriodAdded(period, -1);	    }	
/**	     * Returns a copy of this time minus the specified number of hours.	     * <p>	     * This time instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * TimeOfDay subtracted = dt.minusHours(6);	     * TimeOfDay subtracted = dt.minus(Period.hours(6));	     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);	     * </pre>	     *	     * @param hours  the amount of hours to subtract, may be negative	     * @return the new time minus the increased hours	     * @since 1.1	     */	    public TimeOfDay minusHours(int hours) {	        return withFieldAdded(DurationFieldType.hours(), FieldUtils.safeNegate(hours));	    }	
/**	     * Returns a copy of this time minus the specified number of minutes.	     * <p>	     * This time instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * TimeOfDay subtracted = dt.minusMinutes(6);	     * TimeOfDay subtracted = dt.minus(Period.minutes(6));	     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);	     * </pre>	     *	     * @param minutes  the amount of minutes to subtract, may be negative	     * @return the new time minus the increased minutes	     * @since 1.1	     */	    public TimeOfDay minusMinutes(int minutes) {	        return withFieldAdded(DurationFieldType.minutes(), FieldUtils.safeNegate(minutes));	    }	
/**	     * Returns a copy of this time minus the specified number of seconds.	     * <p>	     * This time instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * TimeOfDay subtracted = dt.minusSeconds(6);	     * TimeOfDay subtracted = dt.minus(Period.seconds(6));	     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);	     * </pre>	     *	     * @param seconds  the amount of seconds to subtract, may be negative	     * @return the new time minus the increased seconds	     * @since 1.1	     */	    public TimeOfDay minusSeconds(int seconds) {	        return withFieldAdded(DurationFieldType.seconds(), FieldUtils.safeNegate(seconds));	    }	
/**	     * Returns a copy of this time minus the specified number of millis.	     * <p>	     * This time instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * TimeOfDay subtracted = dt.minusMillis(6);	     * TimeOfDay subtracted = dt.minus(Period.millis(6));	     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);	     * </pre>	     *	     * @param millis  the amount of millis to subtract, may be negative	     * @return the new time minus the increased millis	     * @since 1.1	     */	    public TimeOfDay minusMillis(int millis) {	        return withFieldAdded(DurationFieldType.millis(), FieldUtils.safeNegate(millis));	    }	
/**	     * Gets the property object for the specified type, which contains	     * many useful methods.	     *	     * @param type  the field type to get the property for	     * @return the property object	     * @throws IllegalArgumentException if the field is null or unsupported	     */	    public Property property(DateTimeFieldType type) {	        return new Property(this, indexOfSupported(type));	    }	
/**	     * Converts this object to a LocalTime with the same time and chronology.	     *	     * @return a LocalTime with the same time and chronology	     * @since 1.3	     */	    public LocalTime toLocalTime() {	        return new LocalTime(getHourOfDay(), getMinuteOfHour(),	                getSecondOfMinute(), getMillisOfSecond(), getChronology());	    }	
/**	     * Converts this partial to a full datetime using the default time zone	     * setting the time fields from this instance and the date fields from	     * the current time.	     *	     * @return this date as a datetime with the time as the current time	     */	    public DateTime toDateTimeToday() {	        return toDateTimeToday(null);	    }	
/**	     * Converts this partial to a full datetime using the specified time zone	     * setting the time fields from this instance and the date fields from	     * the current time.	     * <p>	     * This method uses the chronology from this instance plus the time zone	     * specified.	     *	     * @param zone  the zone to use, null means default	     * @return this date as a datetime with the time as the current time	     */	    public DateTime toDateTimeToday(DateTimeZone zone) {	        Chronology chrono = getChronology().withZone(zone);	        long instantMillis = DateTimeUtils.currentTimeMillis();	        long resolved = chrono.set(this, instantMillis);	        return new DateTime(resolved, chrono);	    }	
/**	     * Get the hour of day (0-23) field value.	     *	     * @return the hour of day	     */	    public int getHourOfDay() {	        return getValue(HOUR_OF_DAY);	    }	
/**	     * Get the minute of hour field value.	     *	     * @return the minute of hour	     */	    public int getMinuteOfHour() {	        return getValue(MINUTE_OF_HOUR);	    }	
/**	     * Get the second of minute field value.	     *	     * @return the second of minute	     */	    public int getSecondOfMinute() {	        return getValue(SECOND_OF_MINUTE);	    }	
/**	     * Get the millis of second field value.	     *	     * @return the millis of second	     */	    public int getMillisOfSecond() {	        return getValue(MILLIS_OF_SECOND);	    }	
/**	     * Returns a copy of this time with the hour of day field updated.	     * <p>	     * TimeOfDay is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * hour of day changed.	     *	     * @param hour  the hour of day to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public TimeOfDay withHourOfDay(int hour) {	        int[] newValues = getValues();	        newValues = getChronology().hourOfDay().set(this, HOUR_OF_DAY, newValues, hour);	        return new TimeOfDay(this, newValues);	    }	
/**	     * Returns a copy of this time with the minute of hour field updated.	     * <p>	     * TimeOfDay is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * minute of hour changed.	     *	     * @param minute  the minute of hour to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public TimeOfDay withMinuteOfHour(int minute) {	        int[] newValues = getValues();	        newValues = getChronology().minuteOfHour().set(this, MINUTE_OF_HOUR, newValues, minute);	        return new TimeOfDay(this, newValues);	    }	
/**	     * Returns a copy of this time with the second of minute field updated.	     * <p>	     * TimeOfDay is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * second of minute changed.	     *	     * @param second  the second of minute to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public TimeOfDay withSecondOfMinute(int second) {	        int[] newValues = getValues();	        newValues = getChronology().secondOfMinute().set(this, SECOND_OF_MINUTE, newValues, second);	        return new TimeOfDay(this, newValues);	    }	
/**	     * Returns a copy of this time with the millis of second field updated.	     * <p>	     * TimeOfDay is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * millis of second changed.	     *	     * @param millis  the millis of second to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public TimeOfDay withMillisOfSecond(int millis) {	        int[] newValues = getValues();	        newValues = getChronology().millisOfSecond().set(this, MILLIS_OF_SECOND, newValues, millis);	        return new TimeOfDay(this, newValues);	    }	
/**	     * Get the hour of day field property which provides access to advanced functionality.	     * 	     * @return the hour of day property	     */	    public Property hourOfDay() {	        return new Property(this, HOUR_OF_DAY);	    }	
/**	     * Get the minute of hour field property which provides access to advanced functionality.	     * 	     * @return the minute of hour property	     */	    public Property minuteOfHour() {	        return new Property(this, MINUTE_OF_HOUR);	    }	
/**	     * Get the second of minute field property which provides access to advanced functionality.	     * 	     * @return the second of minute property	     */	    public Property secondOfMinute() {	        return new Property(this, SECOND_OF_MINUTE);	    }	
/**	     * Get the millis of second property which provides access to advanced functionality.	     * 	     * @return the millis of second property	     */	    public Property millisOfSecond() {	        return new Property(this, MILLIS_OF_SECOND);	    }	
/**	     * Output the time in the ISO8601 format THH:mm:ss.SSS.	     * 	     * @return ISO8601 formatted string	     */	    public String toString() {	        return ISODateTimeFormat.tTime().print(this);	    }	
/**	         * Constructs a property.	         * 	         * @param partial  the partial instance	         * @param fieldIndex  the index in the partial	         */	        Property(TimeOfDay partial, int fieldIndex) {	            super();	            iTimeOfDay = partial;	            iFieldIndex = fieldIndex;	        }	
/**	         * Gets the field that this property uses.	         * 	         * @return the field	         */	        public DateTimeField getField() {	            return iTimeOfDay.getField(iFieldIndex);	        }	
/**	         * Gets the partial that this property belongs to.	         * 	         * @return the partial	         */	        protected ReadablePartial getReadablePartial() {	            return iTimeOfDay;	        }	
/**	         * Gets the partial that this property belongs to.	         * 	         * @return the partial	         */	        public TimeOfDay getTimeOfDay() {	            return iTimeOfDay;	        }	
/**	         * Gets the value of this field.	         * 	         * @return the field value	         */	        public int get() {	            return iTimeOfDay.getValue(iFieldIndex);	        }	
/**	         * Adds to the value of this field in a copy of this TimeOfDay,	         * wrapping to what would be the next day if necessary.	         * <p>	         * The value will be added to this field. If the value is too large to be	         * added solely to this field then it will affect larger fields.	         * Smaller fields are unaffected.	         * <p>	         * If the result would be too large, beyond 23:59:59:999, then the	         * calculation wraps to 00:00:00.000. For the alternate strict behaviour	         * with no wrapping see {@link #addNoWrapToCopy(int)}.	         * <p>	         * The TimeOfDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param valueToAdd  the value to add to the field in the copy	         * @return a copy of the TimeOfDay with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public TimeOfDay addToCopy(int valueToAdd) {	            int[] newValues = iTimeOfDay.getValues();	            newValues = getField().addWrapPartial(iTimeOfDay, iFieldIndex, newValues, valueToAdd);	            return new TimeOfDay(iTimeOfDay, newValues);	        }	
/**	         * Adds to the value of this field in a copy of this TimeOfDay,	         * throwing an Exception if the bounds are exceeded.	         * <p>	         * The value will be added to this field. If the value is too large to be	         * added solely to this field then it will affect larger fields.	         * Smaller fields are unaffected.	         * <p>	         * If the result would be too large (beyond 23:59:59:999) or too	         * small (less than 00:00:00.000) then an Execption is thrown.	         * For the alternate behaviour which wraps to the next 'day',	         * see {@link #addToCopy(int)}.	         * <p>	         * The TimeOfDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param valueToAdd  the value to add to the field in the copy	         * @return a copy of the TimeOfDay with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public TimeOfDay addNoWrapToCopy(int valueToAdd) {	            int[] newValues = iTimeOfDay.getValues();	            newValues = getField().add(iTimeOfDay, iFieldIndex, newValues, valueToAdd);	            return new TimeOfDay(iTimeOfDay, newValues);	        }	
/**	         * Adds to the value of this field in a copy of this TimeOfDay wrapping	         * within this field if the maximum value is reached.	         * <p>	         * The value will be added to this field. If the value is too large to be	         * added solely to this field then it wraps within this field.	         * Other fields are unaffected.	         * <p>	         * For example,	         * <code>12:59:37</code> addWrapField one minute returns <code>12:00:37</code>.	         * <p>	         * The TimeOfDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param valueToAdd  the value to add to the field in the copy	         * @return a copy of the TimeOfDay with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public TimeOfDay addWrapFieldToCopy(int valueToAdd) {	            int[] newValues = iTimeOfDay.getValues();	            newValues = getField().addWrapField(iTimeOfDay, iFieldIndex, newValues, valueToAdd);	            return new TimeOfDay(iTimeOfDay, newValues);	        }	
/**	         * Sets this field in a copy of the TimeOfDay.	         * <p>	         * The TimeOfDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param value  the value to set the field in the copy to	         * @return a copy of the TimeOfDay with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public TimeOfDay setCopy(int value) {	            int[] newValues = iTimeOfDay.getValues();	            newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, value);	            return new TimeOfDay(iTimeOfDay, newValues);	        }	
/**	         * Sets this field in a copy of the TimeOfDay to a parsed text value.	         * <p>	         * The TimeOfDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param text  the text value to set	         * @param locale  optional locale to use for selecting a text symbol	         * @return a copy of the TimeOfDay with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public TimeOfDay setCopy(String text, Locale locale) {	            int[] newValues = iTimeOfDay.getValues();	            newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, text, locale);	            return new TimeOfDay(iTimeOfDay, newValues);	        }	
/**	         * Sets this field in a copy of the TimeOfDay to a parsed text value.	         * <p>	         * The TimeOfDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param text  the text value to set	         * @return a copy of the TimeOfDay with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public TimeOfDay setCopy(String text) {	            return setCopy(text, null);	        }	
/**	         * Returns a new TimeOfDay with this field set to the maximum value	         * for this field.	         * <p>	         * The TimeOfDay attached to this property is unchanged by this call.	         *	         * @return a copy of the TimeOfDay with this field set to its maximum	         * @since 1.2	         */	        public TimeOfDay withMaximumValue() {	            return setCopy(getMaximumValue());	        }	
/**	         * Returns a new TimeOfDay with this field set to the minimum value	         * for this field.	         * <p>	         * The TimeOfDay attached to this property is unchanged by this call.	         *	         * @return a copy of the TimeOfDay with this field set to its minimum	         * @since 1.2	         */	        public TimeOfDay withMinimumValue() {	            return setCopy(getMinimumValue());	        }	
/**	     * Parses a {@code DateMidnight} from the specified string.	     * <p>	     * This uses {@link ISODateTimeFormat#dateTimeParser()}.	     * 	     * @param str  the string to parse, not null	     * @since 2.0	     */	    @FromString	    public static DateMidnight parse(String str) {	        return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed());	    }	
/**	     * Parses a {@code DateMidnight} from the specified string using a formatter.	     * 	     * @param str  the string to parse, not null	     * @param formatter  the formatter to use, not null	     * @since 2.0	     */	    public static DateMidnight parse(String str, DateTimeFormatter formatter) {	        return formatter.parseDateTime(str).toDateMidnight();	    }	
/**	     * Constructs an instance set to the current system millisecond time	     * using <code>ISOChronology</code> in the default time zone.	     * The constructed object will have a local time of midnight.	     */	    public DateMidnight() {	        super();	    }	
/**	     * Constructs an instance set to the current system millisecond time	     * using <code>ISOChronology</code> in the specified time zone.	     * The constructed object will have a local time of midnight.	     * <p>	     * If the specified time zone is null, the default zone is used.	     *	     * @param zone  the time zone, null means default zone	     */	    public DateMidnight(DateTimeZone zone) {	        super(zone);	    }	
/**	     * Constructs an instance set to the current system millisecond time	     * using the specified chronology.	     * The constructed object will have a local time of midnight.	     * <p>	     * If the chronology is null, <code>ISOChronology</code>	     * in the default time zone is used.	     *	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public DateMidnight(Chronology chronology) {	        super(chronology);	    }	
/**	     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z	     * using <code>ISOChronology</code> in the default time zone.	     * The constructed object will have a local time of midnight.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     */	    public DateMidnight(long instant) {	        super(instant);	    }	
/**	     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z	     * using <code>ISOChronology</code> in the specified time zone.	     * The constructed object will have a local time of midnight.	     * <p>	     * If the specified time zone is null, the default zone is used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param zone  the time zone, null means default zone	     */	    public DateMidnight(long instant, DateTimeZone zone) {	        super(instant, zone);	    }	
/**	     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z	     * using the specified chronology.	     * The constructed object will have a local time of midnight.	     * <p>	     * If the chronology is null, <code>ISOChronology</code>	     * in the default time zone is used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public DateMidnight(long instant, Chronology chronology) {	        super(instant, chronology);	    }	
/**	     * Constructs an instance from an Object that represents a datetime.	     * The constructed object will have a local time of midnight.	     * <p>	     * If the object implies a chronology (such as GregorianCalendar does),	     * then that chronology will be used. Otherwise, ISO default is used.	     * Thus if a GregorianCalendar is passed in, the chronology used will	     * be GJ, but if a Date is passed in the chronology will be ISO.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.	     *	     * @param instant  the datetime object, null means now	     * @throws IllegalArgumentException if the instant is invalid	     */	    public DateMidnight(Object instant) {	        super(instant, (Chronology) null);	    }	
/**	     * Constructs an instance from an Object that represents a datetime,	     * forcing the time zone to that specified.	     * The constructed object will have a local time of midnight.	     * <p>	     * If the object implies a chronology (such as GregorianCalendar does),	     * then that chronology will be used, but with the time zone adjusted.	     * Otherwise, ISO is used in the specified time zone.	     * If the specified time zone is null, the default zone is used.	     * Thus if a GregorianCalendar is passed in, the chronology used will	     * be GJ, but if a Date is passed in the chronology will be ISO.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.	     *	     * @param instant  the datetime object, null means now	     * @param zone  the time zone, null means default time zone	     * @throws IllegalArgumentException if the instant is invalid	     */	    public DateMidnight(Object instant, DateTimeZone zone) {	        super(instant, zone);	    }	
/**	     * Constructs an instance from an Object that represents a datetime,	     * using the specified chronology.	     * The constructed object will have a local time of midnight.	     * <p>	     * If the chronology is null, ISO in the default time zone is used.	     * Any chronology implied by the object (such as GregorianCalendar does)	     * is ignored.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.	     *	     * @param instant  the datetime object, null means now	     * @param chronology  the chronology, null means ISOChronology in default zone	     * @throws IllegalArgumentException if the instant is invalid	     */	    public DateMidnight(Object instant, Chronology chronology) {	        super(instant, DateTimeUtils.getChronology(chronology));	    }	
/**	     * Constructs an instance from datetime field values	     * using <code>ISOChronology</code> in the default time zone.	     * The constructed object will have a local time of midnight.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     */	    public DateMidnight(int year, int monthOfYear, int dayOfMonth) {	        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0);	    }	
/**	     * Constructs an instance from datetime field values	     * using <code>ISOChronology</code> in the specified time zone.	     * The constructed object will have a local time of midnight.	     * <p>	     * If the specified time zone is null, the default zone is used.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param zone  the time zone, null means default time zone	     */	    public DateMidnight(int year, int monthOfYear, int dayOfMonth, DateTimeZone zone) {	        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, zone);	    }	
/**	     * Constructs an instance from datetime field values	     * using the specified chronology.	     * The constructed object will have a local time of midnight.	     * <p>	     * If the chronology is null, <code>ISOChronology</code>	     * in the default time zone is used.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public DateMidnight(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {	        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, chronology);	    }	
/**	     * Rounds the specified instant to midnight.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round	     * @param chronology  the chronology to use, not null	     * @return the updated instant, rounded to midnight	     */	    protected long checkInstant(long instant, Chronology chronology) {	        return chronology.dayOfMonth().roundFloor(instant);	    }	
/**	     * Returns a copy of this date with a different millisecond instant.	     * The returned object will have a local time of midnight.	     * <p>	     * Only the millis will change, the chronology and time zone are kept.	     * The returned object will be either be a new instance or <code>this</code>.	     *	     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z	     * @return a copy of this instant with different millis	     */	    public DateMidnight withMillis(long newMillis) {	        Chronology chrono = getChronology();	        newMillis = checkInstant(newMillis, chrono);	        return (newMillis == getMillis() ? this : new DateMidnight(newMillis, chrono));	    }	
/**	     * Returns a copy of this date with a different chronology, potentially	     * changing the day in unexpected ways.	     * <p>	     * This method creates a new DateMidnight using the midnight millisecond value	     * and the new chronology. If the same or similar chronology is specified, but	     * with a different time zone, the day may change. This occurs because the new	     * DateMidnight rounds down the millisecond value to get to midnight, and the	     * time zone change may result in a rounding down to a different day.	     * <p>	     * For example, changing time zone from London (+00:00) to Paris (+01:00) will	     * retain the same day, but changing from Paris to London will change the day.	     * (When its midnight in London its the same day in Paris, but when its midnight	     * in Paris its still the previous day in London)	     * <p>	     * To avoid these unusual effects, use {@link #withZoneRetainFields(DateTimeZone)}	     * to change time zones.	     *	     * @param newChronology  the new chronology	     * @return a copy of this instant with a different chronology	     */	    public DateMidnight withChronology(Chronology newChronology) {	        return (newChronology == getChronology() ? this : new DateMidnight(getMillis(), newChronology));	    }	
/**	     * Returns a copy of this date with a different time zone, preserving the day	     * The returned object will have a local time of midnight in the new zone on	     * the same day as the original instant.	     *	     * @param newZone  the new time zone, null means default	     * @return a copy of this instant with a different time zone	     */	    public DateMidnight withZoneRetainFields(DateTimeZone newZone) {	        newZone = DateTimeUtils.getZone(newZone);	        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());	        if (newZone == originalZone) {	            return this;	        }	        	        long millis = originalZone.getMillisKeepLocal(newZone, getMillis());	        return new DateMidnight(millis, getChronology().withZone(newZone));	    }	
/**	     * Returns a copy of this date with the partial set of fields replacing those	     * from this instance.	     * <p>	     * For example, if the partial is a <code>LocalDate</code> then the date fields	     * would be changed in the returned instance.	     * If the partial is null, then <code>this</code> is returned.	     *	     * @param partial  the partial set of fields to apply to this datetime, null ignored	     * @return a copy of this datetime with a different set of fields	     * @throws IllegalArgumentException if any value is invalid	     */	    public DateMidnight withFields(ReadablePartial partial) {	        if (partial == null) {	            return this;	        }	        return withMillis(getChronology().set(partial, getMillis()));	    }	
/**	     * Returns a copy of this date with the specified field set to a new value.	     * <p>	     * For example, if the field type is <code>dayOfMonth</code> then the day of month	     * field would be changed in the returned instance.	     * If the field type is null, then <code>this</code> is returned.	     * <p>	     * These three lines are equivalent:	     * <pre>	     * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);	     * DateTime updated = dt.dayOfMonth().setCopy(6);	     * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);	     * </pre>	     *	     * @param fieldType  the field type to set, not null	     * @param value  the value to set	     * @return a copy of this datetime with the field set	     * @throws IllegalArgumentException if the value is null or invalid	     */	    public DateMidnight withField(DateTimeFieldType fieldType, int value) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field must not be null");	        }	        long instant = fieldType.getField(getChronology()).set(getMillis(), value);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this date with the value of the specified field increased.	     * <p>	     * If the addition is zero or the field is null, then <code>this</code> is returned.	     * <p>	     * These three lines are equivalent:	     * <pre>	     * DateMidnight added = dt.withFieldAdded(DateTimeFieldType.year(), 6);	     * DateMidnight added = dt.plusYears(6);	     * DateMidnight added = dt.year().addToCopy(6);	     * </pre>	     * 	     * @param fieldType  the field type to add to, not null	     * @param amount  the amount to add	     * @return a copy of this datetime with the field updated	     * @throws IllegalArgumentException if the value is null or invalid	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateMidnight withFieldAdded(DurationFieldType fieldType, int amount) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field must not be null");	        }	        if (amount == 0) {	            return this;	        }	        long instant = fieldType.getField(getChronology()).add(getMillis(), amount);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this date with the specified duration added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * 	     * @param durationToAdd  the duration to add to this one	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this datetime with the duration added	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateMidnight withDurationAdded(long durationToAdd, int scalar) {	        if (durationToAdd == 0 || scalar == 0) {	            return this;	        }	        long instant = getChronology().add(getMillis(), durationToAdd, scalar);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this date with the specified duration added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * 	     * @param durationToAdd  the duration to add to this one, null means zero	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this datetime with the duration added	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateMidnight withDurationAdded(ReadableDuration durationToAdd, int scalar) {	        if (durationToAdd == null || scalar == 0) {	            return this;	        }	        return withDurationAdded(durationToAdd.getMillis(), scalar);	    }	
/**	     * Returns a copy of this date with the specified period added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * <p>	     * This method is typically used to add multiple copies of complex	     * period instances. Adding one field is best achieved using methods	     * like {@link #withFieldAdded(DurationFieldType, int)}	     * or {@link #plusYears(int)}.	     * 	     * @param period  the period to add to this one, null means zero	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this datetime with the period added	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateMidnight withPeriodAdded(ReadablePeriod period, int scalar) {	        if (period == null || scalar == 0) {	            return this;	        }	        long instant = getChronology().add(period, getMillis(), scalar);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this date with the specified duration added.	     * <p>	     * If the amount is zero, then <code>this</code> is returned.	     * 	     * @param duration  the duration, in millis, to add to this one	     * @return a copy of this datetime with the duration added	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateMidnight plus(long duration) {	        return withDurationAdded(duration, 1);	    }	
/**	     * Returns a copy of this date with the specified duration added.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * 	     * @param duration  the duration to add to this one, null means zero	     * @return a copy of this datetime with the duration added	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateMidnight plus(ReadableDuration duration) {	        return withDurationAdded(duration, 1);	    }	
/**	     * Returns a copy of this date with the specified period added.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to add complex period instances.	     * Adding one field is best achieved using methods	     * like {@link #plusYears(int)}.	     * 	     * @param period  the duration to add to this one, null means zero	     * @return a copy of this datetime with the period added	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateMidnight plus(ReadablePeriod period) {	        return withPeriodAdded(period, 1);	    }	
/**	     * Returns a copy of this date plus the specified number of years.	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateMidnight added = dt.plusYears(6);	     * DateMidnight added = dt.plus(Period.years(6));	     * DateMidnight added = dt.withFieldAdded(DurationFieldType.years(), 6);	     * </pre>	     *	     * @param years  the amount of years to add, may be negative	     * @return the new datetime plus the increased years	     * @since 1.1	     */	    public DateMidnight plusYears(int years) {	        if (years == 0) {	            return this;	        }	        long instant = getChronology().years().add(getMillis(), years);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this date plus the specified number of months.	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateMidnight added = dt.plusMonths(6);	     * DateMidnight added = dt.plus(Period.months(6));	     * DateMidnight added = dt.withFieldAdded(DurationFieldType.months(), 6);	     * </pre>	     *	     * @param months  the amount of months to add, may be negative	     * @return the new datetime plus the increased months	     * @since 1.1	     */	    public DateMidnight plusMonths(int months) {	        if (months == 0) {	            return this;	        }	        long instant = getChronology().months().add(getMillis(), months);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this date plus the specified number of weeks.	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateMidnight added = dt.plusWeeks(6);	     * DateMidnight added = dt.plus(Period.weeks(6));	     * DateMidnight added = dt.withFieldAdded(DurationFieldType.weeks(), 6);	     * </pre>	     *	     * @param weeks  the amount of weeks to add, may be negative	     * @return the new datetime plus the increased weeks	     * @since 1.1	     */	    public DateMidnight plusWeeks(int weeks) {	        if (weeks == 0) {	            return this;	        }	        long instant = getChronology().weeks().add(getMillis(), weeks);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this date plus the specified number of days.	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateMidnight added = dt.plusDays(6);	     * DateMidnight added = dt.plus(Period.days(6));	     * DateMidnight added = dt.withFieldAdded(DurationFieldType.days(), 6);	     * </pre>	     *	     * @param days  the amount of days to add, may be negative	     * @return the new datetime plus the increased days	     * @since 1.1	     */	    public DateMidnight plusDays(int days) {	        if (days == 0) {	            return this;	        }	        long instant = getChronology().days().add(getMillis(), days);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this date with the specified duration taken away.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * 	     * @param duration  the duration, in millis, to reduce this instant by	     * @return a copy of this datetime with the duration taken away	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateMidnight minus(long duration) {	        return withDurationAdded(duration, -1);	    }	
/**	     * Returns a copy of this date with the specified duration taken away.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * 	     * @param duration  the duration to reduce this instant by	     * @return a copy of this datetime with the duration taken away	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateMidnight minus(ReadableDuration duration) {	        return withDurationAdded(duration, -1);	    }	
/**	     * Returns a copy of this date with the specified period taken away.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to subtract complex period instances.	     * Subtracting one field is best achieved using methods	     * like {@link #minusYears(int)}.	     * 	     * @param period  the period to reduce this instant by	     * @return a copy of this datetime with the period taken away	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateMidnight minus(ReadablePeriod period) {	        return withPeriodAdded(period, -1);	    }	
/**	     * Returns a copy of this date minus the specified number of years.	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime subtracted = dt.minusYears(6);	     * DateTime subtracted = dt.minus(Period.years(6));	     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);	     * </pre>	     *	     * @param years  the amount of years to subtract, may be negative	     * @return the new datetime minus the increased years	     * @since 1.1	     */	    public DateMidnight minusYears(int years) {	        if (years == 0) {	            return this;	        }	        long instant = getChronology().years().subtract(getMillis(), years);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this date minus the specified number of months.	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateMidnight subtracted = dt.minusMonths(6);	     * DateMidnight subtracted = dt.minus(Period.months(6));	     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);	     * </pre>	     *	     * @param months  the amount of months to subtract, may be negative	     * @return the new datetime minus the increased months	     * @since 1.1	     */	    public DateMidnight minusMonths(int months) {	        if (months == 0) {	            return this;	        }	        long instant = getChronology().months().subtract(getMillis(), months);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this date minus the specified number of weeks.	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateMidnight subtracted = dt.minusWeeks(6);	     * DateMidnight subtracted = dt.minus(Period.weeks(6));	     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);	     * </pre>	     *	     * @param weeks  the amount of weeks to subtract, may be negative	     * @return the new datetime minus the increased weeks	     * @since 1.1	     */	    public DateMidnight minusWeeks(int weeks) {	        if (weeks == 0) {	            return this;	        }	        long instant = getChronology().weeks().subtract(getMillis(), weeks);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this date minus the specified number of days.	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateMidnight subtracted = dt.minusDays(6);	     * DateMidnight subtracted = dt.minus(Period.days(6));	     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);	     * </pre>	     *	     * @param days  the amount of days to subtract, may be negative	     * @return the new datetime minus the increased days	     * @since 1.1	     */	    public DateMidnight minusDays(int days) {	        if (days == 0) {	            return this;	        }	        long instant = getChronology().days().subtract(getMillis(), days);	        return withMillis(instant);	    }	
/**	     * Gets the property object for the specified type, which contains many useful methods.	     *	     * @param type  the field type to get the chronology for	     * @return the property object	     * @throws IllegalArgumentException if the field is null or unsupported	     */	    public Property property(DateTimeFieldType type) {	        if (type == null) {	            throw new IllegalArgumentException("The DateTimeFieldType must not be null");	        }	        DateTimeField field = type.getField(getChronology());	        if (field.isSupported() == false) {	            throw new IllegalArgumentException("Field '" + type + "' is not supported");	        }	        return new Property(this, field);	    }	
/**	     * Converts this object to a <code>YearMonthDay</code> using the	     * same date and chronology.	     * 	     * @return a YearMonthDay using the same millis and chronology	     * @deprecated Use LocalDate instead of YearMonthDay	     */	    public YearMonthDay toYearMonthDay() {	        return new YearMonthDay(getMillis(), getChronology());	    }	
/**	     * Converts this object to a <code>LocalDate</code> with the	     * same date and chronology.	     *	     * @return a LocalDate with the same date and chronology	     * @since 1.3	     */	    public LocalDate toLocalDate() {	        return new LocalDate(getMillis(), getChronology());	    }	
/**	     * Converts this object to an <code>Interval</code> encompassing	     * the whole of this day.	     * <p>	     * The interval starts at midnight 00:00 and ends at 00:00 the following day,	     * (which is not included in the interval, as intervals are half-open).	     * 	     * @return an interval over the day	     */	    public Interval toInterval() {	        Chronology chrono = getChronology();	        long start = getMillis();	        long end = DurationFieldType.days().getField(chrono).add(start, 1);	        return new Interval(start, end, chrono);	    }	
/**	     * Returns a copy of this date with the era field updated.	     * <p>	     * DateMidnight is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * era changed.	     *	     * @param era  the era to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateMidnight withEra(int era) {	        return withMillis(getChronology().era().set(getMillis(), era));	    }	
/**	     * Returns a copy of this date with the century of era field updated.	     * <p>	     * DateMidnight is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * century of era changed.	     *	     * @param centuryOfEra  the centurey of era to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateMidnight withCenturyOfEra(int centuryOfEra) {	        return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra));	    }	
/**	     * Returns a copy of this date with the year of era field updated.	     * <p>	     * DateMidnight is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * year of era changed.	     *	     * @param yearOfEra  the year of era to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateMidnight withYearOfEra(int yearOfEra) {	        return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra));	    }	
/**	     * Returns a copy of this date with the year of century field updated.	     * <p>	     * DateMidnight is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * year of century changed.	     *	     * @param yearOfCentury  the year of century to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateMidnight withYearOfCentury(int yearOfCentury) {	        return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury));	    }	
/**	     * Returns a copy of this date with the year field updated.	     * <p>	     * DateMidnight is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * year changed.	     *	     * @param year  the year to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateMidnight withYear(int year) {	        return withMillis(getChronology().year().set(getMillis(), year));	    }	
/**	     * Returns a copy of this date with the weekyear field updated.	     * <p>	     * DateMidnight is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * weekyear changed.	     *	     * @param weekyear  the weekyear to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateMidnight withWeekyear(int weekyear) {	        return withMillis(getChronology().weekyear().set(getMillis(), weekyear));	    }	
/**	     * Returns a copy of this date with the month of year field updated.	     * <p>	     * DateMidnight is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * month of year changed.	     *	     * @param monthOfYear  the month of year to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateMidnight withMonthOfYear(int monthOfYear) {	        return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));	    }	
/**	     * Returns a copy of this date with the week of weekyear field updated.	     * <p>	     * DateMidnight is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * week of weekyear changed.	     *	     * @param weekOfWeekyear  the week of weekyear to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateMidnight withWeekOfWeekyear(int weekOfWeekyear) {	        return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));	    }	
/**	     * Returns a copy of this date with the day of year field updated.	     * <p>	     * DateMidnight is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * day of year changed.	     *	     * @param dayOfYear  the day of year to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateMidnight withDayOfYear(int dayOfYear) {	        return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));	    }	
/**	     * Returns a copy of this date with the day of month field updated.	     * <p>	     * DateMidnight is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * day of month changed.	     *	     * @param dayOfMonth  the day of month to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateMidnight withDayOfMonth(int dayOfMonth) {	        return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));	    }	
/**	     * Returns a copy of this date with the day of week field updated.	     * <p>	     * DateMidnight is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * day of week changed.	     *	     * @param dayOfWeek  the day of week to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateMidnight withDayOfWeek(int dayOfWeek) {	        return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));	    }	
/**	     * Get the era property which provides access to advanced functionality.	     * 	     * @return the era property	     */	    public Property era() {	        return new Property(this, getChronology().era());	    }	
/**	     * Get the century of era property which provides access to advanced functionality.	     * 	     * @return the year of era property	     */	    public Property centuryOfEra() {	        return new Property(this, getChronology().centuryOfEra());	    }	
/**	     * Get the year of century property which provides access to advanced functionality.	     * 	     * @return the year of era property	     */	    public Property yearOfCentury() {	        return new Property(this, getChronology().yearOfCentury());	    }	
/**	     * Get the year of era property which provides access to advanced functionality.	     * 	     * @return the year of era property	     */	    public Property yearOfEra() {	        return new Property(this, getChronology().yearOfEra());	    }	
/**	     * Get the year property which provides access to advanced functionality.	     * 	     * @return the year property	     */	    public Property year() {	        return new Property(this, getChronology().year());	    }	
/**	     * Get the year of a week based year property which provides access to advanced functionality.	     * 	     * @return the year of a week based year property	     */	    public Property weekyear() {	        return new Property(this, getChronology().weekyear());	    }	
/**	     * Get the month of year property which provides access to advanced functionality.	     * 	     * @return the month of year property	     */	    public Property monthOfYear() {	        return new Property(this, getChronology().monthOfYear());	    }	
/**	     * Get the week of a week based year property which provides access to advanced functionality.	     * 	     * @return the week of a week based year property	     */	    public Property weekOfWeekyear() {	        return new Property(this, getChronology().weekOfWeekyear());	    }	
/**	     * Get the day of year property which provides access to advanced functionality.	     * 	     * @return the day of year property	     */	    public Property dayOfYear() {	        return new Property(this, getChronology().dayOfYear());	    }	
/**	     * Get the day of month property which provides access to advanced functionality.	     * 	     * @return the day of month property	     */	    public Property dayOfMonth() {	        return new Property(this, getChronology().dayOfMonth());	    }	
/**	     * Get the day of week property which provides access to advanced functionality.	     * 	     * @return the day of week property	     */	    public Property dayOfWeek() {	        return new Property(this, getChronology().dayOfWeek());	    }	
/**	         * Constructor.	         * 	         * @param instant  the instant to set	         * @param field  the field to use	         */	        Property(DateMidnight instant, DateTimeField field) {	            super();	            iInstant = instant;	            iField = field;	        }	
/**	         * Writes the property in a safe serialization format.	         */	        private void writeObject(ObjectOutputStream oos) throws IOException {	            oos.writeObject(iInstant);	            oos.writeObject(iField.getType());	        }	
/**	         * Reads the property from a safe serialization format.	         */	        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {	            iInstant = (DateMidnight) oos.readObject();	            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();	            iField = type.getField(iInstant.getChronology());	        }	
/**	         * Gets the field being used.	         * 	         * @return the field	         */	        public DateTimeField getField() {	            return iField;	        }	
/**	         * Gets the milliseconds of the datetime that this property is linked to.	         * 	         * @return the milliseconds	         */	        protected long getMillis() {	            return iInstant.getMillis();	        }	
/**	         * Gets the chronology of the datetime that this property is linked to.	         * 	         * @return the chronology	         * @since 1.4	         */	        protected Chronology getChronology() {	            return iInstant.getChronology();	        }	
/**	         * Gets the datetime being used.	         * 	         * @return the datetime	         */	        public DateMidnight getDateMidnight() {	            return iInstant;	        }	
/**	         * Adds to this field in a copy of this DateMidnight.	         * <p>	         * The DateMidnight attached to this property is unchanged by this call.	         * This operation is faster than converting a DateMidnight to a MutableDateTime	         * and back again when setting one field. When setting multiple fields,	         * it is generally quicker to make the conversion to MutableDateTime.	         * 	         * @param value  the value to add to the field in the copy	         * @return a copy of the DateMidnight with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public DateMidnight addToCopy(int value) {	            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));	        }	
/**	         * Adds to this field in a copy of this DateMidnight.	         * <p>	         * The DateMidnight attached to this property is unchanged by this call.	         * This operation is faster than converting a DateMidnight to a MutableDateTime	         * and back again when setting one field. When setting multiple fields,	         * it is generally quicker to make the conversion to MutableDateTime.	         * 	         * @param value  the value to add to the field in the copy	         * @return a copy of the DateMidnight with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public DateMidnight addToCopy(long value) {	            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));	        }	
/**	         * Adds to this field, possibly wrapped, in a copy of this DateMidnight.	         * A wrapped operation only changes this field.	         * Thus 31st January addWrapField one day goes to the 1st January.	         * <p>	         * The DateMidnight attached to this property is unchanged by this call.	         * This operation is faster than converting a DateMidnight to a MutableDateTime	         * and back again when setting one field. When setting multiple fields,	         * it is generally quicker to make the conversion to MutableDateTime.	         * 	         * @param value  the value to add to the field in the copy	         * @return a copy of the DateMidnight with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public DateMidnight addWrapFieldToCopy(int value) {	            return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value));	        }	
/**	         * Sets this field in a copy of the DateMidnight.	         * <p>	         * The DateMidnight attached to this property is unchanged by this call.	         * This operation is faster than converting a DateMidnight to a MutableDateTime	         * and back again when setting one field. When setting multiple fields,	         * it is generally quicker to make the conversion to MutableDateTime.	         * 	         * @param value  the value to set the field in the copy to	         * @return a copy of the DateMidnight with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public DateMidnight setCopy(int value) {	            return iInstant.withMillis(iField.set(iInstant.getMillis(), value));	        }	
/**	         * Sets this field in a copy of the DateMidnight to a parsed text value.	         * <p>	         * The DateMidnight attached to this property is unchanged by this call.	         * This operation is faster than converting a DateMidnight to a MutableDateTime	         * and back again when setting one field. When setting multiple fields,	         * it is generally quicker to make the conversion to MutableDateTime.	         * 	         * @param text  the text value to set	         * @param locale  optional locale to use for selecting a text symbol	         * @return a copy of the DateMidnight with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public DateMidnight setCopy(String text, Locale locale) {	            return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale));	        }	
/**	         * Sets this field in a copy of the DateMidnight to a parsed text value.	         * <p>	         * The DateMidnight attached to this property is unchanged by this call.	         * This operation is faster than converting a DateMidnight to a MutableDateTime	         * and back again when setting one field. When setting multiple fields,	         * it is generally quicker to make the conversion to MutableDateTime.	         * 	         * @param text  the text value to set	         * @return a copy of the DateMidnight with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public DateMidnight setCopy(String text) {	            return setCopy(text, null);	        }	
/**	         * Returns a new DateMidnight with this field set to the maximum value	         * for this field.	         * <p>	         * This operation is useful for obtaining a DateTime on the last day	         * of the month, as month lengths vary.	         * <pre>	         * DateMidnight lastDayOfMonth = dt.dayOfMonth().withMaximumValue();	         * </pre>	         * <p>	         * The DateMidnight attached to this property is unchanged by this call.	         *	         * @return a copy of the DateMidnight with this field set to its maximum	         * @since 1.2	         */	        public DateMidnight withMaximumValue() {	            return setCopy(getMaximumValue());	        }	
/**	         * Returns a new DateMidnight with this field set to the minimum value	         * for this field.	         * <p>	         * The DateMidnight attached to this property is unchanged by this call.	         *	         * @return a copy of the DateMidnight with this field set to its minimum	         * @since 1.2	         */	        public DateMidnight withMinimumValue() {	            return setCopy(getMinimumValue());	        }	
/**	         * Rounds to the lowest whole unit of this field on a copy of this DateMidnight.	         *	         * @return a copy of the DateMidnight with the field value changed	         */	        public DateMidnight roundFloorCopy() {	            return iInstant.withMillis(iField.roundFloor(iInstant.getMillis()));	        }	
/**	         * Rounds to the highest whole unit of this field on a copy of this DateMidnight.	         *	         * @return a copy of the DateMidnight with the field value changed	         */	        public DateMidnight roundCeilingCopy() {	            return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis()));	        }	
/**	         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,	         * favoring the floor if halfway.	         *	         * @return a copy of the DateMidnight with the field value changed	         */	        public DateMidnight roundHalfFloorCopy() {	            return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis()));	        }	
/**	         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,	         * favoring the ceiling if halfway.	         *	         * @return a copy of the DateMidnight with the field value changed	         */	        public DateMidnight roundHalfCeilingCopy() {	            return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis()));	        }	
/**	         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight.	         * If halfway, the ceiling is favored over the floor only if it makes this field's value even.	         *	         * @return a copy of the DateMidnight with the field value changed	         */	        public DateMidnight roundHalfEvenCopy() {	            return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));	        }	
/**	     * Obtains an instance of <code>Months</code> that may be cached.	     * <code>Months</code> is immutable, so instances can be cached and shared.	     * This factory method provides access to shared instances.	     *	     * @param months  the number of months to obtain an instance for	     * @return the instance of Months	     */	    public static Months months(int months) {	        switch (months) {	            case 0:	                return ZERO;	            case 1:	                return ONE;	            case 2:	                return TWO;	            case 3:	                return THREE;	            case 4:	                return FOUR;	            case 5:	                return FIVE;	            case 6:	                return SIX;	            case 7:	                return SEVEN;	            case 8:	                return EIGHT;	            case 9:	                return NINE;	            case 10:	                return TEN;	            case 11:	                return ELEVEN;	            case 12:	                return TWELVE;	            case Integer.MAX_VALUE:	                return MAX_VALUE;	            case Integer.MIN_VALUE:	                return MIN_VALUE;	            default:	                return new Months(months);	        }	    }	
/**	     * Creates a <code>Months</code> representing the number of whole months	     * between the two specified datetimes. This method corectly handles	     * any daylight savings time changes that may occur during the interval.	     *	     * @param start  the start instant, must not be null	     * @param end  the end instant, must not be null	     * @return the period in months	     * @throws IllegalArgumentException if the instants are null or invalid	     */	    public static Months monthsBetween(ReadableInstant start, ReadableInstant end) {	        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.months());	        return Months.months(amount);	    }	
/**	     * Creates a <code>Months</code> representing the number of whole months	     * between the two specified partial datetimes.	     * <p>	     * The two partials must contain the same fields, for example you can specify	     * two <code>LocalDate</code> objects.	     *	     * @param start  the start partial date, must not be null	     * @param end  the end partial date, must not be null	     * @return the period in months	     * @throws IllegalArgumentException if the partials are null or invalid	     */	    public static Months monthsBetween(ReadablePartial start, ReadablePartial end) {	        if (start instanceof LocalDate && end instanceof LocalDate)   {	            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());	            int months = chrono.months().getDifference(	                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());	            return Months.months(months);	        }	        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);	        return Months.months(amount);	    }	
/**	     * Creates a <code>Months</code> representing the number of whole months	     * in the specified interval. This method corectly handles any daylight	     * savings time changes that may occur during the interval.	     *	     * @param interval  the interval to extract months from, null returns zero	     * @return the period in months	     * @throws IllegalArgumentException if the partials are null or invalid	     */	    public static Months monthsIn(ReadableInterval interval) {	        if (interval == null)   {	            return Months.ZERO;	        }	        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.months());	        return Months.months(amount);	    }	
/**	     * Creates a new <code>Months</code> by parsing a string in the ISO8601 format 'PnM'.	     * <p>	     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the	     * months component may be non-zero. If any other component is non-zero, an exception	     * will be thrown.	     *	     * @param periodStr  the period string, null returns zero	     * @return the period in months	     * @throws IllegalArgumentException if the string format is invalid	     */	    @FromString	    public static Months parseMonths(String periodStr) {	        if (periodStr == null) {	            return Months.ZERO;	        }	        Period p = PARSER.parsePeriod(periodStr);	        return Months.months(p.getMonths());	    }	
/**	     * Creates a new instance representing a number of months.	     * You should consider using the factory method {@link #months(int)}	     * instead of the constructor.	     *	     * @param months  the number of months to represent	     */	    private Months(int months) {	        super(months);	    }	
/**	     * Resolves singletons.	     * 	     * @return the singleton instance	     */	    private Object readResolve() {	        return Months.months(getValue());	    }	
/**	     * Gets the duration field type, which is <code>months</code>.	     *	     * @return the period type	     */	    public DurationFieldType getFieldType() {	        return DurationFieldType.months();	    }	
/**	     * Gets the period type, which is <code>months</code>.	     *	     * @return the period type	     */	    public PeriodType getPeriodType() {	        return PeriodType.months();	    }	
/**	     * Gets the number of months that this period represents.	     *	     * @return the number of months in the period	     */	    public int getMonths() {	        return getValue();	    }	
/**	     * Returns a new instance with the specified number of months added.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param months  the amount of months to add, may be negative	     * @return the new period plus the specified number of months	     * @throws ArithmeticException if the result overflows an int	     */	    public Months plus(int months) {	        if (months == 0) {	            return this;	        }	        return Months.months(FieldUtils.safeAdd(getValue(), months));	    }	
/**	     * Returns a new instance with the specified number of months added.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param months  the amount of months to add, may be negative, null means zero	     * @return the new period plus the specified number of months	     * @throws ArithmeticException if the result overflows an int	     */	    public Months plus(Months months) {	        if (months == null) {	            return this;	        }	        return plus(months.getValue());	    }	
/**	     * Returns a new instance with the specified number of months taken away.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param months  the amount of months to take away, may be negative	     * @return the new period minus the specified number of months	     * @throws ArithmeticException if the result overflows an int	     */	    public Months minus(int months) {	        return plus(FieldUtils.safeNegate(months));	    }	
/**	     * Returns a new instance with the specified number of months taken away.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param months  the amount of months to take away, may be negative, null means zero	     * @return the new period minus the specified number of months	     * @throws ArithmeticException if the result overflows an int	     */	    public Months minus(Months months) {	        if (months == null) {	            return this;	        }	        return minus(months.getValue());	    }	
/**	     * Returns a new instance with the months multiplied by the specified scalar.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param scalar  the amount to multiply by, may be negative	     * @return the new period multiplied by the specified scalar	     * @throws ArithmeticException if the result overflows an int	     */	    public Months multipliedBy(int scalar) {	        return Months.months(FieldUtils.safeMultiply(getValue(), scalar));	    }	
/**	     * Returns a new instance with the months divided by the specified divisor.	     * The calculation uses integer division, thus 3 divided by 2 is 1.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param divisor  the amount to divide by, may be negative	     * @return the new period divided by the specified divisor	     * @throws ArithmeticException if the divisor is zero	     */	    public Months dividedBy(int divisor) {	        if (divisor == 1) {	            return this;	        }	        return Months.months(getValue() / divisor);	    }	
/**	     * Returns a new instance with the months value negated.	     *	     * @return the new period with a negated value	     * @throws ArithmeticException if the result overflows an int	     */	    public Months negated() {	        return Months.months(FieldUtils.safeNegate(getValue()));	    }	
/**	     * Is this months instance greater than the specified number of months.	     *	     * @param other  the other period, null means zero	     * @return true if this months instance is greater than the specified one	     */	    public boolean isGreaterThan(Months other) {	        if (other == null) {	            return getValue() > 0;	        }	        return getValue() > other.getValue();	    }	
/**	     * Is this months instance less than the specified number of months.	     *	     * @param other  the other period, null means zero	     * @return true if this months instance is less than the specified one	     */	    public boolean isLessThan(Months other) {	        if (other == null) {	            return getValue() < 0;	        }	        return getValue() < other.getValue();	    }	
/**	     * Gets this instance as a String in the ISO8601 duration format.	     * <p>	     * For example, "P4M" represents 4 months.	     *	     * @return the value as an ISO8601 string	     */	    @ToString	    public String toString() {	        return "P" + String.valueOf(getValue()) + "M";	    }	
/**	     * Obtains an instance of <code>Seconds</code> that may be cached.	     * <code>Seconds</code> is immutable, so instances can be cached and shared.	     * This factory method provides access to shared instances.	     *	     * @param seconds  the number of seconds to obtain an instance for	     * @return the instance of Seconds	     */	    public static Seconds seconds(int seconds) {	        switch (seconds) {	            case 0:	                return ZERO;	            case 1:	                return ONE;	            case 2:	                return TWO;	            case 3:	                return THREE;	            case Integer.MAX_VALUE:	                return MAX_VALUE;	            case Integer.MIN_VALUE:	                return MIN_VALUE;	            default:	                return new Seconds(seconds);	        }	    }	
/**	     * Creates a <code>Seconds</code> representing the number of whole seconds	     * between the two specified datetimes.	     *	     * @param start  the start instant, must not be null	     * @param end  the end instant, must not be null	     * @return the period in seconds	     * @throws IllegalArgumentException if the instants are null or invalid	     */	    public static Seconds secondsBetween(ReadableInstant start, ReadableInstant end) {	        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.seconds());	        return Seconds.seconds(amount);	    }	
/**	     * Creates a <code>Seconds</code> representing the number of whole seconds	     * between the two specified partial datetimes.	     * <p>	     * The two partials must contain the same fields, for example you can specify	     * two <code>LocalTime</code> objects.	     *	     * @param start  the start partial date, must not be null	     * @param end  the end partial date, must not be null	     * @return the period in seconds	     * @throws IllegalArgumentException if the partials are null or invalid	     */	    public static Seconds secondsBetween(ReadablePartial start, ReadablePartial end) {	        if (start instanceof LocalTime && end instanceof LocalTime)   {	            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());	            int seconds = chrono.seconds().getDifference(	                    ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());	            return Seconds.seconds(seconds);	        }	        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);	        return Seconds.seconds(amount);	    }	
/**	     * Creates a <code>Seconds</code> representing the number of whole seconds	     * in the specified interval.	     *	     * @param interval  the interval to extract seconds from, null returns zero	     * @return the period in seconds	     * @throws IllegalArgumentException if the partials are null or invalid	     */	    public static Seconds secondsIn(ReadableInterval interval) {	        if (interval == null)   {	            return Seconds.ZERO;	        }	        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.seconds());	        return Seconds.seconds(amount);	    }	
/**	     * Creates a new <code>Seconds</code> representing the number of complete	     * standard length seconds in the specified period.	     * <p>	     * This factory method converts all fields from the period to hours using standardised	     * durations for each field. Only those fields which have a precise duration in	     * the ISO UTC chronology can be converted.	     * <ul>	     * <li>One week consists of 7 seconds.	     * <li>One day consists of 24 hours.	     * <li>One hour consists of 60 minutes.	     * <li>One minute consists of 60 seconds.	     * <li>One second consists of 1000 milliseconds.	     * </ul>	     * Months and Years are imprecise and periods containing these values cannot be converted.	     *	     * @param period  the period to get the number of hours from, null returns zero	     * @return the period in seconds	     * @throws IllegalArgumentException if the period contains imprecise duration values	     */	    public static Seconds standardSecondsIn(ReadablePeriod period) {	        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_SECOND);	        return Seconds.seconds(amount);	    }	
/**	     * Creates a new <code>Seconds</code> by parsing a string in the ISO8601 format 'PTnS'.	     * <p>	     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the	     * seconds component may be non-zero. If any other component is non-zero, an exception	     * will be thrown.	     *	     * @param periodStr  the period string, null returns zero	     * @return the period in seconds	     * @throws IllegalArgumentException if the string format is invalid	     */	    @FromString	    public static Seconds parseSeconds(String periodStr) {	        if (periodStr == null) {	            return Seconds.ZERO;	        }	        Period p = PARSER.parsePeriod(periodStr);	        return Seconds.seconds(p.getSeconds());	    }	
/**	     * Creates a new instance representing a number of seconds.	     * You should consider using the factory method {@link #seconds(int)}	     * instead of the constructor.	     *	     * @param seconds  the number of seconds to represent	     */	    private Seconds(int seconds) {	        super(seconds);	    }	
/**	     * Resolves singletons.	     * 	     * @return the singleton instance	     */	    private Object readResolve() {	        return Seconds.seconds(getValue());	    }	
/**	     * Gets the duration field type, which is <code>seconds</code>.	     *	     * @return the period type	     */	    public DurationFieldType getFieldType() {	        return DurationFieldType.seconds();	    }	
/**	     * Gets the period type, which is <code>seconds</code>.	     *	     * @return the period type	     */	    public PeriodType getPeriodType() {	        return PeriodType.seconds();	    }	
/**	     * Converts this period in seconds to a period in weeks assuming a	     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all weeks are 7 days	     * long, all days are 24 hours long, all hours are 60 minutes long and	     * all minutes are 60 seconds long.	     * This is not true when daylight savings time is considered, and may also	     * not be true for some unusual chronologies. However, it is included as it	     * is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of whole weeks for this number of seconds	     */	    public Weeks toStandardWeeks() {	        return Weeks.weeks(getValue() / DateTimeConstants.SECONDS_PER_WEEK);	    }	
/**	     * Converts this period in seconds to a period in days assuming a	     * 24 hour day, 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all days are 24 hours	     * long, all hours are 60 minutes long and all minutes are 60 seconds long.	     * This is not true when daylight savings is considered and may also not	     * be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of days for this number of seconds	     */	    public Days toStandardDays() {	        return Days.days(getValue() / DateTimeConstants.SECONDS_PER_DAY);	    }	
/**	     * Converts this period in seconds to a period in hours assuming a	     * 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all hours are	     * 60 minutes long and all minutes are 60 seconds long.	     * This may not be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of hours for this number of seconds	     */	    public Hours toStandardHours() {	        return Hours.hours(getValue() / DateTimeConstants.SECONDS_PER_HOUR);	    }	
/**	     * Converts this period in seconds to a period in minutes assuming a	     * 60 second minute.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all minutes are	     * 60 seconds long.	     * This may not be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of minutes for this number of seconds	     */	    public Minutes toStandardMinutes() {	        return Minutes.minutes(getValue() / DateTimeConstants.SECONDS_PER_MINUTE);	    }	
/**	     * Converts this period in seconds to a duration in milliseconds assuming a	     * 24 hour day, 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert from a period to a duration.	     * However to achieve this it makes the assumption that all seconds are 24 hours	     * long, all hours are 60 minutes and all minutes are 60 seconds.	     * This is not true when daylight savings time is considered, and may also	     * not be true for some unusual chronologies. However, it is included as it	     * is a useful operation for many applications and business rules.	     * 	     * @return a duration equivalent to this number of seconds	     */	    public Duration toStandardDuration() {	        long seconds = getValue();  // assign to a long	        return new Duration(seconds * DateTimeConstants.MILLIS_PER_SECOND);	    }	
/**	     * Gets the number of seconds that this period represents.	     *	     * @return the number of seconds in the period	     */	    public int getSeconds() {	        return getValue();	    }	
/**	     * Returns a new instance with the specified number of seconds added.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param seconds  the amount of seconds to add, may be negative	     * @return the new period plus the specified number of seconds	     * @throws ArithmeticException if the result overflows an int	     */	    public Seconds plus(int seconds) {	        if (seconds == 0) {	            return this;	        }	        return Seconds.seconds(FieldUtils.safeAdd(getValue(), seconds));	    }	
/**	     * Returns a new instance with the specified number of seconds added.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param seconds  the amount of seconds to add, may be negative, null means zero	     * @return the new period plus the specified number of seconds	     * @throws ArithmeticException if the result overflows an int	     */	    public Seconds plus(Seconds seconds) {	        if (seconds == null) {	            return this;	        }	        return plus(seconds.getValue());	    }	
/**	     * Returns a new instance with the specified number of seconds taken away.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param seconds  the amount of seconds to take away, may be negative	     * @return the new period minus the specified number of seconds	     * @throws ArithmeticException if the result overflows an int	     */	    public Seconds minus(int seconds) {	        return plus(FieldUtils.safeNegate(seconds));	    }	
/**	     * Returns a new instance with the specified number of seconds taken away.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param seconds  the amount of seconds to take away, may be negative, null means zero	     * @return the new period minus the specified number of seconds	     * @throws ArithmeticException if the result overflows an int	     */	    public Seconds minus(Seconds seconds) {	        if (seconds == null) {	            return this;	        }	        return minus(seconds.getValue());	    }	
/**	     * Returns a new instance with the seconds multiplied by the specified scalar.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param scalar  the amount to multiply by, may be negative	     * @return the new period multiplied by the specified scalar	     * @throws ArithmeticException if the result overflows an int	     */	    public Seconds multipliedBy(int scalar) {	        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), scalar));	    }	
/**	     * Returns a new instance with the seconds divided by the specified divisor.	     * The calculation uses integer division, thus 3 divided by 2 is 1.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param divisor  the amount to divide by, may be negative	     * @return the new period divided by the specified divisor	     * @throws ArithmeticException if the divisor is zero	     */	    public Seconds dividedBy(int divisor) {	        if (divisor == 1) {	            return this;	        }	        return Seconds.seconds(getValue() / divisor);	    }	
/**	     * Returns a new instance with the seconds value negated.	     *	     * @return the new period with a negated value	     * @throws ArithmeticException if the result overflows an int	     */	    public Seconds negated() {	        return Seconds.seconds(FieldUtils.safeNegate(getValue()));	    }	
/**	     * Is this seconds instance greater than the specified number of seconds.	     *	     * @param other  the other period, null means zero	     * @return true if this seconds instance is greater than the specified one	     */	    public boolean isGreaterThan(Seconds other) {	        if (other == null) {	            return getValue() > 0;	        }	        return getValue() > other.getValue();	    }	
/**	     * Is this seconds instance less than the specified number of seconds.	     *	     * @param other  the other period, null means zero	     * @return true if this seconds instance is less than the specified one	     */	    public boolean isLessThan(Seconds other) {	        if (other == null) {	            return getValue() < 0;	        }	        return getValue() < other.getValue();	    }	
/**	     * Gets this instance as a String in the ISO8601 duration format.	     * <p>	     * For example, "PT4S" represents 4 seconds.	     *	     * @return the value as an ISO8601 string	     */	    @ToString	    public String toString() {	        return "PT" + String.valueOf(getValue()) + "S";	    }	
/**	     * Obtains an instance of <code>Hours</code> that may be cached.	     * <code>Hours</code> is immutable, so instances can be cached and shared.	     * This factory method provides access to shared instances.	     *	     * @param hours  the number of hours to obtain an instance for	     * @return the instance of Hours	     */	    public static Hours hours(int hours) {	        switch (hours) {	            case 0:	                return ZERO;	            case 1:	                return ONE;	            case 2:	                return TWO;	            case 3:	                return THREE;	            case 4:	                return FOUR;	            case 5:	                return FIVE;	            case 6:	                return SIX;	            case 7:	                return SEVEN;	            case 8:	                return EIGHT;	            case Integer.MAX_VALUE:	                return MAX_VALUE;	            case Integer.MIN_VALUE:	                return MIN_VALUE;	            default:	                return new Hours(hours);	        }	    }	
/**	     * Creates a <code>Hours</code> representing the number of whole hours	     * between the two specified datetimes.	     *	     * @param start  the start instant, must not be null	     * @param end  the end instant, must not be null	     * @return the period in hours	     * @throws IllegalArgumentException if the instants are null or invalid	     */	    public static Hours hoursBetween(ReadableInstant start, ReadableInstant end) {	        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.hours());	        return Hours.hours(amount);	    }	
/**	     * Creates a <code>Hours</code> representing the number of whole hours	     * between the two specified partial datetimes.	     * <p>	     * The two partials must contain the same fields, for example you can specify	     * two <code>LocalTime</code> objects.	     *	     * @param start  the start partial date, must not be null	     * @param end  the end partial date, must not be null	     * @return the period in hours	     * @throws IllegalArgumentException if the partials are null or invalid	     */	    public static Hours hoursBetween(ReadablePartial start, ReadablePartial end) {	        if (start instanceof LocalTime && end instanceof LocalTime)   {	            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());	            int hours = chrono.hours().getDifference(	                    ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());	            return Hours.hours(hours);	        }	        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);	        return Hours.hours(amount);	    }	
/**	     * Creates a <code>Hours</code> representing the number of whole hours	     * in the specified interval.	     *	     * @param interval  the interval to extract hours from, null returns zero	     * @return the period in hours	     * @throws IllegalArgumentException if the partials are null or invalid	     */	    public static Hours hoursIn(ReadableInterval interval) {	        if (interval == null)   {	            return Hours.ZERO;	        }	        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.hours());	        return Hours.hours(amount);	    }	
/**	     * Creates a new <code>Hours</code> representing the number of complete	     * standard length hours in the specified period.	     * <p>	     * This factory method converts all fields from the period to hours using standardised	     * durations for each field. Only those fields which have a precise duration in	     * the ISO UTC chronology can be converted.	     * <ul>	     * <li>One week consists of 7 days.	     * <li>One day consists of 24 hours.	     * <li>One hour consists of 60 minutes.	     * <li>One minute consists of 60 seconds.	     * <li>One second consists of 1000 milliseconds.	     * </ul>	     * Months and Years are imprecise and periods containing these values cannot be converted.	     *	     * @param period  the period to get the number of hours from, null returns zero	     * @return the period in hours	     * @throws IllegalArgumentException if the period contains imprecise duration values	     */	    public static Hours standardHoursIn(ReadablePeriod period) {	        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_HOUR);	        return Hours.hours(amount);	    }	
/**	     * Creates a new <code>Hours</code> by parsing a string in the ISO8601 format 'PTnH'.	     * <p>	     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the	     * hours component may be non-zero. If any other component is non-zero, an exception	     * will be thrown.	     *	     * @param periodStr  the period string, null returns zero	     * @return the period in hours	     * @throws IllegalArgumentException if the string format is invalid	     */	    @FromString	    public static Hours parseHours(String periodStr) {	        if (periodStr == null) {	            return Hours.ZERO;	        }	        Period p = PARSER.parsePeriod(periodStr);	        return Hours.hours(p.getHours());	    }	
/**	     * Creates a new instance representing a number of hours.	     * You should consider using the factory method {@link #hours(int)}	     * instead of the constructor.	     *	     * @param hours  the number of hours to represent	     */	    private Hours(int hours) {	        super(hours);	    }	
/**	     * Resolves singletons.	     * 	     * @return the singleton instance	     */	    private Object readResolve() {	        return Hours.hours(getValue());	    }	
/**	     * Gets the duration field type, which is <code>hours</code>.	     *	     * @return the period type	     */	    public DurationFieldType getFieldType() {	        return DurationFieldType.hours();	    }	
/**	     * Gets the period type, which is <code>hours</code>.	     *	     * @return the period type	     */	    public PeriodType getPeriodType() {	        return PeriodType.hours();	    }	
/**	     * Converts this period in hours to a period in weeks assuming a	     * 7 day week and 24 hour day.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all weeks are 7 days	     * long and all days are 24 hours long.	     * This is not true when daylight savings time is considered, and may also	     * not be true for some unusual chronologies. However, it is included as it	     * is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of whole weeks for this number of hours	     */	    public Weeks toStandardWeeks() {	        return Weeks.weeks(getValue() / DateTimeConstants.HOURS_PER_WEEK);	    }	
/**	     * Converts this period in hours to a period in days assuming a	     * 24 hour day.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all days are 24 hours long.	     * This is not true when daylight savings time is considered, and may also	     * not be true for some unusual chronologies. However, it is included as it	     * is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of whole days for this number of hours	     */	    public Days toStandardDays() {	        return Days.days(getValue() / DateTimeConstants.HOURS_PER_DAY);	    }	
/**	     * Converts this period in hours to a period in minutes assuming a	     * 60 minute hour.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all hours are 60 minutes long.	     * This may not be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of minutes for this number of hours	     * @throws ArithmeticException if the number of minutes is too large to be represented	     */	    public Minutes toStandardMinutes() {	        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_HOUR));	    }	
/**	     * Converts this period in hours to a period in seconds assuming a	     * 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all hours are	     * 60 minutes long and all minutes are 60 seconds long.	     * This may not be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of seconds for this number of hours	     * @throws ArithmeticException if the number of seconds is too large to be represented	     */	    public Seconds toStandardSeconds() {	        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_HOUR));	    }	
/**	     * Converts this period in hours to a duration in milliseconds assuming a	     * 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert from a period to a duration.	     * However to achieve this it makes the assumption that all hours are	     * 60 minutes and all minutes are 60 seconds. This might not be true for an	     * unusual chronology, for example one that takes leap seconds into account.	     * However, the method is included as it is a useful operation for many	     * applications and business rules.	     *	     * @return a duration equivalent to this number of hours	     */	    public Duration toStandardDuration() {	        long hours = getValue();  // assign to a long	        return new Duration(hours * DateTimeConstants.MILLIS_PER_HOUR);	    }	
/**	     * Gets the number of hours that this period represents.	     *	     * @return the number of hours in the period	     */	    public int getHours() {	        return getValue();	    }	
/**	     * Returns a new instance with the specified number of hours added.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param hours  the amount of hours to add, may be negative	     * @return the new period plus the specified number of hours	     * @throws ArithmeticException if the result overflows an int	     */	    public Hours plus(int hours) {	        if (hours == 0) {	            return this;	        }	        return Hours.hours(FieldUtils.safeAdd(getValue(), hours));	    }	
/**	     * Returns a new instance with the specified number of hours added.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param hours  the amount of hours to add, may be negative, null means zero	     * @return the new period plus the specified number of hours	     * @throws ArithmeticException if the result overflows an int	     */	    public Hours plus(Hours hours) {	        if (hours == null) {	            return this;	        }	        return plus(hours.getValue());	    }	
/**	     * Returns a new instance with the specified number of hours taken away.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param hours  the amount of hours to take away, may be negative	     * @return the new period minus the specified number of hours	     * @throws ArithmeticException if the result overflows an int	     */	    public Hours minus(int hours) {	        return plus(FieldUtils.safeNegate(hours));	    }	
/**	     * Returns a new instance with the specified number of hours taken away.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param hours  the amount of hours to take away, may be negative, null means zero	     * @return the new period minus the specified number of hours	     * @throws ArithmeticException if the result overflows an int	     */	    public Hours minus(Hours hours) {	        if (hours == null) {	            return this;	        }	        return minus(hours.getValue());	    }	
/**	     * Returns a new instance with the hours multiplied by the specified scalar.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param scalar  the amount to multiply by, may be negative	     * @return the new period multiplied by the specified scalar	     * @throws ArithmeticException if the result overflows an int	     */	    public Hours multipliedBy(int scalar) {	        return Hours.hours(FieldUtils.safeMultiply(getValue(), scalar));	    }	
/**	     * Returns a new instance with the hours divided by the specified divisor.	     * The calculation uses integer division, thus 3 divided by 2 is 1.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param divisor  the amount to divide by, may be negative	     * @return the new period divided by the specified divisor	     * @throws ArithmeticException if the divisor is zero	     */	    public Hours dividedBy(int divisor) {	        if (divisor == 1) {	            return this;	        }	        return Hours.hours(getValue() / divisor);	    }	
/**	     * Returns a new instance with the hours value negated.	     *	     * @return the new period with a negated value	     * @throws ArithmeticException if the result overflows an int	     */	    public Hours negated() {	        return Hours.hours(FieldUtils.safeNegate(getValue()));	    }	
/**	     * Is this hours instance greater than the specified number of hours.	     *	     * @param other  the other period, null means zero	     * @return true if this hours instance is greater than the specified one	     */	    public boolean isGreaterThan(Hours other) {	        if (other == null) {	            return getValue() > 0;	        }	        return getValue() > other.getValue();	    }	
/**	     * Is this hours instance less than the specified number of hours.	     *	     * @param other  the other period, null means zero	     * @return true if this hours instance is less than the specified one	     */	    public boolean isLessThan(Hours other) {	        if (other == null) {	            return getValue() < 0;	        }	        return getValue() < other.getValue();	    }	
/**	     * Gets this instance as a String in the ISO8601 duration format.	     * <p>	     * For example, "PT4H" represents 4 hours.	     *	     * @return the value as an ISO8601 string	     */	    @ToString	    public String toString() {	        return "PT" + String.valueOf(getValue()) + "H";	    }	
/**	     * Returns a DateTimeComparator the compares the entire date time value.	     * 	     * @return a comparator over all fields	     */	    public static DateTimeComparator getInstance() {	        return ALL_INSTANCE;	    }	
/**	     * Returns a DateTimeComparator with a lower limit only. Fields of a	     * magnitude less than the lower limit are excluded from comparisons.	     *	     * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit	     * @return a comparator over all fields above the lower limit	     */	    public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit) {	        return getInstance(lowerLimit, null);	    }	
/**	     * Returns a DateTimeComparator with a lower and upper limit. Fields of a	     * magnitude less than the lower limit are excluded from comparisons.	     * Fields of a magnitude greater than or equal to the upper limit are also	     * excluded from comparisons. Either limit may be specified as null, which	     * indicates an unbounded limit.	     *	     * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit	     * @param upperLimit  exclusive upper limit for fields to be compared, null means no limit	     * @return a comparator over all fields between the limits	     */	    public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) {	        if (lowerLimit == null && upperLimit == null) {	            return ALL_INSTANCE;	        }	        if (lowerLimit == DateTimeFieldType.dayOfYear() && upperLimit == null) {	            return DATE_INSTANCE;	        }	        if (lowerLimit == null && upperLimit == DateTimeFieldType.dayOfYear()) {	            return TIME_INSTANCE;	        }	        return new DateTimeComparator(lowerLimit, upperLimit);	    }	
/**	     * Returns a comparator that only considers date fields.	     * Time of day is ignored.	     * 	     * @return a comparator over all date fields	     */	    public static DateTimeComparator getDateOnlyInstance() {	        return DATE_INSTANCE;	    }	
/**	     * Returns a comparator that only considers time fields.	     * Date is ignored.	     * 	     * @return a comparator over all time fields	     */	    public static DateTimeComparator getTimeOnlyInstance() {	        return TIME_INSTANCE;	    }	
/**	     * Restricted constructor.	     * 	     * @param lowerLimit  the lower field limit, null means no limit	     * @param upperLimit  the upper field limit, null means no limit	     */	    protected DateTimeComparator(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) {	        super();	        iLowerLimit = lowerLimit;	        iUpperLimit = upperLimit;	    }	
/**	     * Gets the field type that represents the lower limit of comparison.	     * 	     * @return the field type, null if no upper limit	     */	    public DateTimeFieldType getLowerLimit() {	        return iLowerLimit;	    }	
/**	     * Gets the field type that represents the upper limit of comparison.	     * 	     * @return the field type, null if no upper limit	     */	    public DateTimeFieldType getUpperLimit() {	        return iUpperLimit;	    }	
/**	     * Compare two objects against only the range of date time fields as	     * specified in the constructor.	     * 	     * @param lhsObj  the first object,	     *      logically on the left of a &lt; comparison, null means now	     * @param rhsObj  the second object,	     *      logically on the right of a &lt; comparison, null means now	     * @return zero if order does not matter,	     *      negative value if lhsObj &lt; rhsObj, positive value otherwise.	     * @throws IllegalArgumentException if either argument is not supported	     */	    public int compare(Object lhsObj, Object rhsObj) {	        InstantConverter conv = ConverterManager.getInstance().getInstantConverter(lhsObj);	        Chronology lhsChrono = conv.getChronology(lhsObj, (Chronology) null);	        long lhsMillis = conv.getInstantMillis(lhsObj, lhsChrono);	        	        conv = ConverterManager.getInstance().getInstantConverter(rhsObj);	        Chronology rhsChrono = conv.getChronology(rhsObj, (Chronology) null);	        long rhsMillis = conv.getInstantMillis(rhsObj, rhsChrono);		        if (iLowerLimit != null) {	            lhsMillis = iLowerLimit.getField(lhsChrono).roundFloor(lhsMillis);	            rhsMillis = iLowerLimit.getField(rhsChrono).roundFloor(rhsMillis);	        }		        if (iUpperLimit != null) {	            lhsMillis = iUpperLimit.getField(lhsChrono).remainder(lhsMillis);	            rhsMillis = iUpperLimit.getField(rhsChrono).remainder(rhsMillis);	        }		        if (lhsMillis < rhsMillis) {	            return -1;	        } else if (lhsMillis > rhsMillis) {	            return 1;	        } else {	            return 0;	        }	    }	
/**	     * Support serialization singletons.	     * 	     * @return the resolved singleton instance	     */	    private Object readResolve() {	        return getInstance(iLowerLimit, iUpperLimit);	    }	
/**	     * Compares this comparator to another.	     * 	     * @param object  the object to compare to	     * @return true if equal	     */	    public boolean equals(Object object) {	        if (object instanceof DateTimeComparator) {	            DateTimeComparator other = (DateTimeComparator) object;	            return (iLowerLimit == other.getLowerLimit() ||	                    (iLowerLimit != null && iLowerLimit.equals(other.getLowerLimit()))) &&	                   (iUpperLimit == other.getUpperLimit() ||	                    (iUpperLimit != null && iUpperLimit.equals(other.getUpperLimit())));	        }	        return false;	    }	
/**	     * Gets a suitable hashcode.	     * 	     * @return the hashcode	     */	    public int hashCode() {	        return (iLowerLimit == null ? 0 : iLowerLimit.hashCode()) +	               (123 * (iUpperLimit == null ? 0 : iUpperLimit.hashCode()));	    }	
/**	     * Gets a debugging string.	     * 	     * @return a debugging string	     */	    public String toString() {	        if (iLowerLimit == iUpperLimit) {	            return "DateTimeComparator["	                + (iLowerLimit == null ? "" : iLowerLimit.getName())	                + "]";	        } else {	            return "DateTimeComparator["	                + (iLowerLimit == null ? "" : iLowerLimit.getName())	                + "-"	                + (iUpperLimit == null ? "" : iUpperLimit.getName())	                + "]";	        }	    }	
/**	     * Obtains an instance of <code>Minutes</code> that may be cached.	     * <code>Minutes</code> is immutable, so instances can be cached and shared.	     * This factory method provides access to shared instances.	     *	     * @param minutes  the number of minutes to obtain an instance for	     * @return the instance of Minutes	     */	    public static Minutes minutes(int minutes) {	        switch (minutes) {	            case 0:	                return ZERO;	            case 1:	                return ONE;	            case 2:	                return TWO;	            case 3:	                return THREE;	            case Integer.MAX_VALUE:	                return MAX_VALUE;	            case Integer.MIN_VALUE:	                return MIN_VALUE;	            default:	                return new Minutes(minutes);	        }	    }	
/**	     * Creates a <code>Minutes</code> representing the number of whole minutes	     * between the two specified datetimes.	     *	     * @param start  the start instant, must not be null	     * @param end  the end instant, must not be null	     * @return the period in minutes	     * @throws IllegalArgumentException if the instants are null or invalid	     */	    public static Minutes minutesBetween(ReadableInstant start, ReadableInstant end) {	        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.minutes());	        return Minutes.minutes(amount);	    }	
/**	     * Creates a <code>Minutes</code> representing the number of whole minutes	     * between the two specified partial datetimes.	     * <p>	     * The two partials must contain the same fields, for example you can specify	     * two <code>LocalTime</code> objects.	     *	     * @param start  the start partial date, must not be null	     * @param end  the end partial date, must not be null	     * @return the period in minutes	     * @throws IllegalArgumentException if the partials are null or invalid	     */	    public static Minutes minutesBetween(ReadablePartial start, ReadablePartial end) {	        if (start instanceof LocalTime && end instanceof LocalTime)   {	            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());	            int minutes = chrono.minutes().getDifference(	                    ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());	            return Minutes.minutes(minutes);	        }	        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);	        return Minutes.minutes(amount);	    }	
/**	     * Creates a <code>Minutes</code> representing the number of whole minutes	     * in the specified interval.	     *	     * @param interval  the interval to extract minutes from, null returns zero	     * @return the period in minutes	     * @throws IllegalArgumentException if the partials are null or invalid	     */	    public static Minutes minutesIn(ReadableInterval interval) {	        if (interval == null)   {	            return Minutes.ZERO;	        }	        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.minutes());	        return Minutes.minutes(amount);	    }	
/**	     * Creates a new <code>Minutes</code> representing the number of complete	     * standard length minutes in the specified period.	     * <p>	     * This factory method converts all fields from the period to minutes using standardised	     * durations for each field. Only those fields which have a precise duration in	     * the ISO UTC chronology can be converted.	     * <ul>	     * <li>One week consists of 7 days.	     * <li>One day consists of 24 hours.	     * <li>One hour consists of 60 minutes.	     * <li>One minute consists of 60 seconds.	     * <li>One second consists of 1000 milliseconds.	     * </ul>	     * Months and Years are imprecise and periods containing these values cannot be converted.	     *	     * @param period  the period to get the number of minutes from, null returns zero	     * @return the period in minutes	     * @throws IllegalArgumentException if the period contains imprecise duration values	     */	    public static Minutes standardMinutesIn(ReadablePeriod period) {	        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_MINUTE);	        return Minutes.minutes(amount);	    }	
/**	     * Creates a new <code>Minutes</code> by parsing a string in the ISO8601 format 'PTnM'.	     * <p>	     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the	     * minutes component may be non-zero. If any other component is non-zero, an exception	     * will be thrown.	     *	     * @param periodStr  the period string, null returns zero	     * @return the period in minutes	     * @throws IllegalArgumentException if the string format is invalid	     */	    @FromString	    public static Minutes parseMinutes(String periodStr) {	        if (periodStr == null) {	            return Minutes.ZERO;	        }	        Period p = PARSER.parsePeriod(periodStr);	        return Minutes.minutes(p.getMinutes());	    }	
/**	     * Creates a new instance representing a number of minutes.	     * You should consider using the factory method {@link #minutes(int)}	     * instead of the constructor.	     *	     * @param minutes  the number of minutes to represent	     */	    private Minutes(int minutes) {	        super(minutes);	    }	
/**	     * Resolves singletons.	     * 	     * @return the singleton instance	     */	    private Object readResolve() {	        return Minutes.minutes(getValue());	    }	
/**	     * Gets the duration field type, which is <code>minutes</code>.	     *	     * @return the period type	     */	    public DurationFieldType getFieldType() {	        return DurationFieldType.minutes();	    }	
/**	     * Gets the period type, which is <code>minutes</code>.	     *	     * @return the period type	     */	    public PeriodType getPeriodType() {	        return PeriodType.minutes();	    }	
/**	     * Converts this period in minutes to a period in weeks assuming a	     * 7 days week, 24 hour day and 60 minute hour.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all weeks are	     * 7 days long, all days are 24 hours long and all hours are 60 minutes long.	     * This is not true when daylight savings is considered and may also not	     * be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of whole weeks for this number of minutes	     */	    public Weeks toStandardWeeks() {	        return Weeks.weeks(getValue() / DateTimeConstants.MINUTES_PER_WEEK);	    }	
/**	     * Converts this period in minutes to a period in days assuming a	     * 24 hour day and 60 minute hour.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all days are	     * 24 hours long and all hours are 60 minutes long.	     * This is not true when daylight savings is considered and may also not	     * be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of whole days for this number of minutes	     */	    public Days toStandardDays() {	        return Days.days(getValue() / DateTimeConstants.MINUTES_PER_DAY);	    }	
/**	     * Converts this period in minutes to a period in hours assuming a	     * 60 minute hour.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all hours are	     * 60 minutes long.	     * This may not be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of hours for this number of minutes	     */	    public Hours toStandardHours() {	        return Hours.hours(getValue() / DateTimeConstants.MINUTES_PER_HOUR);	    }	
/**	     * Converts this period in minutes to a period in seconds assuming a	     * 60 second minute.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all minutes are	     * 60 seconds long.	     * This may not be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of seconds for this number of minutes	     * @throws ArithmeticException if the number of seconds is too large to be represented	     */	    public Seconds toStandardSeconds() {	        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_MINUTE));	    }	
/**	     * Converts this period in minutes to a duration in milliseconds assuming a	     * 60 second minute.	     * <p>	     * This method allows you to convert from a period to a duration.	     * However to achieve this it makes the assumption that all minutes are	     * 60 seconds long. This might not be true for an unusual chronology,	     * for example one that takes leap seconds into account.	     * However, the method is included as it is a useful operation for many	     * applications and business rules.	     *	     * @return a duration equivalent to this number of minutes	     */	    public Duration toStandardDuration() {	        long minutes = getValue();  // assign to a long	        return new Duration(minutes * DateTimeConstants.MILLIS_PER_MINUTE);	    }	
/**	     * Gets the number of minutes that this period represents.	     *	     * @return the number of minutes in the period	     */	    public int getMinutes() {	        return getValue();	    }	
/**	     * Returns a new instance with the specified number of minutes added.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param minutes  the amount of minutes to add, may be negative	     * @return the new period plus the specified number of minutes	     * @throws ArithmeticException if the result overflows an int	     */	    public Minutes plus(int minutes) {	        if (minutes == 0) {	            return this;	        }	        return Minutes.minutes(FieldUtils.safeAdd(getValue(), minutes));	    }	
/**	     * Returns a new instance with the specified number of minutes added.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param minutes  the amount of minutes to add, may be negative, null means zero	     * @return the new period plus the specified number of minutes	     * @throws ArithmeticException if the result overflows an int	     */	    public Minutes plus(Minutes minutes) {	        if (minutes == null) {	            return this;	        }	        return plus(minutes.getValue());	    }	
/**	     * Returns a new instance with the specified number of minutes taken away.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param minutes  the amount of minutes to take away, may be negative	     * @return the new period minus the specified number of minutes	     * @throws ArithmeticException if the result overflows an int	     */	    public Minutes minus(int minutes) {	        return plus(FieldUtils.safeNegate(minutes));	    }	
/**	     * Returns a new instance with the specified number of minutes taken away.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param minutes  the amount of minutes to take away, may be negative, null means zero	     * @return the new period minus the specified number of minutes	     * @throws ArithmeticException if the result overflows an int	     */	    public Minutes minus(Minutes minutes) {	        if (minutes == null) {	            return this;	        }	        return minus(minutes.getValue());	    }	
/**	     * Returns a new instance with the minutes multiplied by the specified scalar.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param scalar  the amount to multiply by, may be negative	     * @return the new period multiplied by the specified scalar	     * @throws ArithmeticException if the result overflows an int	     */	    public Minutes multipliedBy(int scalar) {	        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), scalar));	    }	
/**	     * Returns a new instance with the minutes divided by the specified divisor.	     * The calculation uses integer division, thus 3 divided by 2 is 1.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param divisor  the amount to divide by, may be negative	     * @return the new period divided by the specified divisor	     * @throws ArithmeticException if the divisor is zero	     */	    public Minutes dividedBy(int divisor) {	        if (divisor == 1) {	            return this;	        }	        return Minutes.minutes(getValue() / divisor);	    }	
/**	     * Returns a new instance with the minutes value negated.	     *	     * @return the new period with a negated value	     * @throws ArithmeticException if the result overflows an int	     */	    public Minutes negated() {	        return Minutes.minutes(FieldUtils.safeNegate(getValue()));	    }	
/**	     * Is this minutes instance greater than the specified number of minutes.	     *	     * @param other  the other period, null means zero	     * @return true if this minutes instance is greater than the specified one	     */	    public boolean isGreaterThan(Minutes other) {	        if (other == null) {	            return getValue() > 0;	        }	        return getValue() > other.getValue();	    }	
/**	     * Is this minutes instance less than the specified number of minutes.	     *	     * @param other  the other period, null means zero	     * @return true if this minutes instance is less than the specified one	     */	    public boolean isLessThan(Minutes other) {	        if (other == null) {	            return getValue() < 0;	        }	        return getValue() < other.getValue();	    }	
/**	     * Gets this instance as a String in the ISO8601 duration format.	     * <p>	     * For example, "PT4M" represents 4 minutes.	     *	     * @return the value as an ISO8601 string	     */	    @ToString	    public String toString() {	        return "PT" + String.valueOf(getValue()) + "M";	    }	
/**	     * Parses a {@code MutableDateTime} from the specified string.	     * <p>	     * This uses {@link ISODateTimeFormat#dateTimeParser()}.	     * 	     * @param str  the string to parse, not null	     * @since 2.0	     */	    @FromString	    public static MutableDateTime parse(String str) {	        return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed());	    }	
/**	     * Parses a {@code MutableDateTime} from the specified string using a formatter.	     * 	     * @param str  the string to parse, not null	     * @param formatter  the formatter to use, not null	     * @since 2.0	     */	    public static MutableDateTime parse(String str, DateTimeFormatter formatter) {	        return formatter.parseDateTime(str).toMutableDateTime();	    }	
/**	     * Constructs an instance set to the current system millisecond time	     * using <code>ISOChronology</code> in the default time zone.	     */	    public MutableDateTime() {	        super();	    }	
/**	     * Constructs an instance set to the current system millisecond time	     * using <code>ISOChronology</code> in the specified time zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     *	     * @param zone  the time zone, null means default zone	     */	    public MutableDateTime(DateTimeZone zone) {	        super(zone);	    }	
/**	     * Constructs an instance set to the current system millisecond time	     * using the specified chronology.	     * <p>	     * If the chronology is null, <code>ISOChronology</code>	     * in the default time zone is used.	     *	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public MutableDateTime(Chronology chronology) {	        super(chronology);	    }	
/**	     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z	     * using <code>ISOChronology</code> in the default time zone.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     */	    public MutableDateTime(long instant) {	        super(instant);	    }	
/**	     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z	     * using <code>ISOChronology</code> in the specified time zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param zone  the time zone, null means default zone	     */	    public MutableDateTime(long instant, DateTimeZone zone) {	        super(instant, zone);	    }	
/**	     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z	     * using the specified chronology.	     * <p>	     * If the chronology is null, <code>ISOChronology</code>	     * in the default time zone is used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public MutableDateTime(long instant, Chronology chronology) {	        super(instant, chronology);	    }	
/**	     * Constructs an instance from an Object that represents a datetime.	     * <p>	     * If the object implies a chronology (such as GregorianCalendar does),	     * then that chronology will be used. Otherwise, ISO default is used.	     * Thus if a GregorianCalendar is passed in, the chronology used will	     * be GJ, but if a Date is passed in the chronology will be ISO.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     *	     * @param instant  the datetime object, null means now	     * @throws IllegalArgumentException if the instant is invalid	     */	    public MutableDateTime(Object instant) {	        super(instant, (Chronology) null);	    }	
/**	     * Constructs an instance from an Object that represents a datetime,	     * forcing the time zone to that specified.	     * <p>	     * If the object implies a chronology (such as GregorianCalendar does),	     * then that chronology will be used, but with the time zone adjusted.	     * Otherwise, ISO is used in the specified time zone.	     * If the specified time zone is null, the default zone is used.	     * Thus if a GregorianCalendar is passed in, the chronology used will	     * be GJ, but if a Date is passed in the chronology will be ISO.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     *	     * @param instant  the datetime object, null means now	     * @param zone  the time zone, null means default time zone	     * @throws IllegalArgumentException if the instant is invalid	     */	    public MutableDateTime(Object instant, DateTimeZone zone) {	        super(instant, zone);	    }	
/**	     * Constructs an instance from an Object that represents a datetime,	     * using the specified chronology.	     * <p>	     * If the chronology is null, ISO in the default time zone is used.	     * Any chronology implied by the object (such as GregorianCalendar does)	     * is ignored.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     *	     * @param instant  the datetime object, null means now	     * @param chronology  the chronology, null means ISOChronology in default zone	     * @throws IllegalArgumentException if the instant is invalid	     */	    public MutableDateTime(Object instant, Chronology chronology) {	        super(instant, DateTimeUtils.getChronology(chronology));	    }	
/**	     * Constructs an instance from datetime field values	     * using <code>ISOChronology</code> in the default time zone.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     */	    public MutableDateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute,	            int millisOfSecond) {	        super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	    }	
/**	     * Constructs an instance from datetime field values	     * using <code>ISOChronology</code> in the specified time zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     * @param zone  the time zone, null means default time zone	     */	    public MutableDateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute,	            int millisOfSecond,	            DateTimeZone zone) {	        super(year, monthOfYear, dayOfMonth,	              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);	    }	
/**	     * Constructs an instance from datetime field values	     * using the specified chronology.	     * <p>	     * If the chronology is null, <code>ISOChronology</code>	     * in the default time zone is used.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public MutableDateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute,	            int millisOfSecond,	            Chronology chronology) {	        super(year, monthOfYear, dayOfMonth,	              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);	    }	
/**	     * Gets the field used for rounding this instant, returning null if rounding	     * is not enabled.	     * 	     * @return the rounding field	     */	    public DateTimeField getRoundingField() {	        return iRoundingField;	    }	
/**	     * Gets the rounding mode for this instant, returning ROUND_NONE if rounding	     * is not enabled.	     * 	     * @return the rounding mode constant	     */	    public int getRoundingMode() {	        return iRoundingMode;	    }	
/**	     * Sets the status of rounding to use the specified field and ROUND_FLOOR mode.	     * A null field will disable rounding.	     * Once set, the instant is then rounded using the new field and mode.	     * <p>	     * Enabling rounding will cause all subsequent calls to {@link #setMillis(long)}	     * to be rounded. This can be used to control the precision of the instant,	     * for example by setting a rounding field of minuteOfDay, the seconds and	     * milliseconds will always be zero.	     *	     * @param field rounding field or null to disable	     */	    public void setRounding(DateTimeField field) {	        setRounding(field, MutableDateTime.ROUND_FLOOR);	    }	
/**	     * Sets the status of rounding to use the specified field and mode.	     * A null field or mode of ROUND_NONE will disable rounding.	     * Once set, the instant is then rounded using the new field and mode.	     * <p>	     * Enabling rounding will cause all subsequent calls to {@link #setMillis(long)}	     * to be rounded. This can be used to control the precision of the instant,	     * for example by setting a rounding field of minuteOfDay, the seconds and	     * milliseconds will always be zero.	     *	     * @param field  rounding field or null to disable	     * @param mode  rounding mode or ROUND_NONE to disable	     * @throws IllegalArgumentException if mode is unknown, no exception if field is null	     */	    public void setRounding(DateTimeField field, int mode) {	        if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) {	            throw new IllegalArgumentException("Illegal rounding mode: " + mode);	        }	        iRoundingField = (mode == ROUND_NONE ? null : field);	        iRoundingMode = (field == null ? ROUND_NONE : mode);	        setMillis(getMillis());	    }	
/**	     * Set the milliseconds of the datetime.	     * <p>	     * All changes to the millisecond field occurs via this method.	     *	     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the	     * datetime to	     */	    public void setMillis(long instant) {	        switch (iRoundingMode) {	            case ROUND_NONE:	                break;	            case ROUND_FLOOR:	                instant = iRoundingField.roundFloor(instant);	                break;	            case ROUND_CEILING:	                instant = iRoundingField.roundCeiling(instant);	                break;	            case ROUND_HALF_FLOOR:	                instant = iRoundingField.roundHalfFloor(instant);	                break;	            case ROUND_HALF_CEILING:	                instant = iRoundingField.roundHalfCeiling(instant);	                break;	            case ROUND_HALF_EVEN:	                instant = iRoundingField.roundHalfEven(instant);	                break;	        }		        super.setMillis(instant);	    }	
/**	     * Sets the millisecond instant of this instant from another.	     * <p>	     * This method does not change the chronology of this instant, just the	     * millisecond instant.	     * 	     * @param instant  the instant to use, null means now	     */	    public void setMillis(ReadableInstant instant) {	        long instantMillis = DateTimeUtils.getInstantMillis(instant);	        setMillis(instantMillis);  // set via this class not super	    }	
/**	     * Add an amount of time to the datetime.	     * 	     * @param duration  the millis to add	     * @throws ArithmeticException if the result exceeds the capacity of the instant	     */	    public void add(long duration) {	        setMillis(FieldUtils.safeAdd(getMillis(), duration));  // set via this class not super	    }	
/**	     * Adds a duration to this instant.	     * <p>	     * This will typically change the value of most fields.	     *	     * @param duration  the duration to add, null means add zero	     * @throws ArithmeticException if the result exceeds the capacity of the instant	     */	    public void add(ReadableDuration duration) {	        add(duration, 1);	    }	
/**	     * Adds a duration to this instant specifying how many times to add.	     * <p>	     * This will typically change the value of most fields.	     *	     * @param duration  the duration to add, null means add zero	     * @param scalar  direction and amount to add, which may be negative	     * @throws ArithmeticException if the result exceeds the capacity of the instant	     */	    public void add(ReadableDuration duration, int scalar) {	        if (duration != null) {	            add(FieldUtils.safeMultiply(duration.getMillis(), scalar));	        }	    }	
/**	     * Adds a period to this instant.	     * <p>	     * This will typically change the value of most fields.	     *	     * @param period  the period to add, null means add zero	     * @throws ArithmeticException if the result exceeds the capacity of the instant	     */	    public void add(ReadablePeriod period) {	        add(period, 1);	    }	
/**	     * Adds a period to this instant specifying how many times to add.	     * <p>	     * This will typically change the value of most fields.	     *	     * @param period  the period to add, null means add zero	     * @param scalar  direction and amount to add, which may be negative	     * @throws ArithmeticException if the result exceeds the capacity of the instant	     */	    public void add(ReadablePeriod period, int scalar) {	        if (period != null) {	            setMillis(getChronology().add(period, getMillis(), scalar));  // set via this class not super	        }	    }	
/**	     * Set the chronology of the datetime.	     * <p>	     * All changes to the chronology occur via this method.	     * 	     * @param chronology  the chronology to use, null means ISOChronology in default zone	     */	    public void setChronology(Chronology chronology) {	        super.setChronology(chronology);	    }	
/**	     * Sets the time zone of the datetime, changing the chronology and field values.	     * <p>	     * Changing the zone using this method retains the millisecond instant.	     * The millisecond instant is adjusted in the new zone to compensate.	     * 	     * chronology. Setting the time zone does not affect the millisecond value	     * of this instant.	     * <p>	     * If the chronology already has this time zone, no change occurs.	     *	     * @param newZone  the time zone to use, null means default zone	     * @see #setZoneRetainFields	     */	    public void setZone(DateTimeZone newZone) {	        newZone = DateTimeUtils.getZone(newZone);	        Chronology chrono = getChronology();	        if (chrono.getZone() != newZone) {	            setChronology(chrono.withZone(newZone));  // set via this class not super	        }	    }	
/**	     * Sets the time zone of the datetime, changing the chronology and millisecond.	     * <p>	     * Changing the zone using this method retains the field values.	     * The millisecond instant is adjusted in the new zone to compensate.	     * <p>	     * If the chronology already has this time zone, no change occurs.	     *	     * @param newZone  the time zone to use, null means default zone	     * @see #setZone	     */	    public void setZoneRetainFields(DateTimeZone newZone) {	        newZone = DateTimeUtils.getZone(newZone);	        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());	        if (newZone == originalZone) {	            return;	        }	        	        long millis = originalZone.getMillisKeepLocal(newZone, getMillis());	        setChronology(getChronology().withZone(newZone));  // set via this class not super	        setMillis(millis);	    }	
/**	     * Sets the value of one of the fields of the instant, such as hourOfDay.	     *	     * @param type  a field type, usually obtained from DateTimeFieldType, not null	     * @param value  the value to set the field to	     * @throws IllegalArgumentException if the value is null or invalid	     */	    public void set(DateTimeFieldType type, int value) {	        if (type == null) {	            throw new IllegalArgumentException("Field must not be null");	        }	        setMillis(type.getField(getChronology()).set(getMillis(), value));	    }	
/**	     * Adds to the instant specifying the duration and multiple to add.	     *	     * @param type  a field type, usually obtained from DateTimeFieldType, not null	     * @param amount  the amount to add of this duration	     * @throws IllegalArgumentException if the value is null or invalid	     * @throws ArithmeticException if the result exceeds the capacity of the instant	     */	    public void add(DurationFieldType type, int amount) {	        if (type == null) {	            throw new IllegalArgumentException("Field must not be null");	        }	        setMillis(type.getField(getChronology()).add(getMillis(), amount));	    }	
/**	     * Set the year to the specified value.	     *	     * @param year  the year	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setYear(final int year) {	        setMillis(getChronology().year().set(getMillis(), year));	    }	
/**	     * Add a number of years to the date.	     *	     * @param years  the years to add	     * @throws IllegalArgumentException if the value is invalid	     */	    public void addYears(final int years) {	        setMillis(getChronology().years().add(getMillis(), years));	    }	
/**	     * Set the weekyear to the specified value.	     *	     * @param weekyear  the weekyear	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setWeekyear(final int weekyear) {	        setMillis(getChronology().weekyear().set(getMillis(), weekyear));	    }	
/**	     * Add a number of weekyears to the date.	     *	     * @param weekyears  the weekyears to add	     * @throws IllegalArgumentException if the value is invalid	     */	    public void addWeekyears(final int weekyears) {	        setMillis(getChronology().weekyears().add(getMillis(), weekyears));	    }	
/**	     * Set the month of the year to the specified value.	     *	     * @param monthOfYear  the month of the year	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setMonthOfYear(final int monthOfYear) {	        setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));	    }	
/**	     * Add a number of months to the date.	     *	     * @param months  the months to add	     * @throws IllegalArgumentException if the value is invalid	     */	    public void addMonths(final int months) {	        setMillis(getChronology().months().add(getMillis(), months));	    }	
/**	     * Set the week of weekyear to the specified value.	     *	     * @param weekOfWeekyear the week of the weekyear	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setWeekOfWeekyear(final int weekOfWeekyear) {	        setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));	    }	
/**	     * Add a number of weeks to the date.	     *	     * @param weeks  the weeks to add	     * @throws IllegalArgumentException if the value is invalid	     */	    public void addWeeks(final int weeks) {	        setMillis(getChronology().weeks().add(getMillis(), weeks));	    }	
/**	     * Set the day of year to the specified value.	     *	     * @param dayOfYear the day of the year	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setDayOfYear(final int dayOfYear) {	        setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));	    }	
/**	     * Set the day of the month to the specified value.	     *	     * @param dayOfMonth  the day of the month	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setDayOfMonth(final int dayOfMonth) {	        setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));	    }	
/**	     * Set the day of week to the specified value.	     *	     * @param dayOfWeek  the day of the week	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setDayOfWeek(final int dayOfWeek) {	        setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));	    }	
/**	     * Add a number of days to the date.	     *	     * @param days  the days to add	     * @throws IllegalArgumentException if the value is invalid	     */	    public void addDays(final int days) {	        setMillis(getChronology().days().add(getMillis(), days));	    }	
/**	     * Set the hour of the day to the specified value.	     *	     * @param hourOfDay  the hour of day	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setHourOfDay(final int hourOfDay) {	        setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay));	    }	
/**	     * Add a number of hours to the date.	     *	     * @param hours  the hours to add	     * @throws IllegalArgumentException if the value is invalid	     */	    public void addHours(final int hours) {	        setMillis(getChronology().hours().add(getMillis(), hours));	    }	
/**	     * Set the minute of the day to the specified value.	     *	     * @param minuteOfDay  the minute of day	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setMinuteOfDay(final int minuteOfDay) {	        setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay));	    }	
/**	     * Set the minute of the hour to the specified value.	     *	     * @param minuteOfHour  the minute of hour	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setMinuteOfHour(final int minuteOfHour) {	        setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour));	    }	
/**	     * Add a number of minutes to the date.	     *	     * @param minutes  the minutes to add	     * @throws IllegalArgumentException if the value is invalid	     */	    public void addMinutes(final int minutes) {	        setMillis(getChronology().minutes().add(getMillis(), minutes));	    }	
/**	     * Set the second of the day to the specified value.	     *	     * @param secondOfDay  the second of day	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setSecondOfDay(final int secondOfDay) {	        setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay));	    }	
/**	     * Set the second of the minute to the specified value.	     *	     * @param secondOfMinute  the second of minute	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setSecondOfMinute(final int secondOfMinute) {	        setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute));	    }	
/**	     * Add a number of seconds to the date.	     *	     * @param seconds  the seconds to add	     * @throws IllegalArgumentException if the value is invalid	     */	    public void addSeconds(final int seconds) {	        setMillis(getChronology().seconds().add(getMillis(), seconds));	    }	
/**	     * Set the millis of the day to the specified value.	     *	     * @param millisOfDay  the millis of day	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setMillisOfDay(final int millisOfDay) {	        setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));	    }	
/**	     * Set the millis of the second to the specified value.	     *	     * @param millisOfSecond  the millis of second	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setMillisOfSecond(final int millisOfSecond) {	        setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond));	    }	
/**	     * Add a number of milliseconds to the date. The implementation of this	     * method differs from the {@link #add(long)} method in that a	     * DateTimeField performs the addition.	     *	     * @param millis  the milliseconds to add	     * @throws IllegalArgumentException if the value is invalid	     */	    public void addMillis(final int millis) {	        setMillis(getChronology().millis().add(getMillis(), millis));	    }	
/**	     * Set the date from milliseconds.	     * The time part of this object will be unaffected.	     *	     * @param instant  an instant to copy the date from, time part ignored	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setDate(final long instant) {	        setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay()));	    }	
/**	     * Set the date from another instant.	     * The time part of this object will be unaffected.	     *	     * @param instant  an instant to copy the date from, time part ignored	     * @throws IllegalArgumentException if the object is invalid	     */	    public void setDate(final ReadableInstant instant) {	        long instantMillis = DateTimeUtils.getInstantMillis(instant);	        Chronology instantChrono = DateTimeUtils.getInstantChronology(instant);	        DateTimeZone zone = instantChrono.getZone();	        if (zone != null) {	            instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis);	        }	        setDate(instantMillis);	    }	
/**	     * Set the date from fields.	     * The time part of this object will be unaffected.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setDate(	            final int year,	            final int monthOfYear,	            final int dayOfMonth) {	        Chronology c = getChronology();	        long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);	        setDate(instantMidnight);	    }	
/**	     * Set the time from milliseconds.	     * The date part of this object will be unaffected.	     *	     * @param millis  an instant to copy the time from, date part ignored	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setTime(final long millis) {	        int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis);	        setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));	    }	
/**	     * Set the time from another instant.	     * The date part of this object will be unaffected.	     *	     * @param instant  an instant to copy the time from, date part ignored	     * @throws IllegalArgumentException if the object is invalid	     */	    public void setTime(final ReadableInstant instant) {	        long instantMillis = DateTimeUtils.getInstantMillis(instant);	        Chronology instantChrono = DateTimeUtils.getInstantChronology(instant);	        DateTimeZone zone = instantChrono.getZone();	        if (zone != null) {	            instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis);	        }	        setTime(instantMillis);	    }	
/**	     * Set the time from fields.	     * The date part of this object will be unaffected.	     *	     * @param hour  the hour	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setTime(	            final int hour,	            final int minuteOfHour,	            final int secondOfMinute,	            final int millisOfSecond) {	        long instant = getChronology().getDateTimeMillis(	            getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond);	        setMillis(instant);	    }	
/**	     * Set the date and time from fields.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     * @throws IllegalArgumentException if the value is invalid	     */	    public void setDateTime(	            final int year,	            final int monthOfYear,	            final int dayOfMonth,	            final int hourOfDay,	            final int minuteOfHour,	            final int secondOfMinute,	            final int millisOfSecond) {	        long instant = getChronology().getDateTimeMillis(	            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	        setMillis(instant);	    }	
/**	     * Gets the property object for the specified type, which contains many useful methods.	     *	     * @param type  the field type to get the chronology for	     * @return the property object	     * @throws IllegalArgumentException if the field is null or unsupported	     * @since 1.2	     */	    public Property property(DateTimeFieldType type) {	        if (type == null) {	            throw new IllegalArgumentException("The DateTimeFieldType must not be null");	        }	        DateTimeField field = type.getField(getChronology());	        if (field.isSupported() == false) {	            throw new IllegalArgumentException("Field '" + type + "' is not supported");	        }	        return new Property(this, field);	    }	
/**	     * Get the era property.	     * 	     * @return the era property	     */	    public Property era() {	        return new Property(this, getChronology().era());	    }	
/**	     * Get the century of era property.	     * 	     * @return the year of era property	     */	    public Property centuryOfEra() {	        return new Property(this, getChronology().centuryOfEra());	    }	
/**	     * Get the year of century property.	     * 	     * @return the year of era property	     */	    public Property yearOfCentury() {	        return new Property(this, getChronology().yearOfCentury());	    }	
/**	     * Get the year of era property.	     * 	     * @return the year of era property	     */	    public Property yearOfEra() {	        return new Property(this, getChronology().yearOfEra());	    }	
/**	     * Get the year property.	     * 	     * @return the year property	     */	    public Property year() {	        return new Property(this, getChronology().year());	    }	
/**	     * Get the year of a week based year property.	     * 	     * @return the year of a week based year property	     */	    public Property weekyear() {	        return new Property(this, getChronology().weekyear());	    }	
/**	     * Get the month of year property.	     * 	     * @return the month of year property	     */	    public Property monthOfYear() {	        return new Property(this, getChronology().monthOfYear());	    }	
/**	     * Get the week of a week based year property.	     * 	     * @return the week of a week based year property	     */	    public Property weekOfWeekyear() {	        return new Property(this, getChronology().weekOfWeekyear());	    }	
/**	     * Get the day of year property.	     * 	     * @return the day of year property	     */	    public Property dayOfYear() {	        return new Property(this, getChronology().dayOfYear());	    }	
/**	     * Get the day of month property.	     * <p>	     * The values for day of month are defined in {@link DateTimeConstants}.	     * 	     * @return the day of month property	     */	    public Property dayOfMonth() {	        return new Property(this, getChronology().dayOfMonth());	    }	
/**	     * Get the day of week property.	     * <p>	     * The values for day of week are defined in {@link DateTimeConstants}.	     * 	     * @return the day of week property	     */	    public Property dayOfWeek() {	        return new Property(this, getChronology().dayOfWeek());	    }	
/**	     * Get the hour of day field property	     * 	     * @return the hour of day property	     */	    public Property hourOfDay() {	        return new Property(this, getChronology().hourOfDay());	    }	
/**	     * Get the minute of day property	     * 	     * @return the minute of day property	     */	    public Property minuteOfDay() {	        return new Property(this, getChronology().minuteOfDay());	    }	
/**	     * Get the minute of hour field property	     * 	     * @return the minute of hour property	     */	    public Property minuteOfHour() {	        return new Property(this, getChronology().minuteOfHour());	    }	
/**	     * Get the second of day property	     * 	     * @return the second of day property	     */	    public Property secondOfDay() {	        return new Property(this, getChronology().secondOfDay());	    }	
/**	     * Get the second of minute field property	     * 	     * @return the second of minute property	     */	    public Property secondOfMinute() {	        return new Property(this, getChronology().secondOfMinute());	    }	
/**	     * Get the millis of day property	     * 	     * @return the millis of day property	     */	    public Property millisOfDay() {	        return new Property(this, getChronology().millisOfDay());	    }	
/**	     * Get the millis of second property	     * 	     * @return the millis of second property	     */	    public Property millisOfSecond() {	        return new Property(this, getChronology().millisOfSecond());	    }	
/**	     * Clone this object without having to cast the returned object.	     *	     * @return a clone of the this object.	     */	    public MutableDateTime copy() {	        return (MutableDateTime) clone();	    }	
/**	     * Clone this object.	     *	     * @return a clone of this object.	     */	    public Object clone() {	        try {	            return super.clone();	        } catch (CloneNotSupportedException ex) {	            throw new InternalError("Clone error");	        }	    }	
/**	     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZZ).	     * 	     * @return ISO8601 time formatted string.	     */	    @ToString	    public String toString() {	        return ISODateTimeFormat.dateTime().print(this);	    }	
/**	         * Constructor.	         * 	         * @param instant  the instant to set	         * @param field  the field to use	         */	        Property(MutableDateTime instant, DateTimeField field) {	            super();	            iInstant = instant;	            iField = field;	        }	
/**	         * Writes the property in a safe serialization format.	         */	        private void writeObject(ObjectOutputStream oos) throws IOException {	            oos.writeObject(iInstant);	            oos.writeObject(iField.getType());	        }	
/**	         * Reads the property from a safe serialization format.	         */	        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {	            iInstant = (MutableDateTime) oos.readObject();	            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();	            iField = type.getField(iInstant.getChronology());	        }	
/**	         * Gets the field being used.	         * 	         * @return the field	         */	        public DateTimeField getField() {	            return iField;	        }	
/**	         * Gets the milliseconds of the datetime that this property is linked to.	         * 	         * @return the milliseconds	         */	        protected long getMillis() {	            return iInstant.getMillis();	        }	
/**	         * Gets the chronology of the datetime that this property is linked to.	         * 	         * @return the chronology	         * @since 1.4	         */	        protected Chronology getChronology() {	            return iInstant.getChronology();	        }	
/**	         * Gets the mutable datetime being used.	         * 	         * @return the mutable datetime	         */	        public MutableDateTime getMutableDateTime() {	            return iInstant;	        }	
/**	         * Adds a value to the millis value.	         * 	         * @param value  the value to add	         * @return the mutable datetime being used, so calls can be chained	         * @see DateTimeField#add(long,int)	         */	        public MutableDateTime add(int value) {	            iInstant.setMillis(getField().add(iInstant.getMillis(), value));	            return iInstant;	        }	
/**	         * Adds a value to the millis value.	         * 	         * @param value  the value to add	         * @return the mutable datetime being used, so calls can be chained	         * @see DateTimeField#add(long,long)	         */	        public MutableDateTime add(long value) {	            iInstant.setMillis(getField().add(iInstant.getMillis(), value));	            return iInstant;	        }	
/**	         * Adds a value, possibly wrapped, to the millis value.	         * 	         * @param value  the value to add	         * @return the mutable datetime being used, so calls can be chained	         * @see DateTimeField#addWrapField	         */	        public MutableDateTime addWrapField(int value) {	            iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value));	            return iInstant;	        }	
/**	         * Sets a value.	         * 	         * @param value  the value to set.	         * @return the mutable datetime being used, so calls can be chained	         * @see DateTimeField#set(long,int)	         */	        public MutableDateTime set(int value) {	            iInstant.setMillis(getField().set(iInstant.getMillis(), value));	            return iInstant;	        }	
/**	         * Sets a text value.	         * 	         * @param text  the text value to set	         * @param locale  optional locale to use for selecting a text symbol	         * @return the mutable datetime being used, so calls can be chained	         * @throws IllegalArgumentException if the text value isn't valid	         * @see DateTimeField#set(long,java.lang.String,java.util.Locale)	         */	        public MutableDateTime set(String text, Locale locale) {	            iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale));	            return iInstant;	        }	
/**	         * Sets a text value.	         * 	         * @param text  the text value to set	         * @return the mutable datetime being used, so calls can be chained	         * @throws IllegalArgumentException if the text value isn't valid	         * @see DateTimeField#set(long,java.lang.String)	         */	        public MutableDateTime set(String text) {	            set(text, null);	            return iInstant;	        }	
/**	         * Round to the lowest whole unit of this field.	         *	         * @return the mutable datetime being used, so calls can be chained	         * @see DateTimeField#roundFloor	         */	        public MutableDateTime roundFloor() {	            iInstant.setMillis(getField().roundFloor(iInstant.getMillis()));	            return iInstant;	        }	
/**	         * Round to the highest whole unit of this field.	         *	         * @return the mutable datetime being used, so calls can be chained	         * @see DateTimeField#roundCeiling	         */	        public MutableDateTime roundCeiling() {	            iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));	            return iInstant;	        }	
/**	         * Round to the nearest whole unit of this field, favoring the floor if	         * halfway.	         *	         * @return the mutable datetime being used, so calls can be chained	         * @see DateTimeField#roundHalfFloor	         */	        public MutableDateTime roundHalfFloor() {	            iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis()));	            return iInstant;	        }	
/**	         * Round to the nearest whole unit of this field, favoring the ceiling if	         * halfway.	         *	         * @return the mutable datetime being used, so calls can be chained	         * @see DateTimeField#roundHalfCeiling	         */	        public MutableDateTime roundHalfCeiling() {	            iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis()));	            return iInstant;	        }	
/**	         * Round to the nearest whole unit of this field. If halfway, the ceiling	         * is favored over the floor only if it makes this field's value even.	         *	         * @return the mutable datetime being used, so calls can be chained	         * @see DateTimeField#roundHalfEven	         */	        public MutableDateTime roundHalfEven() {	            iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis()));	            return iInstant;	        }	
/**	     * Constructs a YearMonthDay from a <code>java.util.Calendar</code>	     * using exactly the same field values avoiding any time zone effects.	     * <p>	     * Each field is queried from the Calendar and assigned to the YearMonthDay.	     * This is useful if you have been using the Calendar as a local date,	     * ignoing the zone.	     * <p>	     * This factory method ignores the type of the calendar and always	     * creates a YearMonthDay with ISO chronology. It is expected that you	     * will only pass in instances of <code>GregorianCalendar</code> however	     * this is not validated.	     *	     * @param calendar  the Calendar to extract fields from	     * @return the created YearMonthDay	     * @throws IllegalArgumentException if the calendar is null	     * @throws IllegalArgumentException if the date is invalid for the ISO chronology	     * @since 1.2	     */	    public static YearMonthDay fromCalendarFields(Calendar calendar) {	        if (calendar == null) {	            throw new IllegalArgumentException("The calendar must not be null");	        }	        return new YearMonthDay(	            calendar.get(Calendar.YEAR),	            calendar.get(Calendar.MONTH) + 1,	            calendar.get(Calendar.DAY_OF_MONTH)	        );	    }	
/**	     * Constructs a YearMonthDay from a <code>java.util.Date</code>	     * using exactly the same field values avoiding any time zone effects.	     * <p>	     * Each field is queried from the Date and assigned to the YearMonthDay.	     * This is useful if you have been using the Date as a local date,	     * ignoing the zone.	     * <p>	     * This factory method always creates a YearMonthDay with ISO chronology.	     *	     * @param date  the Date to extract fields from	     * @return the created YearMonthDay	     * @throws IllegalArgumentException if the calendar is null	     * @throws IllegalArgumentException if the date is invalid for the ISO chronology	     * @since 1.2	     */	    public static YearMonthDay fromDateFields(Date date) {	        if (date == null) {	            throw new IllegalArgumentException("The date must not be null");	        }	        return new YearMonthDay(	            date.getYear() + 1900,	            date.getMonth() + 1,	            date.getDate()	        );	    }	
/**	     * Constructs a YearMonthDay with the current date, using ISOChronology in	     * the default zone to extract the fields.	     * <p>	     * The constructor uses the default time zone, resulting in the local time	     * being initialised. Once the constructor is complete, all further calculations	     * are performed without reference to a timezone (by switching to UTC).	     */	    public YearMonthDay() {	        super();	    }	
/**	     * Constructs a YearMonthDay with the current date, using ISOChronology in	     * the specified zone to extract the fields.	     * <p>	     * The constructor uses the specified time zone to obtain the current date.	     * Once the constructor is complete, all further calculations	     * are performed without reference to a timezone (by switching to UTC).	     * 	     * @param zone  the zone to use, null means default zone	     * @since 1.1	     */	    public YearMonthDay(DateTimeZone zone) {	        super(ISOChronology.getInstance(zone));	    }	
/**	     * Constructs a YearMonthDay with the current date, using the specified chronology	     * and zone to extract the fields.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a timezone (by switching to UTC).	     *	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    public YearMonthDay(Chronology chronology) {	        super(chronology);	    }	
/**	     * Constructs a YearMonthDay extracting the partial fields from the specified	     * milliseconds using the ISOChronology in the default zone.	     * <p>	     * The constructor uses the default time zone, resulting in the local time	     * being initialised. Once the constructor is complete, all further calculations	     * are performed without reference to a timezone (by switching to UTC).	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     */	    public YearMonthDay(long instant) {	        super(instant);	    }	
/**	     * Constructs a YearMonthDay extracting the partial fields from the specified	     * milliseconds using the chronology provided.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a timezone (by switching to UTC).	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    public YearMonthDay(long instant, Chronology chronology) {	        super(instant, chronology);	    }	
/**	     * Constructs a YearMonthDay from an Object that represents a time.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.	     * <p>	     * The chronology used will be derived from the object, defaulting to ISO.	     * <p>	     * NOTE: Prior to v1.3 the string format was described by	     * {@link ISODateTimeFormat#dateTimeParser()}. Time ony strings are now rejected.	     *	     * @param instant  the datetime object, null means now	     * @throws IllegalArgumentException if the instant is invalid	     */	    public YearMonthDay(Object instant) {	        super(instant, null, ISODateTimeFormat.dateOptionalTimeParser());	    }	
/**	     * Constructs a YearMonthDay from an Object that represents a time, using the	     * specified chronology.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a timezone (by switching to UTC).	     * The specified chronology overrides that of the object.	     * <p>	     * NOTE: Prior to v1.3 the string format was described by	     * {@link ISODateTimeFormat#dateTimeParser()}. Time only strings are now rejected.	     *	     * @param instant  the datetime object, null means now	     * @param chronology  the chronology, null means ISO default	     * @throws IllegalArgumentException if the instant is invalid	     */	    public YearMonthDay(Object instant, Chronology chronology) {	        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.dateOptionalTimeParser());	    }	
/**	     * Constructs a YearMonthDay with specified time field values	     * using <code>ISOChronology</code> in the default zone.	     * <p>	     * The constructor uses the no time zone initialising the fields as provided.	     * Once the constructor is complete, all further calculations	     * are performed without reference to a timezone (by switching to UTC).	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     */	    public YearMonthDay(int year, int monthOfYear, int dayOfMonth) {	        this(year, monthOfYear, dayOfMonth, null);	    }	
/**	     * Constructs a YearMonthDay with specified time field values.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a timezone (by switching to UTC).	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {	        super(new int[] {year, monthOfYear, dayOfMonth}, chronology);	    }	
/**	     * Constructs a YearMonthDay with chronology from this instance and new values.	     *	     * @param partial  the partial to base this new instance on	     * @param values  the new set of values	     */	    YearMonthDay(YearMonthDay partial, int[] values) {	        super(partial, values);	    }	
/**	     * Constructs a YearMonthDay with values from this instance and a new chronology.	     *	     * @param partial  the partial to base this new instance on	     * @param chrono  the new chronology	     */	    YearMonthDay(YearMonthDay partial, Chronology chrono) {	        super(partial, chrono);	    }	
/**	     * Gets the number of fields in this partial.	     * 	     * @return the field count	     */	    public int size() {	        return 3;	    }	
/**	     * Gets the field for a specific index in the chronology specified.	     * <p>	     * This method must not use any instance variables.	     * 	     * @param index  the index to retrieve	     * @param chrono  the chronology to use	     * @return the field	     */	    protected DateTimeField getField(int index, Chronology chrono) {	        switch (index) {	            case YEAR:	                return chrono.year();	            case MONTH_OF_YEAR:	                return chrono.monthOfYear();	            case DAY_OF_MONTH:	                return chrono.dayOfMonth();	            default:	                throw new IndexOutOfBoundsException("Invalid index: " + index);	        }	    }	
/**	     * Gets the field type at the specified index.	     *	     * @param index  the index to retrieve	     * @return the field at the specified index	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public DateTimeFieldType getFieldType(int index) {	        return FIELD_TYPES[index];	    }	
/**	     * Gets an array of the field type of each of the fields that this partial supports.	     * <p>	     * The fields are returned largest to smallest, Year, Month, Day	     *	     * @return the array of field types (cloned), largest to smallest	     */	    public DateTimeFieldType[] getFieldTypes() {	        return (DateTimeFieldType[]) FIELD_TYPES.clone();	    }	
/**	     * Returns a copy of this date with the specified chronology.	     * This instance is immutable and unaffected by this method call.	     * <p>	     * This method retains the values of the fields, thus the result will	     * typically refer to a different instant.	     * <p>	     * The time zone of the specified chronology is ignored, as YearMonthDay	     * operates without a time zone.	     *	     * @param newChronology  the new chronology, null means ISO	     * @return a copy of this datetime with a different chronology	     * @throws IllegalArgumentException if the values are invalid for the new chronology	     */	    public YearMonthDay withChronologyRetainFields(Chronology newChronology) {	        newChronology = DateTimeUtils.getChronology(newChronology);	        newChronology = newChronology.withUTC();	        if (newChronology == getChronology()) {	            return this;	        } else {	            YearMonthDay newYearMonthDay = new YearMonthDay(this, newChronology);	            newChronology.validate(newYearMonthDay, getValues());	            return newYearMonthDay;	        }	    }	
/**	     * Returns a copy of this date with the specified field set to a new value.	     * <p>	     * For example, if the field type is <code>dayOfMonth</code> then the day	     * would be changed in the returned instance.	     * <p>	     * These three lines are equivalent:	     * <pre>	     * YearMonthDay updated = ymd.withField(DateTimeFieldType.dayOfMonth(), 6);	     * YearMonthDay updated = ymd.dayOfMonth().setCopy(6);	     * YearMonthDay updated = ymd.property(DateTimeFieldType.dayOfMonth()).setCopy(6);	     * </pre>	     *	     * @param fieldType  the field type to set, not null	     * @param value  the value to set	     * @return a copy of this instance with the field set	     * @throws IllegalArgumentException if the value is null or invalid	     */	    public YearMonthDay withField(DateTimeFieldType fieldType, int value) {	        int index = indexOfSupported(fieldType);	        if (value == getValue(index)) {	            return this;	        }	        int[] newValues = getValues();	        newValues = getField(index).set(this, index, newValues, value);	        return new YearMonthDay(this, newValues);	    }	
/**	     * Returns a copy of this date with the value of the specified field increased.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * <p>	     * These three lines are equivalent:	     * <pre>	     * YearMonthDay added = ymd.withFieldAdded(DurationFieldType.days(), 6);	     * YearMonthDay added = ymd.plusDays(6);	     * YearMonthDay added = ymd.dayOfMonth().addToCopy(6);	     * </pre>	     * 	     * @param fieldType  the field type to add to, not null	     * @param amount  the amount to add	     * @return a copy of this instance with the field updated	     * @throws IllegalArgumentException if the value is null or invalid	     * @throws ArithmeticException if the new datetime exceeds the capacity	     */	    public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount) {	        int index = indexOfSupported(fieldType);	        if (amount == 0) {	            return this;	        }	        int[] newValues = getValues();	        newValues = getField(index).add(this, index, newValues, amount);	        return new YearMonthDay(this, newValues);	    }	
/**	     * Returns a copy of this date with the specified period added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * Fields in the period that aren't present in the partial are ignored.	     * <p>	     * This method is typically used to add multiple copies of complex	     * period instances. Adding one field is best achieved using methods	     * like {@link #withFieldAdded(DurationFieldType, int)}	     * or {@link #plusYears(int)}.	     * 	     * @param period  the period to add to this one, null means zero	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this instance with the period added	     * @throws ArithmeticException if the new datetime exceeds the capacity	     */	    public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar) {	        if (period == null || scalar == 0) {	            return this;	        }	        int[] newValues = getValues();	        for (int i = 0; i < period.size(); i++) {	            DurationFieldType fieldType = period.getFieldType(i);	            int index = indexOf(fieldType);	            if (index >= 0) {	                newValues = getField(index).add(this, index, newValues,	                        FieldUtils.safeMultiply(period.getValue(i), scalar));	            }	        }	        return new YearMonthDay(this, newValues);	    }	
/**	     * Returns a copy of this date with the specified period added.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to add complex period instances.	     * Adding one field is best achieved using methods	     * like {@link #plusYears(int)}.	     * 	     * @param period  the duration to add to this one, null means zero	     * @return a copy of this instance with the period added	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public YearMonthDay plus(ReadablePeriod period) {	        return withPeriodAdded(period, 1);	    }	
/**	     * Returns a copy of this date plus the specified number of years.	     * <p>	     * This date instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * YearMonthDay added = dt.plusYears(6);	     * YearMonthDay added = dt.plus(Period.years(6));	     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.years(), 6);	     * </pre>	     *	     * @param years  the amount of years to add, may be negative	     * @return the new date plus the increased years	     * @since 1.1	     */	    public YearMonthDay plusYears(int years) {	        return withFieldAdded(DurationFieldType.years(), years);	    }	
/**	     * Returns a copy of this date plus the specified number of months.	     * <p>	     * This date instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * YearMonthDay added = dt.plusMonths(6);	     * YearMonthDay added = dt.plus(Period.months(6));	     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.months(), 6);	     * </pre>	     *	     * @param months  the amount of months to add, may be negative	     * @return the new date plus the increased months	     * @since 1.1	     */	    public YearMonthDay plusMonths(int months) {	        return withFieldAdded(DurationFieldType.months(), months);	    }	
/**	     * Returns a copy of this date plus the specified number of days.	     * <p>	     * This date instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * YearMonthDay added = dt.plusDays(6);	     * YearMonthDay added = dt.plus(Period.days(6));	     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.days(), 6);	     * </pre>	     *	     * @param days  the amount of days to add, may be negative	     * @return the new date plus the increased days	     * @since 1.1	     */	    public YearMonthDay plusDays(int days) {	        return withFieldAdded(DurationFieldType.days(), days);	    }	
/**	     * Returns a copy of this date with the specified period taken away.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to subtract complex period instances.	     * Subtracting one field is best achieved using methods	     * like {@link #minusYears(int)}.	     * 	     * @param period  the period to reduce this instant by	     * @return a copy of this instance with the period taken away	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public YearMonthDay minus(ReadablePeriod period) {	        return withPeriodAdded(period, -1);	    }	
/**	     * Returns a copy of this date minus the specified number of years.	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * YearMonthDay subtracted = dt.minusYears(6);	     * YearMonthDay subtracted = dt.minus(Period.years(6));	     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);	     * </pre>	     *	     * @param years  the amount of years to subtract, may be negative	     * @return the new datetime minus the increased years	     * @since 1.1	     */	    public YearMonthDay minusYears(int years) {	        return withFieldAdded(DurationFieldType.years(), FieldUtils.safeNegate(years));	    }	
/**	     * Returns a copy of this date minus the specified number of months.	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * YearMonthDay subtracted = dt.minusMonths(6);	     * YearMonthDay subtracted = dt.minus(Period.months(6));	     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);	     * </pre>	     *	     * @param months  the amount of months to subtract, may be negative	     * @return the new datetime minus the increased months	     * @since 1.1	     */	    public YearMonthDay minusMonths(int months) {	        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));	    }	
/**	     * Returns a copy of this date minus the specified number of days.	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * YearMonthDay subtracted = dt.minusDays(6);	     * YearMonthDay subtracted = dt.minus(Period.days(6));	     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);	     * </pre>	     *	     * @param days  the amount of days to subtract, may be negative	     * @return the new datetime minus the increased days	     * @since 1.1	     */	    public YearMonthDay minusDays(int days) {	        return withFieldAdded(DurationFieldType.days(), FieldUtils.safeNegate(days));	    }	
/**	     * Gets the property object for the specified type, which contains	     * many useful methods.	     *	     * @param type  the field type to get the property for	     * @return the property object	     * @throws IllegalArgumentException if the field is null or unsupported	     */	    public Property property(DateTimeFieldType type) {	        return new Property(this, indexOfSupported(type));	    }	
/**	     * Converts this object to a LocalDate with the same date and chronology.	     *	     * @return a LocalDate with the same date and chronology	     * @since 1.3	     */	    public LocalDate toLocalDate() {	        return new LocalDate(getYear(), getMonthOfYear(), getDayOfMonth(), getChronology());	    }	
/**	     * Converts this YearMonthDay to a full datetime at midnight using the	     * default time zone.	     *	     * @return this date as a datetime at midnight	     */	    public DateTime toDateTimeAtMidnight() {	        return toDateTimeAtMidnight(null);	    }	
/**	     * Converts this YearMonthDay to a full datetime at midnight using the	     * specified time zone.	     * <p>	     * This method uses the chronology from this instance plus the time zone	     * specified.	     *	     * @param zone  the zone to use, null means default	     * @return this date as a datetime at midnight	     */	    public DateTime toDateTimeAtMidnight(DateTimeZone zone) {	        Chronology chrono = getChronology().withZone(zone);	        return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);	    }	
/**	     * Converts this partial to a full datetime using the default time zone	     * setting the date fields from this instance and the time fields from	     * the current time.	     *	     * @return this date as a datetime with the time as the current time	     */	    public DateTime toDateTimeAtCurrentTime() {	        return toDateTimeAtCurrentTime(null);	    }	
/**	     * Converts this partial to a full datetime using the specified time zone	     * setting the date fields from this instance and the time fields from	     * the current time.	     * <p>	     * This method uses the chronology from this instance plus the time zone	     * specified.	     *	     * @param zone  the zone to use, null means default	     * @return this date as a datetime with the time as the current time	     */	    public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {	        Chronology chrono = getChronology().withZone(zone);	        long instantMillis = DateTimeUtils.currentTimeMillis();	        long resolved = chrono.set(this, instantMillis);	        return new DateTime(resolved, chrono);	    }	
/**	     * Converts this object to a DateMidnight in the default time zone.	     *	     * @return the DateMidnight instance in the default zone	     */	    public DateMidnight toDateMidnight() {	        return toDateMidnight(null);	    }	
/**	     * Converts this object to a DateMidnight.	     *	     * @param zone  the zone to get the DateMidnight in, null means default	     * @return the DateMidnight instance	     */	    public DateMidnight toDateMidnight(DateTimeZone zone) {	        Chronology chrono = getChronology().withZone(zone);	        return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);	    }	
/**	     * Converts this object to a DateTime using a TimeOfDay to fill in the	     * missing fields and using the default time zone.	     * This instance is immutable and unaffected by this method call.	     * <p>	     * The resulting chronology is determined by the chronology of this	     * YearMonthDay plus the time zone.	     * The chronology of the time is ignored - only the field values are used.	     *	     * @param time  the time of day to use, null means current time	     * @return the DateTime instance	     */	    public DateTime toDateTime(TimeOfDay time) {	        return toDateTime(time, null);	    }	
/**	     * Converts this object to a DateTime using a TimeOfDay to fill in the	     * missing fields.	     * This instance is immutable and unaffected by this method call.	     * <p>	     * The resulting chronology is determined by the chronology of this	     * YearMonthDay plus the time zone.	     * The chronology of the time is ignored - only the field values are used.	     *	     * @param time  the time of day to use, null means current time	     * @param zone  the zone to get the DateTime in, null means default	     * @return the DateTime instance	     */	    public DateTime toDateTime(TimeOfDay time, DateTimeZone zone) {	        Chronology chrono = getChronology().withZone(zone);	        long instant = DateTimeUtils.currentTimeMillis();	        instant = chrono.set(this, instant);	        if (time != null) {	            instant = chrono.set(time, instant);	        }	        return new DateTime(instant, chrono);	    }	
/**	     * Converts this object to an Interval representing the whole day	     * in the default time zone.	     *	     * @return a interval over the day	     */	    public Interval toInterval() {	        return toInterval(null);	    }	
/**	     * Converts this object to an Interval representing the whole day.	     *	     * @param zone  the zone to get the Interval in, null means default	     * @return a interval over the day	     */	    public Interval toInterval(DateTimeZone zone) {	        zone = DateTimeUtils.getZone(zone);	        return toDateMidnight(zone).toInterval();	    }	
/**	     * Get the year field value.	     *	     * @return the year	     */	    public int getYear() {	        return getValue(YEAR);	    }	
/**	     * Get the month of year field value.	     *	     * @return the month of year	     */	    public int getMonthOfYear() {	        return getValue(MONTH_OF_YEAR);	    }	
/**	     * Get the day of month field value.	     *	     * @return the day of month	     */	    public int getDayOfMonth() {	        return getValue(DAY_OF_MONTH);	    }	
/**	     * Returns a copy of this date with the year field updated.	     * <p>	     * YearMonthDay is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * year changed.	     *	     * @param year  the year to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public YearMonthDay withYear(int year) {	        int[] newValues = getValues();	        newValues = getChronology().year().set(this, YEAR, newValues, year);	        return new YearMonthDay(this, newValues);	    }	
/**	     * Returns a copy of this date with the month of year field updated.	     * <p>	     * YearMonthDay is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * month of year changed.	     *	     * @param monthOfYear  the month of year to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public YearMonthDay withMonthOfYear(int monthOfYear) {	        int[] newValues = getValues();	        newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);	        return new YearMonthDay(this, newValues);	    }	
/**	     * Returns a copy of this date with the day of month field updated.	     * <p>	     * YearMonthDay is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * day of month changed.	     *	     * @param dayOfMonth  the day of month to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public YearMonthDay withDayOfMonth(int dayOfMonth) {	        int[] newValues = getValues();	        newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth);	        return new YearMonthDay(this, newValues);	    }	
/**	     * Get the year field property which provides access to advanced functionality.	     * 	     * @return the year property	     */	    public Property year() {	        return new Property(this, YEAR);	    }	
/**	     * Get the month of year field property which provides access to advanced functionality.	     * 	     * @return the month of year property	     */	    public Property monthOfYear() {	        return new Property(this, MONTH_OF_YEAR);	    }	
/**	     * Get the day of month field property which provides access to advanced functionality.	     * 	     * @return the day of month property	     */	    public Property dayOfMonth() {	        return new Property(this, DAY_OF_MONTH);	    }	
/**	     * Output the date in the ISO8601 format YYYY-MM-DD.	     * 	     * @return ISO8601 formatted string	     */	    public String toString() {	        return ISODateTimeFormat.yearMonthDay().print(this);	    }	
/**	         * Constructs a property.	         * 	         * @param partial  the partial instance	         * @param fieldIndex  the index in the partial	         */	        Property(YearMonthDay partial, int fieldIndex) {	            super();	            iYearMonthDay = partial;	            iFieldIndex = fieldIndex;	        }	
/**	         * Gets the field that this property uses.	         * 	         * @return the field	         */	        public DateTimeField getField() {	            return iYearMonthDay.getField(iFieldIndex);	        }	
/**	         * Gets the partial that this property belongs to.	         * 	         * @return the partial	         */	        protected ReadablePartial getReadablePartial() {	            return iYearMonthDay;	        }	
/**	         * Gets the partial that this property belongs to.	         * 	         * @return the partial	         */	        public YearMonthDay getYearMonthDay() {	            return iYearMonthDay;	        }	
/**	         * Gets the value of this field.	         * 	         * @return the field value	         */	        public int get() {	            return iYearMonthDay.getValue(iFieldIndex);	        }	
/**	         * Adds to the value of this field in a copy of this YearMonthDay.	         * <p>	         * The value will be added to this field. If the value is too large to be	         * added solely to this field then it will affect larger fields.	         * Smaller fields are unaffected.	         * <p>	         * If the result would be too large, beyond the maximum year, then an	         * IllegalArgumentException is thrown.	         * <p>	         * The YearMonthDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param valueToAdd  the value to add to the field in the copy	         * @return a copy of the YearMonthDay with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public YearMonthDay addToCopy(int valueToAdd) {	            int[] newValues = iYearMonthDay.getValues();	            newValues = getField().add(iYearMonthDay, iFieldIndex, newValues, valueToAdd);	            return new YearMonthDay(iYearMonthDay, newValues);	        }	
/**	         * Adds to the value of this field in a copy of this YearMonthDay wrapping	         * within this field if the maximum value is reached.	         * <p>	         * The value will be added to this field. If the value is too large to be	         * added solely to this field then it wraps within this field.	         * Other fields are unaffected.	         * <p>	         * For example,	         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.	         * <p>	         * The YearMonthDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param valueToAdd  the value to add to the field in the copy	         * @return a copy of the YearMonthDay with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public YearMonthDay addWrapFieldToCopy(int valueToAdd) {	            int[] newValues = iYearMonthDay.getValues();	            newValues = getField().addWrapField(iYearMonthDay, iFieldIndex, newValues, valueToAdd);	            return new YearMonthDay(iYearMonthDay, newValues);	        }	
/**	         * Sets this field in a copy of the YearMonthDay.	         * <p>	         * The YearMonthDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param value  the value to set the field in the copy to	         * @return a copy of the YearMonthDay with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public YearMonthDay setCopy(int value) {	            int[] newValues = iYearMonthDay.getValues();	            newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, value);	            return new YearMonthDay(iYearMonthDay, newValues);	        }	
/**	         * Sets this field in a copy of the YearMonthDay to a parsed text value.	         * <p>	         * The YearMonthDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param text  the text value to set	         * @param locale  optional locale to use for selecting a text symbol	         * @return a copy of the YearMonthDay with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public YearMonthDay setCopy(String text, Locale locale) {	            int[] newValues = iYearMonthDay.getValues();	            newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, text, locale);	            return new YearMonthDay(iYearMonthDay, newValues);	        }	
/**	         * Sets this field in a copy of the YearMonthDay to a parsed text value.	         * <p>	         * The YearMonthDay attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param text  the text value to set	         * @return a copy of the YearMonthDay with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public YearMonthDay setCopy(String text) {	            return setCopy(text, null);	        }	
/**	         * Returns a new YearMonthDay with this field set to the maximum value	         * for this field.	         * <p>	         * This operation is useful for obtaining a DateTime on the last day	         * of the month, as month lengths vary.	         * <pre>	         * YearMonthDay lastDayOfMonth = dt.dayOfMonth().withMaximumValue();	         * </pre>	         * <p>	         * The YearMonthDay attached to this property is unchanged by this call.	         *	         * @return a copy of the YearMonthDay with this field set to its maximum	         * @since 1.2	         */	        public YearMonthDay withMaximumValue() {	            return setCopy(getMaximumValue());	        }	
/**	         * Returns a new YearMonthDay with this field set to the minimum value	         * for this field.	         * <p>	         * The YearMonthDay attached to this property is unchanged by this call.	         *	         * @return a copy of the YearMonthDay with this field set to its minimum	         * @since 1.2	         */	        public YearMonthDay withMinimumValue() {	            return setCopy(getMinimumValue());	        }	
/**	     * Parses a {@code YearMonth} from the specified string.	     * <p>	     * This uses {@link ISODateTimeFormat#localDateParser()}.	     * 	     * @param str  the string to parse, not null	     * @since 2.0	     */	    @FromString	    public static YearMonth parse(String str) {	        return parse(str, ISODateTimeFormat.localDateParser());	    }	
/**	     * Parses a {@code YearMonth} from the specified string using a formatter.	     * 	     * @param str  the string to parse, not null	     * @param formatter  the formatter to use, not null	     * @since 2.0	     */	    public static YearMonth parse(String str, DateTimeFormatter formatter) {	        LocalDate date = formatter.parseLocalDate(str);	        return new YearMonth(date.getYear(), date.getMonthOfYear());	    }	
/**	     * Constructs a YearMonth from a <code>java.util.Calendar</code>	     * using exactly the same field values avoiding any time zone effects.	     * <p>	     * Each field is queried from the Calendar and assigned to the YearMonth.	     * <p>	     * This factory method ignores the type of the calendar and always	     * creates a YearMonth with ISO chronology. It is expected that you	     * will only pass in instances of <code>GregorianCalendar</code> however	     * this is not validated.	     *	     * @param calendar  the Calendar to extract fields from	     * @return the created YearMonth, never null	     * @throws IllegalArgumentException if the calendar is null	     * @throws IllegalArgumentException if the year or month is invalid for the ISO chronology	     */	    public static YearMonth fromCalendarFields(Calendar calendar) {	        if (calendar == null) {	            throw new IllegalArgumentException("The calendar must not be null");	        }	        return new YearMonth(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1);	    }	
/**	     * Constructs a YearMonth from a <code>java.util.Date</code>	     * using exactly the same field values avoiding any time zone effects.	     * <p>	     * Each field is queried from the Date and assigned to the YearMonth.	     * <p>	     * This factory method always creates a YearMonth with ISO chronology.	     *	     * @param date  the Date to extract fields from	     * @return the created YearMonth, never null	     * @throws IllegalArgumentException if the calendar is null	     * @throws IllegalArgumentException if the year or month is invalid for the ISO chronology	     */	    @SuppressWarnings("deprecation")	    public static YearMonth fromDateFields(Date date) {	        if (date == null) {	            throw new IllegalArgumentException("The date must not be null");	        }	        return new YearMonth(date.getYear() + 1900, date.getMonth() + 1);	    }	
/**	     * Constructs a YearMonth with the current year-month, using ISOChronology in	     * the default zone to extract the fields.	     * <p>	     * The constructor uses the default time zone, resulting in the local time	     * being initialised. Once the constructor is complete, all further calculations	     * are performed without reference to a time-zone (by switching to UTC).	     */	    public YearMonth() {	        super();	    }	
/**	     * Constructs a YearMonth with the current year-month, using ISOChronology in	     * the specified zone to extract the fields.	     * <p>	     * The constructor uses the specified time zone to obtain the current year-month.	     * Once the constructor is complete, all further calculations	     * are performed without reference to a time-zone (by switching to UTC).	     * 	     * @param zone  the zone to use, null means default zone	     */	    public YearMonth(DateTimeZone zone) {	        super(ISOChronology.getInstance(zone));	    }	
/**	     * Constructs a YearMonth with the current year-month, using the specified chronology	     * and zone to extract the fields.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a time-zone (by switching to UTC).	     *	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    public YearMonth(Chronology chronology) {	        super(chronology);	    }	
/**	     * Constructs a YearMonth extracting the partial fields from the specified	     * milliseconds using the ISOChronology in the default zone.	     * <p>	     * The constructor uses the default time zone, resulting in the local time	     * being initialised. Once the constructor is complete, all further calculations	     * are performed without reference to a time-zone (by switching to UTC).	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     */	    public YearMonth(long instant) {	        super(instant);	    }	
/**	     * Constructs a YearMonth extracting the partial fields from the specified	     * milliseconds using the chronology provided.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a time-zone (by switching to UTC).	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    public YearMonth(long instant, Chronology chronology) {	        super(instant, chronology);	    }	
/**	     * Constructs a YearMonth from an Object that represents some form of time.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.	     * <p>	     * The chronology used will be derived from the object, defaulting to ISO.	     *	     * @param instant  the date-time object, null means now	     * @throws IllegalArgumentException if the instant is invalid	     */	    public YearMonth(Object instant) {	        super(instant, null, ISODateTimeFormat.localDateParser());	    }	
/**	     * Constructs a YearMonth from an Object that represents some form of time,	     * using the specified chronology.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a time-zone (by switching to UTC).	     * The specified chronology overrides that of the object.	     *	     * @param instant  the date-time object, null means now	     * @param chronology  the chronology, null means ISO default	     * @throws IllegalArgumentException if the instant is invalid	     */	    public YearMonth(Object instant, Chronology chronology) {	        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser());	    }	
/**	     * Constructs a YearMonth with specified year and month	     * using <code>ISOChronology</code>.	     * <p>	     * The constructor uses the no time zone initialising the fields as provided.	     * Once the constructor is complete, all further calculations	     * are performed without reference to a time-zone (by switching to UTC).	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     */	    public YearMonth(int year, int monthOfYear) {	        this(year, monthOfYear, null);	    }	
/**	     * Constructs an instance set to the specified year and month	     * using the specified chronology, whose zone is ignored.	     * <p>	     * If the chronology is null, <code>ISOChronology</code> is used.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a time-zone (by switching to UTC).	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    public YearMonth(int year, int monthOfYear, Chronology chronology) {	        super(new int[] {year, monthOfYear}, chronology);	    }	
/**	     * Constructs a YearMonth with chronology from this instance and new values.	     *	     * @param partial  the partial to base this new instance on	     * @param values  the new set of values	     */	    YearMonth(YearMonth partial, int[] values) {	        super(partial, values);	    }	
/**	     * Constructs a YearMonth with values from this instance and a new chronology.	     *	     * @param partial  the partial to base this new instance on	     * @param chrono  the new chronology	     */	    YearMonth(YearMonth partial, Chronology chrono) {	        super(partial, chrono);	    }	
/**	     * Gets the number of fields in this partial, which is two.	     * The supported fields are Year and MonthOfYear.	     * Note that only these fields may be queried.	     *	     * @return the field count, two	     */	    public int size() {	        return 2;	    }	
/**	     * Gets the field for a specific index in the chronology specified.	     * <p>	     * This method must not use any instance variables.	     * 	     * @param index  the index to retrieve	     * @param chrono  the chronology to use	     * @return the field, never null	     */	    protected DateTimeField getField(int index, Chronology chrono) {	        switch (index) {	            case YEAR:	                return chrono.year();	            case MONTH_OF_YEAR:	                return chrono.monthOfYear();	            default:	                throw new IndexOutOfBoundsException("Invalid index: " + index);	        }	    }	
/**	     * Gets the field type at the specified index.	     *	     * @param index  the index to retrieve	     * @return the field at the specified index, never null	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public DateTimeFieldType getFieldType(int index) {	        return FIELD_TYPES[index];	    }	
/**	     * Gets an array of the field type of each of the fields that this partial supports.	     * <p>	     * The fields are returned largest to smallest, Year, Month.	     *	     * @return the array of field types (cloned), largest to smallest, never null	     */	    public DateTimeFieldType[] getFieldTypes() {	        return (DateTimeFieldType[]) FIELD_TYPES.clone();	    }	
/**	     * Returns a copy of this year-month with the specified chronology.	     * This instance is immutable and unaffected by this method call.	     * <p>	     * This method retains the values of the fields, thus the result will	     * typically refer to a different instant.	     * <p>	     * The time zone of the specified chronology is ignored, as YearMonth	     * operates without a time zone.	     *	     * @param newChronology  the new chronology, null means ISO	     * @return a copy of this year-month with a different chronology, never null	     * @throws IllegalArgumentException if the values are invalid for the new chronology	     */	    public YearMonth withChronologyRetainFields(Chronology newChronology) {	        newChronology = DateTimeUtils.getChronology(newChronology);	        newChronology = newChronology.withUTC();	        if (newChronology == getChronology()) {	            return this;	        } else {	            YearMonth newYearMonth = new YearMonth(this, newChronology);	            newChronology.validate(newYearMonth, getValues());	            return newYearMonth;	        }	    }	
/**	     * Returns a copy of this year-month with the specified field set to a new value.	     * <p>	     * For example, if the field type is <code>monthOfYear</code> then the month	     * would be changed in the returned instance.	     * <p>	     * These three lines are equivalent:	     * <pre>	     * YearMonth updated = ym.withField(DateTimeFieldType.monthOfYear(), 6);	     * YearMonth updated = ym.monthOfYear().setCopy(6);	     * YearMonth updated = ym.property(DateTimeFieldType.monthOfYear()).setCopy(6);	     * </pre>	     *	     * @param fieldType  the field type to set, not null	     * @param value  the value to set	     * @return a copy of this instance with the field set, never null	     * @throws IllegalArgumentException if the value is null or invalid	     */	    public YearMonth withField(DateTimeFieldType fieldType, int value) {	        int index = indexOfSupported(fieldType);	        if (value == getValue(index)) {	            return this;	        }	        int[] newValues = getValues();	        newValues = getField(index).set(this, index, newValues, value);	        return new YearMonth(this, newValues);	    }	
/**	     * Returns a copy of this year-month with the value of the specified field increased.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * <p>	     * These three lines are equivalent:	     * <pre>	     * YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6);	     * YearMonth added = ym.plusMonths(6);	     * YearMonth added = ym.monthOfYear().addToCopy(6);	     * </pre>	     * 	     * @param fieldType  the field type to add to, not null	     * @param amount  the amount to add	     * @return a copy of this instance with the field updated, never null	     * @throws IllegalArgumentException if the value is null or invalid	     * @throws ArithmeticException if the new date-time exceeds the capacity	     */	    public YearMonth withFieldAdded(DurationFieldType fieldType, int amount) {	        int index = indexOfSupported(fieldType);	        if (amount == 0) {	            return this;	        }	        int[] newValues = getValues();	        newValues = getField(index).add(this, index, newValues, amount);	        return new YearMonth(this, newValues);	    }	
/**	     * Returns a copy of this year-month with the specified period added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * Fields in the period that aren't present in the partial are ignored.	     * <p>	     * This method is typically used to add multiple copies of complex	     * period instances. Adding one field is best achieved using methods	     * like {@link #withFieldAdded(DurationFieldType, int)}	     * or {@link #plusYears(int)}.	     * 	     * @param period  the period to add to this one, null means zero	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this instance with the period added, never null	     * @throws ArithmeticException if the new date-time exceeds the capacity	     */	    public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) {	        if (period == null || scalar == 0) {	            return this;	        }	        int[] newValues = getValues();	        for (int i = 0; i < period.size(); i++) {	            DurationFieldType fieldType = period.getFieldType(i);	            int index = indexOf(fieldType);	            if (index >= 0) {	                newValues = getField(index).add(this, index, newValues,	                        FieldUtils.safeMultiply(period.getValue(i), scalar));	            }	        }	        return new YearMonth(this, newValues);	    }	
/**	     * Returns a copy of this year-month with the specified period added.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to add complex period instances.	     * Adding one field is best achieved using methods	     * like {@link #plusYears(int)}.	     * 	     * @param period  the duration to add to this one, null means zero	     * @return a copy of this instance with the period added, never null	     * @throws ArithmeticException if the new year-month exceeds the capacity	     */	    public YearMonth plus(ReadablePeriod period) {	        return withPeriodAdded(period, 1);	    }	
/**	     * Returns a copy of this year-month plus the specified number of years.	     * <p>	     * This year-month instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * YearMonth added = ym.plusYears(6);	     * YearMonth added = ym.plus(Period.years(6));	     * YearMonth added = ym.withFieldAdded(DurationFieldType.years(), 6);	     * </pre>	     *	     * @param years  the amount of years to add, may be negative	     * @return the new year-month plus the increased years, never null	     */	    public YearMonth plusYears(int years) {	        return withFieldAdded(DurationFieldType.years(), years);	    }	
/**	     * Returns a copy of this year-month plus the specified number of months.	     * <p>	     * This year-month instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * YearMonth added = ym.plusMonths(6);	     * YearMonth added = ym.plus(Period.months(6));	     * YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6);	     * </pre>	     *	     * @param months  the amount of months to add, may be negative	     * @return the new year-month plus the increased months, never null	     */	    public YearMonth plusMonths(int months) {	        return withFieldAdded(DurationFieldType.months(), months);	    }	
/**	     * Returns a copy of this year-month with the specified period taken away.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * <p>	     * This method is typically used to subtract complex period instances.	     * Subtracting one field is best achieved using methods	     * like {@link #minusYears(int)}.	     * 	     * @param period  the period to reduce this instant by	     * @return a copy of this instance with the period taken away, never null	     * @throws ArithmeticException if the new year-month exceeds the capacity	     */	    public YearMonth minus(ReadablePeriod period) {	        return withPeriodAdded(period, -1);	    }	
/**	     * Returns a copy of this year-month minus the specified number of years.	     * <p>	     * This year-month instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * YearMonth subtracted = ym.minusYears(6);	     * YearMonth subtracted = ym.minus(Period.years(6));	     * YearMonth subtracted = ym.withFieldAdded(DurationFieldType.years(), -6);	     * </pre>	     *	     * @param years  the amount of years to subtract, may be negative	     * @return the new year-month minus the increased years, never null	     */	    public YearMonth minusYears(int years) {	        return withFieldAdded(DurationFieldType.years(), FieldUtils.safeNegate(years));	    }	
/**	     * Returns a copy of this year-month minus the specified number of months.	     * <p>	     * This year-month instance is immutable and unaffected by this method call.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * YearMonth subtracted = ym.minusMonths(6);	     * YearMonth subtracted = ym.minus(Period.months(6));	     * YearMonth subtracted = ym.withFieldAdded(DurationFieldType.months(), -6);	     * </pre>	     *	     * @param months  the amount of months to subtract, may be negative	     * @return the new year-month minus the increased months, never null	     */	    public YearMonth minusMonths(int months) {	        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));	    }	
/**	     * Converts this object to a LocalDate with the same year-month and chronology.	     *	     * @param dayOfMonth the day of month to use, valid for chronology, such as 1-31 for ISO	     * @return a LocalDate with the same year-month and chronology, never null	     */	    public LocalDate toLocalDate(int dayOfMonth) {	        return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology());	    }	
/**	     * Converts this object to an Interval representing the whole month.	     * <p>	     * The interval will use the chronology of the year-month in the default zone.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @return an interval over the month, never null	     */	    public Interval toInterval() {	        return toInterval(null);	    }	
/**	     * Converts this object to an Interval representing the whole month.	     * <p>	     * The interval will use the chronology of the year-month in the specified zone.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param zone  the zone to get the Interval in, null means default	     * @return an interval over the month, never null	     */	    public Interval toInterval(DateTimeZone zone) {	        zone = DateTimeUtils.getZone(zone);	        DateTime start = toLocalDate(1).toDateTimeAtStartOfDay(zone);	        DateTime end = plusMonths(1).toLocalDate(1).toDateTimeAtStartOfDay(zone);	        return new Interval(start, end);	    }	
/**	     * Get the year field value.	     *	     * @return the year	     */	    public int getYear() {	        return getValue(YEAR);	    }	
/**	     * Get the month of year field value.	     *	     * @return the month of year	     */	    public int getMonthOfYear() {	        return getValue(MONTH_OF_YEAR);	    }	
/**	     * Returns a copy of this year-month with the year field updated.	     * <p>	     * YearMonth is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * year changed.	     *	     * @param year  the year to set	     * @return a copy of this object with the field set, never null	     * @throws IllegalArgumentException if the value is invalid	     */	    public YearMonth withYear(int year) {	        int[] newValues = getValues();	        newValues = getChronology().year().set(this, YEAR, newValues, year);	        return new YearMonth(this, newValues);	    }	
/**	     * Returns a copy of this year-month with the month of year field updated.	     * <p>	     * YearMonth is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * month of year changed.	     *	     * @param monthOfYear  the month of year to set	     * @return a copy of this object with the field set, never null	     * @throws IllegalArgumentException if the value is invalid	     */	    public YearMonth withMonthOfYear(int monthOfYear) {	        int[] newValues = getValues();	        newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);	        return new YearMonth(this, newValues);	    }	
/**	     * Gets the property object for the specified type, which contains	     * many useful methods.	     *	     * @param type  the field type to get the property for	     * @return the property object	     * @throws IllegalArgumentException if the field is null or unsupported	     */	    public Property property(DateTimeFieldType type) {	        return new Property(this, indexOfSupported(type));	    }	
/**	     * Get the year field property which provides access to advanced functionality.	     * 	     * @return the year property	     */	    public Property year() {	        return new Property(this, YEAR);	    }	
/**	     * Get the month of year field property which provides access to advanced functionality.	     * 	     * @return the month of year property	     */	    public Property monthOfYear() {	        return new Property(this, MONTH_OF_YEAR);	    }	
/**	     * Output the year-month in ISO8601 format (yyyy-MM).	     *	     * @return ISO8601 time formatted string.	     */	    @ToString	    public String toString() {	        return ISODateTimeFormat.yearMonth().print(this);	    }	
/**	     * Output the year-month using the specified format pattern.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @see org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern) {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).print(this);	    }	
/**	     * Output the year-month using the specified format pattern.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @param locale  Locale to use, null means default	     * @see org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern, Locale locale) throws IllegalArgumentException {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);	    }	
/**	         * Constructs a property.	         * 	         * @param partial  the partial instance	         * @param fieldIndex  the index in the partial	         */	        Property(YearMonth partial, int fieldIndex) {	            super();	            iBase = partial;	            iFieldIndex = fieldIndex;	        }	
/**	         * Gets the field that this property uses.	         * 	         * @return the field	         */	        public DateTimeField getField() {	            return iBase.getField(iFieldIndex);	        }	
/**	         * Gets the partial that this property belongs to.	         * 	         * @return the partial	         */	        protected ReadablePartial getReadablePartial() {	            return iBase;	        }	
/**	         * Gets the partial that this property belongs to.	         * 	         * @return the partial	         */	        public YearMonth getYearMonth() {	            return iBase;	        }	
/**	         * Gets the value of this field.	         * 	         * @return the field value	         */	        public int get() {	            return iBase.getValue(iFieldIndex);	        }	
/**	         * Adds to the value of this field in a copy of this YearMonth.	         * <p>	         * The value will be added to this field. If the value is too large to be	         * added solely to this field then it will affect larger fields.	         * Smaller fields are unaffected.	         * <p>	         * If the result would be too large, beyond the maximum year, then an	         * IllegalArgumentException is thrown.	         * <p>	         * The YearMonth attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param valueToAdd  the value to add to the field in the copy	         * @return a copy of the YearMonth with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public YearMonth addToCopy(int valueToAdd) {	            int[] newValues = iBase.getValues();	            newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd);	            return new YearMonth(iBase, newValues);	        }	
/**	         * Adds to the value of this field in a copy of this YearMonth wrapping	         * within this field if the maximum value is reached.	         * <p>	         * The value will be added to this field. If the value is too large to be	         * added solely to this field then it wraps within this field.	         * Other fields are unaffected.	         * <p>	         * For example,	         * <code>2004-12</code> addWrapField one month returns <code>2004-01</code>.	         * <p>	         * The YearMonth attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param valueToAdd  the value to add to the field in the copy	         * @return a copy of the YearMonth with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public YearMonth addWrapFieldToCopy(int valueToAdd) {	            int[] newValues = iBase.getValues();	            newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd);	            return new YearMonth(iBase, newValues);	        }	
/**	         * Sets this field in a copy of the YearMonth.	         * <p>	         * The YearMonth attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param value  the value to set the field in the copy to	         * @return a copy of the YearMonth with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public YearMonth setCopy(int value) {	            int[] newValues = iBase.getValues();	            newValues = getField().set(iBase, iFieldIndex, newValues, value);	            return new YearMonth(iBase, newValues);	        }	
/**	         * Sets this field in a copy of the YearMonth to a parsed text value.	         * <p>	         * The YearMonth attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param text  the text value to set	         * @param locale  optional locale to use for selecting a text symbol	         * @return a copy of the YearMonth with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public YearMonth setCopy(String text, Locale locale) {	            int[] newValues = iBase.getValues();	            newValues = getField().set(iBase, iFieldIndex, newValues, text, locale);	            return new YearMonth(iBase, newValues);	        }	
/**	         * Sets this field in a copy of the YearMonth to a parsed text value.	         * <p>	         * The YearMonth attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param text  the text value to set	         * @return a copy of the YearMonth with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public YearMonth setCopy(String text) {	            return setCopy(text, null);	        }	
/**	     * Constructor.	     * 	     * @param name  the name to use, which by convention, are plural.	     */	    protected DurationFieldType(String name) {	        super();	        iName = name;	    }	
/**	     * Get the millis field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DurationFieldType millis() {	        return MILLIS_TYPE;	    }	
/**	     * Get the seconds field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DurationFieldType seconds() {	        return SECONDS_TYPE;	    }	
/**	     * Get the minutes field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DurationFieldType minutes() {	        return MINUTES_TYPE;	    }	
/**	     * Get the hours field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DurationFieldType hours() {	        return HOURS_TYPE;	    }	
/**	     * Get the halfdays field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DurationFieldType halfdays() {	        return HALFDAYS_TYPE;	    }	
/**	     * Get the days field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DurationFieldType days() {	        return DAYS_TYPE;	    }	
/**	     * Get the weeks field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DurationFieldType weeks() {	        return WEEKS_TYPE;	    }	
/**	     * Get the weekyears field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DurationFieldType weekyears() {	        return WEEKYEARS_TYPE;	    }	
/**	     * Get the months field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DurationFieldType months() {	        return MONTHS_TYPE;	    }	
/**	     * Get the years field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DurationFieldType years() {	        return YEARS_TYPE;	    }	
/**	     * Get the centuries field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DurationFieldType centuries() {	        return CENTURIES_TYPE;	    }	
/**	     * Get the eras field type.	     * 	     * @return the DateTimeFieldType constant	     */	    public static DurationFieldType eras() {	        return ERAS_TYPE;	    }	
/**	     * Get the name of the field.	     * By convention, names are plural.	     * 	     * @return field name	     */	    public String getName() {	        return iName;	    }	
/**	     * Checks whether this field supported in the given Chronology.	     *	     * @param chronology  the chronology to use, null means ISOChronology in default zone	     * @return true if supported	     */	    public boolean isSupported(Chronology chronology) {	        return getField(chronology).isSupported();	    }	
/**	     * Get a suitable debug string.	     * 	     * @return debug string	     */	    public String toString() {	        return getName();	    }	
/**	         * Constructor.	         * 	         * @param name  the name to use	         */	        StandardDurationFieldType(String name, byte ordinal) {	            super(name);	            iOrdinal = ordinal;	        }	
public DurationField getField(Chronology chronology) {	            chronology = DateTimeUtils.getChronology(chronology);	            	            switch (iOrdinal) {	                case ERAS:	                    return chronology.eras();	                case CENTURIES:	                    return chronology.centuries();	                case WEEKYEARS:	                    return chronology.weekyears();	                case YEARS:	                    return chronology.years();	                case MONTHS:	                    return chronology.months();	                case WEEKS:	                    return chronology.weeks();	                case DAYS:	                    return chronology.days();	                case HALFDAYS:	                    return chronology.halfdays();	                case HOURS:	                    return chronology.hours();	                case MINUTES:	                    return chronology.minutes();	                case SECONDS:	                    return chronology.seconds();	                case MILLIS:	                    return chronology.millis();	                default:	                    // Shouldn't happen.	                    throw new InternalError();	            }	        }	
/**	         * Ensure a singleton is returned.	         * 	         * @return the singleton type	         */	        private Object readResolve() {	            switch (iOrdinal) {	                case ERAS:	                    return ERAS_TYPE;	                case CENTURIES:	                    return CENTURIES_TYPE;	                case WEEKYEARS:	                    return WEEKYEARS_TYPE;	                case YEARS:	                    return YEARS_TYPE;	                case MONTHS:	                    return MONTHS_TYPE;	                case WEEKS:	                    return WEEKS_TYPE;	                case DAYS:	                    return DAYS_TYPE;	                case HALFDAYS:	                    return HALFDAYS_TYPE;	                case HOURS:	                    return HOURS_TYPE;	                case MINUTES:	                    return MINUTES_TYPE;	                case SECONDS:	                    return SECONDS_TYPE;	                case MILLIS:	                    return MILLIS_TYPE;	                default:	                    // Shouldn't happen.	                    return this;	            }	        }	
/**	     * Parses a {@code Period} from the specified string.	     * <p>	     * This uses {@link ISOPeriodFormat#standard()}.	     * 	     * @param str  the string to parse, not null	     * @since 2.0	     */	    @FromString	    public static Period parse(String str) {	        return parse(str, ISOPeriodFormat.standard());	    }	
/**	     * Parses a {@code Period} from the specified string using a formatter.	     * 	     * @param str  the string to parse, not null	     * @param formatter  the formatter to use, not null	     * @since 2.0	     */	    public static Period parse(String str, PeriodFormatter formatter) {	        return formatter.parsePeriod(str);	    }	
/**	     * Create a period with a specified number of years.	     * <p>	     * The standard period type is used, thus you can add other fields such	     * as months or days using the <code>withXxx()</code> methods.	     * For example, <code>Period.years(2).withMonths(6);</code>	     * <p>	     * If you want a year-based period that cannot have other fields added,	     * then you should consider using {@link Years}.	     *	     * @param years  the amount of years in this period	     * @return the period	     */	    public static Period years(int years) {	        return new Period(new int[] {years, 0, 0, 0, 0, 0, 0, 0, 0}, PeriodType.standard());	    }	
/**	     * Create a period with a specified number of months.	     * <p>	     * The standard period type is used, thus you can add other fields such	     * as years or days using the <code>withXxx()</code> methods.	     * For example, <code>Period.months(2).withDays(6);</code>	     * <p>	     * If you want a month-based period that cannot have other fields added,	     * then you should consider using {@link Months}.	     *	     * @param months  the amount of months in this period	     * @return the period	     */	    public static Period months(int months) {	        return new Period(new int[] {0, months, 0, 0, 0, 0, 0, 0}, PeriodType.standard());	    }	
/**	     * Create a period with a specified number of weeks.	     * <p>	     * The standard period type is used, thus you can add other fields such	     * as months or days using the <code>withXxx()</code> methods.	     * For example, <code>Period.weeks(2).withDays(6);</code>	     * <p>	     * If you want a week-based period that cannot have other fields added,	     * then you should consider using {@link Weeks}.	     *	     * @param weeks  the amount of weeks in this period	     * @return the period	     */	    public static Period weeks(int weeks) {	        return new Period(new int[] {0, 0, weeks, 0, 0, 0, 0, 0}, PeriodType.standard());	    }	
/**	     * Create a period with a specified number of days.	     * <p>	     * The standard period type is used, thus you can add other fields such	     * as months or weeks using the <code>withXxx()</code> methods.	     * For example, <code>Period.days(2).withHours(6);</code>	     * <p>	     * If you want a day-based period that cannot have other fields added,	     * then you should consider using {@link Days}.	     *	     * @param days  the amount of days in this period	     * @return the period	     */	    public static Period days(int days) {	        return new Period(new int[] {0, 0, 0, days, 0, 0, 0, 0}, PeriodType.standard());	    }	
/**	     * Create a period with a specified number of hours.	     * <p>	     * The standard period type is used, thus you can add other fields such	     * as months or days using the <code>withXxx()</code> methods.	     * For example, <code>Period.hours(2).withMinutes(30);</code>	     * <p>	     * If you want a hour-based period that cannot have other fields added,	     * then you should consider using {@link Hours}.	     *	     * @param hours  the amount of hours in this period	     * @return the period	     */	    public static Period hours(int hours) {	        return new Period(new int[] {0, 0, 0, 0, hours, 0, 0, 0}, PeriodType.standard());	    }	
/**	     * Create a period with a specified number of minutes.	     * <p>	     * The standard period type is used, thus you can add other fields such	     * as days or hours using the <code>withXxx()</code> methods.	     * For example, <code>Period.minutes(2).withSeconds(30);</code>	     * <p>	     * If you want a minute-based period that cannot have other fields added,	     * then you should consider using {@link Minutes}.	     *	     * @param minutes  the amount of minutes in this period	     * @return the period	     */	    public static Period minutes(int minutes) {	        return new Period(new int[] {0, 0, 0, 0, 0, minutes, 0, 0}, PeriodType.standard());	    }	
/**	     * Create a period with a specified number of seconds.	     * <p>	     * The standard period type is used, thus you can add other fields such	     * as days or hours using the <code>withXxx()</code> methods.	     * For example, <code>Period.seconds(2).withMillis(30);</code>	     * <p>	     * If you want a second-based period that cannot have other fields added,	     * then you should consider using {@link Seconds}.	     *	     * @param seconds  the amount of seconds in this period	     * @return the period	     */	    public static Period seconds(int seconds) {	        return new Period(new int[] {0, 0, 0, 0, 0, 0, seconds, 0}, PeriodType.standard());	    }	
/**	     * Create a period with a specified number of millis.	     * <p>	     * The standard period type is used, thus you can add other fields such	     * as days or hours using the <code>withXxx()</code> methods.	     * For example, <code>Period.millis(20).withSeconds(30);</code>	     *	     * @param millis  the amount of millis in this period	     * @return the period	     */	    public static Period millis(int millis) {	        return new Period(new int[] {0, 0, 0, 0, 0, 0, 0, millis}, PeriodType.standard());	    }	
/**	     * Creates a period from two partially specified times, calculating	     * by field difference.	     * <p>	     * The two partials must contain the same fields, thus you can specify	     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,	     * but not one of each. Also, the partial may not contain overlapping	     * fields, such as dayOfWeek and dayOfMonth.	     * <p>	     * Calculation by field difference works by extracting the difference	     * one field at a time and not wrapping into other fields.	     * Thus 2005-06-09/2007-04-12 will yield P1Y-2M3D.	     * <p>	     * For example, you have an event that always runs from the 27th of	     * each month to the 2nd of the next month. If you calculate this	     * period using a standard constructor, then you will get between	     * P3D and P6D depending on the month. If you use this method, then	     * you will get P1M-25D. This field-difference based period can	     * be successfully applied to each month of the year to obtain the	     * correct end date for a given start date.	     *	     * @param start  the start of the period, must not be null	     * @param end  the end of the period, must not be null	     * @throws IllegalArgumentException if the partials are null or invalid	     * @since 1.1	     */	    public static Period fieldDifference(ReadablePartial start, ReadablePartial end) {	        if (start == null || end == null) {	            throw new IllegalArgumentException("ReadablePartial objects must not be null");	        }	        if (start.size() != end.size()) {	            throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields");	        }	        DurationFieldType[] types = new DurationFieldType[start.size()];	        int[] values = new int[start.size()];	        for (int i = 0, isize = start.size(); i < isize; i++) {	            if (start.getFieldType(i) != end.getFieldType(i)) {	                throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields");	            }	            types[i] = start.getFieldType(i).getDurationType();	            if (i > 0 && types[i - 1] == types[i]) {	                throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields");	            }	            values[i] = end.getValue(i) - start.getValue(i);	        }	        return new Period(values, PeriodType.forFields(types));	    }	
/**	     * Creates a new empty period with the standard set of fields.	     * <p>	     * One way to initialise a period is as follows:	     * <pre>	     * Period = new Period().withYears(6).withMonths(3).withSeconds(23);	     * </pre>	     * Bear in mind that this creates four period instances in total, three of	     * which are immediately discarded.	     * The alterative is more efficient, but less readable:	     * <pre>	     * Period = new Period(6, 3, 0, 0, 0, 0, 23, 0);	     * </pre>	     * The following is also slightly less wasteful:	     * <pre>	     * Period = Period.years(6).withMonths(3).withSeconds(23);	     * </pre>	     */	    public Period() {	        super(0L, null, null);	    }	
/**	     * Create a period from a set of field values using the standard set of fields.	     * Note that the parameters specify the time fields hours, minutes,	     * seconds and millis, not the date fields.	     *	     * @param hours  amount of hours in this period	     * @param minutes  amount of minutes in this period	     * @param seconds  amount of seconds in this period	     * @param millis  amount of milliseconds in this period	     */	    public Period(int hours, int minutes, int seconds, int millis) {	        super(0, 0, 0, 0, hours, minutes, seconds, millis, PeriodType.standard());	    }	
/**	     * Create a period from a set of field values using the standard set of fields.	     *	     * @param years  amount of years in this period	     * @param months  amount of months in this period	     * @param weeks  amount of weeks in this period	     * @param days  amount of days in this period	     * @param hours  amount of hours in this period	     * @param minutes  amount of minutes in this period	     * @param seconds  amount of seconds in this period	     * @param millis  amount of milliseconds in this period	     */	    public Period(int years, int months, int weeks, int days,	                  int hours, int minutes, int seconds, int millis) {	        super(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());	    }	
/**	     * Create a period from a set of field values.	     * <p>	     * There is usually little need to use this constructor.	     * The period type is used primarily to define how to split an interval into a period.	     * As this constructor already is split, the period type does no real work.	     *	     * @param years  amount of years in this period, which must be zero if unsupported	     * @param months  amount of months in this period, which must be zero if unsupported	     * @param weeks  amount of weeks in this period, which must be zero if unsupported	     * @param days  amount of days in this period, which must be zero if unsupported	     * @param hours  amount of hours in this period, which must be zero if unsupported	     * @param minutes  amount of minutes in this period, which must be zero if unsupported	     * @param seconds  amount of seconds in this period, which must be zero if unsupported	     * @param millis  amount of milliseconds in this period, which must be zero if unsupported	     * @param type  which set of fields this period supports, null means AllType	     * @throws IllegalArgumentException if an unsupported field's value is non-zero	     */	    public Period(int years, int months, int weeks, int days,	                    int hours, int minutes, int seconds, int millis, PeriodType type) {	        super(years, months, weeks, days, hours, minutes, seconds, millis, type);	    }	
/**	     * Creates a period from the given millisecond duration using the standard	     * set of fields.	     * <p>	     * Only precise fields in the period type will be used.	     * For the standard period type this is the time fields only.	     * Thus the year, month, week and day fields will not be populated.	     * <p>	     * If the duration is small, less than one day, then this method will perform	     * as you might expect and split the fields evenly.	     * <p>	     * If the duration is larger than one day then all the remaining duration will	     * be stored in the largest available precise field, hours in this case.	     * <p>	     * For example, a duration equal to (365 + 60 + 5) days will be converted to	     * ((365 + 60 + 5) * 24) hours by this constructor.	     * <p>	     * For more control over the conversion process, you have two options:	     * <ul>	     * <li>convert the duration to an {@link Interval}, and from there obtain the period	     * <li>specify a period type that contains precise definitions of the day and larger	     * fields, such as UTC	     * </ul>	     *	     * @param duration  the duration, in milliseconds	     */	    public Period(long duration) {	        super(duration, null, null);	    }	
/**	     * Creates a period from the given millisecond duration.	     * <p>	     * Only precise fields in the period type will be used.	     * Imprecise fields will not be populated.	     * <p>	     * If the duration is small then this method will perform	     * as you might expect and split the fields evenly.	     * <p>	     * If the duration is large then all the remaining duration will	     * be stored in the largest available precise field.	     * For details as to which fields are precise, review the period type javadoc.	     *	     * @param duration  the duration, in milliseconds	     * @param type  which set of fields this period supports, null means standard	     */	    public Period(long duration, PeriodType type) {	        super(duration, type, null);	    }	
/**	     * Creates a period from the given millisecond duration using the standard	     * set of fields.	     * <p>	     * Only precise fields in the period type will be used.	     * Imprecise fields will not be populated.	     * <p>	     * If the duration is small then this method will perform	     * as you might expect and split the fields evenly.	     * <p>	     * If the duration is large then all the remaining duration will	     * be stored in the largest available precise field.	     * For details as to which fields are precise, review the period type javadoc.	     *	     * @param duration  the duration, in milliseconds	     * @param chronology  the chronology to use to split the duration, null means ISO default	     */	    public Period(long duration, Chronology chronology) {	        super(duration, null, chronology);	    }	
/**	     * Creates a period from the given millisecond duration.	     * <p>	     * Only precise fields in the period type will be used.	     * Imprecise fields will not be populated.	     * <p>	     * If the duration is small then this method will perform	     * as you might expect and split the fields evenly.	     * <p>	     * If the duration is large then all the remaining duration will	     * be stored in the largest available precise field.	     * For details as to which fields are precise, review the period type javadoc.	     *	     * @param duration  the duration, in milliseconds	     * @param type  which set of fields this period supports, null means standard	     * @param chronology  the chronology to use to split the duration, null means ISO default	     */	    public Period(long duration, PeriodType type, Chronology chronology) {	        super(duration, type, chronology);	    }	
/**	     * Creates a period from the given interval endpoints using the standard	     * set of fields.	     *	     * @param startInstant  interval start, in milliseconds	     * @param endInstant  interval end, in milliseconds	     */	    public Period(long startInstant, long endInstant) {	        super(startInstant, endInstant, null, null);	    }	
/**	     * Creates a period from the given interval endpoints.	     *	     * @param startInstant  interval start, in milliseconds	     * @param endInstant  interval end, in milliseconds	     * @param type  which set of fields this period supports, null means standard	     */	    public Period(long startInstant, long endInstant, PeriodType type) {	        super(startInstant, endInstant, type, null);	    }	
/**	     * Creates a period from the given interval endpoints using the standard	     * set of fields.	     *	     * @param startInstant  interval start, in milliseconds	     * @param endInstant  interval end, in milliseconds	     * @param chrono  the chronology to use, null means ISO in default zone	     */	    public Period(long startInstant, long endInstant, Chronology chrono) {	        super(startInstant, endInstant, null, chrono);	    }	
/**	     * Creates a period from the given interval endpoints.	     *	     * @param startInstant  interval start, in milliseconds	     * @param endInstant  interval end, in milliseconds	     * @param type  which set of fields this period supports, null means standard	     * @param chrono  the chronology to use, null means ISO in default zone	     */	    public Period(long startInstant, long endInstant, PeriodType type, Chronology chrono) {	        super(startInstant, endInstant, type, chrono);	    }	
/**	     * Creates a period from the given interval endpoints using the standard	     * set of fields.	     *	     * @param startInstant  interval start, null means now	     * @param endInstant  interval end, null means now	     */	    public Period(ReadableInstant startInstant, ReadableInstant endInstant) {	        super(startInstant, endInstant, null);	    }	
/**	     * Creates a period from the given interval endpoints.	     *	     * @param startInstant  interval start, null means now	     * @param endInstant  interval end, null means now	     * @param type  which set of fields this period supports, null means standard	     */	    public Period(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {	        super(startInstant, endInstant, type);	    }	
/**	     * Creates a period from two partially specified times.	     * <p>	     * The two partials must contain the same fields, thus you can specify	     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,	     * but not one of each.	     * As these are Partial objects, time zones have no effect on the result.	     * <p>	     * The two partials must also both be contiguous - see	     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.	     * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.	     * <p>	     * An alternative way of constructing a Period from two Partials	     * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.	     * That method handles all kinds of partials.	     *	     * @param start  the start of the period, must not be null	     * @param end  the end of the period, must not be null	     * @throws IllegalArgumentException if the partials are null or invalid	     * @since 1.1	     */	    public Period(ReadablePartial start, ReadablePartial end) {	        super(start, end, null);	    }	
/**	     * Creates a period from two partially specified times.	     * <p>	     * The two partials must contain the same fields, thus you can specify	     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,	     * but not one of each.	     * As these are Partial objects, time zones have no effect on the result.	     * <p>	     * The two partials must also both be contiguous - see	     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.	     * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.	     * <p>	     * An alternative way of constructing a Period from two Partials	     * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.	     * That method handles all kinds of partials.	     *	     * @param start  the start of the period, must not be null	     * @param end  the end of the period, must not be null	     * @param type  which set of fields this period supports, null means standard	     * @throws IllegalArgumentException if the partials are null or invalid	     * @since 1.1	     */	    public Period(ReadablePartial start, ReadablePartial end, PeriodType type) {	        super(start, end, type);	    }	
/**	     * Creates a period from the given start point and the duration.	     *	     * @param startInstant  the interval start, null means now	     * @param duration  the duration of the interval, null means zero-length	     */	    public Period(ReadableInstant startInstant, ReadableDuration duration) {	        super(startInstant, duration, null);	    }	
/**	     * Creates a period from the given start point and the duration.	     *	     * @param startInstant  the interval start, null means now	     * @param duration  the duration of the interval, null means zero-length	     * @param type  which set of fields this period supports, null means standard	     */	    public Period(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {	        super(startInstant, duration, type);	    }	
/**	     * Creates a period from the given duration and end point.	     *	     * @param duration  the duration of the interval, null means zero-length	     * @param endInstant  the interval end, null means now	     */	    public Period(ReadableDuration duration, ReadableInstant endInstant) {	        super(duration, endInstant, null);	    }	
/**	     * Creates a period from the given duration and end point.	     *	     * @param duration  the duration of the interval, null means zero-length	     * @param endInstant  the interval end, null means now	     * @param type  which set of fields this period supports, null means standard	     */	    public Period(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {	        super(duration, endInstant, type);	    }	
/**	     * Creates a period by converting or copying from another object.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePeriod, ReadableInterval and String.	     * The String formats are described by {@link ISOPeriodFormat#standard()}.	     *	     * @param period  period to convert	     * @throws IllegalArgumentException if period is invalid	     * @throws UnsupportedOperationException if an unsupported field's value is non-zero	     */	    public Period(Object period) {	        super(period, null, null);	    }	
/**	     * Creates a period by converting or copying from another object.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePeriod, ReadableInterval and String.	     * The String formats are described by {@link ISOPeriodFormat#standard()}.	     *	     * @param period  period to convert	     * @param type  which set of fields this period supports, null means use converter	     * @throws IllegalArgumentException if period is invalid	     * @throws UnsupportedOperationException if an unsupported field's value is non-zero	     */	    public Period(Object period, PeriodType type) {	        super(period, type, null);	    }	
/**	     * Creates a period by converting or copying from another object.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePeriod, ReadableInterval and String.	     * The String formats are described by {@link ISOPeriodFormat#standard()}.	     *	     * @param period  period to convert	     * @param chrono  the chronology to use, null means ISO in default zone	     * @throws IllegalArgumentException if period is invalid	     * @throws UnsupportedOperationException if an unsupported field's value is non-zero	     */	    public Period(Object period, Chronology chrono) {	        super(period, null, chrono);	    }	
/**	     * Creates a period by converting or copying from another object.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadablePeriod, ReadableInterval and String.	     * The String formats are described by {@link ISOPeriodFormat#standard()}.	     *	     * @param period  period to convert	     * @param type  which set of fields this period supports, null means use converter	     * @param chrono  the chronology to use, null means ISO in default zone	     * @throws IllegalArgumentException if period is invalid	     * @throws UnsupportedOperationException if an unsupported field's value is non-zero	     */	    public Period(Object period, PeriodType type, Chronology chrono) {	        super(period, type, chrono);	    }	
/**	     * Constructor used when we trust ourselves.	     *	     * @param values  the values to use, not null, not cloned	     * @param type  which set of fields this period supports, not null	     */	    private Period(int[] values, PeriodType type) {	        super(values, type);	    }	
/**	     * Get this period as an immutable <code>Period</code> object	     * by returning <code>this</code>.	     * 	     * @return <code>this</code>	     */	    public Period toPeriod() {	        return this;	    }	
/**	     * Gets the years field part of the period.	     * 	     * @return the number of years in the period, zero if unsupported	     */	    public int getYears() {	        return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);	    }	
/**	     * Gets the months field part of the period.	     * 	     * @return the number of months in the period, zero if unsupported	     */	    public int getMonths() {	        return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);	    }	
/**	     * Gets the weeks field part of the period.	     * 	     * @return the number of weeks in the period, zero if unsupported	     */	    public int getWeeks() {	        return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);	    }	
/**	     * Gets the days field part of the period.	     * 	     * @return the number of days in the period, zero if unsupported	     */	    public int getDays() {	        return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);	    }	
/**	     * Gets the hours field part of the period.	     * 	     * @return the number of hours in the period, zero if unsupported	     */	    public int getHours() {	        return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);	    }	
/**	     * Gets the minutes field part of the period.	     * 	     * @return the number of minutes in the period, zero if unsupported	     */	    public int getMinutes() {	        return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);	    }	
/**	     * Gets the seconds field part of the period.	     * 	     * @return the number of seconds in the period, zero if unsupported	     */	    public int getSeconds() {	        return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);	    }	
/**	     * Gets the millis field part of the period.	     * 	     * @return the number of millis in the period, zero if unsupported	     */	    public int getMillis() {	        return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);	    }	
/**	     * Creates a new Period instance with the same field values but	     * different PeriodType.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     * 	     * @param type  the period type to use, null means standard	     * @return the new period instance	     * @throws IllegalArgumentException if the new period won't accept all of the current fields	     */	    public Period withPeriodType(PeriodType type) {	        type = DateTimeUtils.getPeriodType(type);	        if (type.equals(getPeriodType())) {	            return this;	        }	        return new Period(this, type);	    }	
/**	     * Creates a new Period instance with the fields from the specified period	     * copied on top of those from this period.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     * 	     * @param period  the period to copy from, null ignored	     * @return the new period instance	     * @throws IllegalArgumentException if a field type is unsupported	     */	    public Period withFields(ReadablePeriod period) {	        if (period == null) {	            return this;	        }	        int[] newValues = getValues();  // cloned	        newValues = super.mergePeriodInto(newValues, period);	        return new Period(newValues, getPeriodType());	    }	
/**	     * Creates a new Period instance with the specified field set to a new value.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     * 	     * @param field  the field to set, not null	     * @param value  the value to set to	     * @return the new period instance	     * @throws IllegalArgumentException if the field type is null or unsupported	     */	    public Period withField(DurationFieldType field, int value) {	        if (field == null) {	            throw new IllegalArgumentException("Field must not be null");	        }	        int[] newValues = getValues();  // cloned	        super.setFieldInto(newValues, field, value);	        return new Period(newValues, getPeriodType());	    }	
/**	     * Creates a new Period instance with the valueToAdd added to the specified field.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     * 	     * @param field  the field to set, not null	     * @param value  the value to add	     * @return the new period instance	     * @throws IllegalArgumentException if the field type is null or unsupported	     */	    public Period withFieldAdded(DurationFieldType field, int value) {	        if (field == null) {	            throw new IllegalArgumentException("Field must not be null");	        }	        if (value == 0) {	            return this;	        }	        int[] newValues = getValues();  // cloned	        super.addFieldInto(newValues, field, value);	        return new Period(newValues, getPeriodType());	    }	
/**	     * Returns a new period with the specified number of years.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param years  the amount of years to add, may be negative	     * @return the new period with the increased years	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period withYears(int years) {	        int[] values = getValues();  // cloned	        getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period with the specified number of months.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param months  the amount of months to add, may be negative	     * @return the new period with the increased months	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period withMonths(int months) {	        int[] values = getValues();  // cloned	        getPeriodType().setIndexedField(this, PeriodType.MONTH_INDEX, values, months);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period with the specified number of weeks.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param weeks  the amount of weeks to add, may be negative	     * @return the new period with the increased weeks	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period withWeeks(int weeks) {	        int[] values = getValues();  // cloned	        getPeriodType().setIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period with the specified number of days.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param days  the amount of days to add, may be negative	     * @return the new period with the increased days	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period withDays(int days) {	        int[] values = getValues();  // cloned	        getPeriodType().setIndexedField(this, PeriodType.DAY_INDEX, values, days);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period with the specified number of hours.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param hours  the amount of hours to add, may be negative	     * @return the new period with the increased hours	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period withHours(int hours) {	        int[] values = getValues();  // cloned	        getPeriodType().setIndexedField(this, PeriodType.HOUR_INDEX, values, hours);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period with the specified number of minutes.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param minutes  the amount of minutes to add, may be negative	     * @return the new period with the increased minutes	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period withMinutes(int minutes) {	        int[] values = getValues();  // cloned	        getPeriodType().setIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period with the specified number of seconds.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param seconds  the amount of seconds to add, may be negative	     * @return the new period with the increased seconds	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period withSeconds(int seconds) {	        int[] values = getValues();  // cloned	        getPeriodType().setIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period with the specified number of millis.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param millis  the amount of millis to add, may be negative	     * @return the new period with the increased millis	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period withMillis(int millis) {	        int[] values = getValues();  // cloned	        getPeriodType().setIndexedField(this, PeriodType.MILLI_INDEX, values, millis);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period with the specified period added.	     * <p>	     * Each field of the period is added separately. Thus a period of	     * 2 hours 30 minutes plus 3 hours 40 minutes will produce a result	     * of 5 hours 70 minutes - see {@link #normalizedStandard()}.	     * <p>	     * If the period being added contains a non-zero amount for a field that	     * is not supported in this period then an exception is thrown.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param period  the period to add, null adds zero and returns this	     * @return the new updated period	     * @throws UnsupportedOperationException if any field is not supported	     * @since 1.5	     */	    public Period plus(ReadablePeriod period) {	        if (period == null) {	            return this;	        }	        int[] values = getValues();  // cloned	        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, period.get(DurationFieldType.YEARS_TYPE));	        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, period.get(DurationFieldType.MONTHS_TYPE));	        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, period.get(DurationFieldType.WEEKS_TYPE));	        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, period.get(DurationFieldType.DAYS_TYPE));	        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, period.get(DurationFieldType.HOURS_TYPE));	        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, period.get(DurationFieldType.MINUTES_TYPE));	        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, period.get(DurationFieldType.SECONDS_TYPE));	        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, period.get(DurationFieldType.MILLIS_TYPE));	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period with the specified number of years added.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param years  the amount of years to add, may be negative	     * @return the new period with the increased years	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period plusYears(int years) {	        if (years == 0) {	            return this;	        }	        int[] values = getValues();  // cloned	        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period plus the specified number of months added.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param months  the amount of months to add, may be negative	     * @return the new period plus the increased months	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period plusMonths(int months) {	        if (months == 0) {	            return this;	        }	        int[] values = getValues();  // cloned	        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, months);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period plus the specified number of weeks added.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param weeks  the amount of weeks to add, may be negative	     * @return the new period plus the increased weeks	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period plusWeeks(int weeks) {	        if (weeks == 0) {	            return this;	        }	        int[] values = getValues();  // cloned	        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period plus the specified number of days added.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param days  the amount of days to add, may be negative	     * @return the new period plus the increased days	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period plusDays(int days) {	        if (days == 0) {	            return this;	        }	        int[] values = getValues();  // cloned	        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period plus the specified number of hours added.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param hours  the amount of hours to add, may be negative	     * @return the new period plus the increased hours	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period plusHours(int hours) {	        if (hours == 0) {	            return this;	        }	        int[] values = getValues();  // cloned	        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period plus the specified number of minutes added.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param minutes  the amount of minutes to add, may be negative	     * @return the new period plus the increased minutes	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period plusMinutes(int minutes) {	        if (minutes == 0) {	            return this;	        }	        int[] values = getValues();  // cloned	        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period plus the specified number of seconds added.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param seconds  the amount of seconds to add, may be negative	     * @return the new period plus the increased seconds	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period plusSeconds(int seconds) {	        if (seconds == 0) {	            return this;	        }	        int[] values = getValues();  // cloned	        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period plus the specified number of millis added.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param millis  the amount of millis to add, may be negative	     * @return the new period plus the increased millis	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period plusMillis(int millis) {	        if (millis == 0) {	            return this;	        }	        int[] values = getValues();  // cloned	        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis);	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period with the specified period subtracted.	     * <p>	     * Each field of the period is subtracted separately. Thus a period of	     * 3 hours 30 minutes minus 2 hours 40 minutes will produce a result	     * of 1 hour and -10 minutes - see {@link #normalizedStandard()}.	     * <p>	     * If the period being added contains a non-zero amount for a field that	     * is not supported in this period then an exception is thrown.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param period  the period to add, null adds zero and returns this	     * @return the new updated period	     * @throws UnsupportedOperationException if any field is not supported	     * @since 1.5	     */	    public Period minus(ReadablePeriod period) {	        if (period == null) {	            return this;	        }	        int[] values = getValues();  // cloned	        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, -period.get(DurationFieldType.YEARS_TYPE));	        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, -period.get(DurationFieldType.MONTHS_TYPE));	        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, -period.get(DurationFieldType.WEEKS_TYPE));	        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, -period.get(DurationFieldType.DAYS_TYPE));	        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, -period.get(DurationFieldType.HOURS_TYPE));	        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, -period.get(DurationFieldType.MINUTES_TYPE));	        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, -period.get(DurationFieldType.SECONDS_TYPE));	        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, -period.get(DurationFieldType.MILLIS_TYPE));	        return new Period(values, getPeriodType());	    }	
/**	     * Returns a new period with the specified number of years taken away.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param years  the amount of years to take away, may be negative	     * @return the new period with the increased years	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period minusYears(int years) {	        return plusYears(-years);	    }	
/**	     * Returns a new period minus the specified number of months taken away.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param months  the amount of months to take away, may be negative	     * @return the new period minus the increased months	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period minusMonths(int months) {	        return plusMonths(-months);	    }	
/**	     * Returns a new period minus the specified number of weeks taken away.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param weeks  the amount of weeks to take away, may be negative	     * @return the new period minus the increased weeks	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period minusWeeks(int weeks) {	        return plusWeeks(-weeks);	    }	
/**	     * Returns a new period minus the specified number of days taken away.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param days  the amount of days to take away, may be negative	     * @return the new period minus the increased days	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period minusDays(int days) {	        return plusDays(-days);	    }	
/**	     * Returns a new period minus the specified number of hours taken away.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param hours  the amount of hours to take away, may be negative	     * @return the new period minus the increased hours	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period minusHours(int hours) {	        return plusHours(-hours);	    }	
/**	     * Returns a new period minus the specified number of minutes taken away.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param minutes  the amount of minutes to take away, may be negative	     * @return the new period minus the increased minutes	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period minusMinutes(int minutes) {	        return plusMinutes(-minutes);	    }	
/**	     * Returns a new period minus the specified number of seconds taken away.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param seconds  the amount of seconds to take away, may be negative	     * @return the new period minus the increased seconds	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period minusSeconds(int seconds) {	        return plusSeconds(-seconds);	    }	
/**	     * Returns a new period minus the specified number of millis taken away.	     * <p>	     * This period instance is immutable and unaffected by this method call.	     *	     * @param millis  the amount of millis to take away, may be negative	     * @return the new period minus the increased millis	     * @throws UnsupportedOperationException if the field is not supported	     */	    public Period minusMillis(int millis) {	        return plusMillis(-millis);	    }	
/**	     * Converts this period to a period in weeks assuming a	     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all	     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and	     * all minutes are 60 seconds. This is not true when daylight savings time	     * is considered, and may also not be true for some unusual chronologies.	     * However, it is included as it is a useful operation for many	     * applications and business rules.	     * <p>	     * If the period contains years or months, an exception will be thrown.	     * 	     * @return a period representing the number of standard weeks in this period	     * @throws UnsupportedOperationException if the period contains years or months	     * @throws ArithmeticException if the number of weeks is too large to be represented	     * @since 1.5	     */	    public Weeks toStandardWeeks() {	        checkYearsAndMonths("Weeks");	        long millis = getMillis();  // assign to a long	        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;	        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;	        millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;	        millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY;	        long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK;	        return Weeks.weeks(FieldUtils.safeToInt(weeks));	    }	
/**	     * Converts this period to a period in days assuming a	     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all	     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and	     * all minutes are 60 seconds. This is not true when daylight savings time	     * is considered, and may also not be true for some unusual chronologies.	     * However, it is included as it is a useful operation for many	     * applications and business rules.	     * <p>	     * If the period contains years or months, an exception will be thrown.	     * 	     * @return a period representing the number of standard days in this period	     * @throws UnsupportedOperationException if the period contains years or months	     * @throws ArithmeticException if the number of days is too large to be represented	     * @since 1.5	     */	    public Days toStandardDays() {	        checkYearsAndMonths("Days");	        long millis = getMillis();  // assign to a long	        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;	        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;	        millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;	        long days = millis / DateTimeConstants.MILLIS_PER_DAY;	        days = FieldUtils.safeAdd(days, getDays());	        days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK));	        return Days.days(FieldUtils.safeToInt(days));	    }	
/**	     * Converts this period to a period in hours assuming a	     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all	     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and	     * all minutes are 60 seconds. This is not true when daylight savings time	     * is considered, and may also not be true for some unusual chronologies.	     * However, it is included as it is a useful operation for many	     * applications and business rules.	     * <p>	     * If the period contains years or months, an exception will be thrown.	     * 	     * @return a period representing the number of standard hours in this period	     * @throws UnsupportedOperationException if the period contains years or months	     * @throws ArithmeticException if the number of hours is too large to be represented	     * @since 1.5	     */	    public Hours toStandardHours() {	        checkYearsAndMonths("Hours");	        long millis = getMillis();  // assign to a long	        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;	        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;	        long hours = millis / DateTimeConstants.MILLIS_PER_HOUR;	        hours = FieldUtils.safeAdd(hours, getHours());	        hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY));	        hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK));	        return Hours.hours(FieldUtils.safeToInt(hours));	    }	
/**	     * Converts this period to a period in minutes assuming a	     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all	     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and	     * all minutes are 60 seconds. This is not true when daylight savings time	     * is considered, and may also not be true for some unusual chronologies.	     * However, it is included as it is a useful operation for many	     * applications and business rules.	     * <p>	     * If the period contains years or months, an exception will be thrown.	     * 	     * @return a period representing the number of standard minutes in this period	     * @throws UnsupportedOperationException if the period contains years or months	     * @throws ArithmeticException if the number of minutes is too large to be represented	     * @since 1.5	     */	    public Minutes toStandardMinutes() {	        checkYearsAndMonths("Minutes");	        long millis = getMillis();  // assign to a long	        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;	        long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE;	        minutes = FieldUtils.safeAdd(minutes, getMinutes());	        minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR));	        minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY));	        minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK));	        return Minutes.minutes(FieldUtils.safeToInt(minutes));	    }	
/**	     * Converts this period to a period in seconds assuming a	     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all	     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and	     * all minutes are 60 seconds. This is not true when daylight savings time	     * is considered, and may also not be true for some unusual chronologies.	     * However, it is included as it is a useful operation for many	     * applications and business rules.	     * <p>	     * If the period contains years or months, an exception will be thrown.	     * 	     * @return a period representing the number of standard seconds in this period	     * @throws UnsupportedOperationException if the period contains years or months	     * @throws ArithmeticException if the number of seconds is too large to be represented	     * @since 1.5	     */	    public Seconds toStandardSeconds() {	        checkYearsAndMonths("Seconds");	        long seconds = getMillis() / DateTimeConstants.MILLIS_PER_SECOND;	        seconds = FieldUtils.safeAdd(seconds, getSeconds());	        seconds = FieldUtils.safeAdd(seconds, ((long) getMinutes()) * ((long) DateTimeConstants.SECONDS_PER_MINUTE));	        seconds = FieldUtils.safeAdd(seconds, ((long) getHours()) * ((long) DateTimeConstants.SECONDS_PER_HOUR));	        seconds = FieldUtils.safeAdd(seconds, ((long) getDays()) * ((long) DateTimeConstants.SECONDS_PER_DAY));	        seconds = FieldUtils.safeAdd(seconds, ((long) getWeeks()) * ((long) DateTimeConstants.SECONDS_PER_WEEK));	        return Seconds.seconds(FieldUtils.safeToInt(seconds));	    }	
/**	     * Converts this period to a duration assuming a	     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert from a period to a duration.	     * However to achieve this it makes the assumption that all	     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and	     * all minutes are 60 seconds. This is not true when daylight savings time	     * is considered, and may also not be true for some unusual chronologies.	     * However, it is included as it is a useful operation for many	     * applications and business rules.	     * <p>	     * If the period contains years or months, an exception will be thrown.	     * 	     * @return a duration equivalent to this period	     * @throws UnsupportedOperationException if the period contains years or months	     * @since 1.5	     */	    public Duration toStandardDuration() {	        checkYearsAndMonths("Duration");	        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs	        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));	        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));	        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));	        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));	        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));	        return new Duration(millis);	    }	
/**	     * Check that there are no years or months in the period.	     * 	     * @param destintionType  the destination type, not null	     * @throws UnsupportedOperationException if the period contains years or months	     */	    private void checkYearsAndMonths(String destintionType) {	        if (getMonths() != 0) {	            throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains months and months vary in length");	        }	        if (getYears() != 0) {	            throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains years and years vary in length");	        }	    }	
/**	     * Normalizes this period using standard rules, assuming a 12 month year,	     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to normalize a period.	     * However to achieve this it makes the assumption that all years are	     * 12 months, all weeks are 7 days, all days are 24 hours,	     * all hours are 60 minutes and all minutes are 60 seconds. This is not	     * true when daylight savings time is considered, and may also not be true	     * for some chronologies. However, it is included as it is a useful operation	     * for many applications and business rules.	     * <p>	     * If the period contains years or months, then the months will be	     * normalized to be between 0 and 11. The days field and below will be	     * normalized as necessary, however this will not overflow into the months	     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.	     * But a period of 1 month 40 days will remain as 1 month 40 days.	     * <p>	     * The result will always have a <code>PeriodType</code> of standard, thus	     * days will be grouped into weeks.	     * 	     * @return a normalized period equivalent to this period	     * @throws ArithmeticException if any field is too large to be represented	     * @since 1.5	     */	    public Period normalizedStandard() {	        return normalizedStandard(PeriodType.standard());	    }	
/**	     * Normalizes this period using standard rules, assuming a 12 month year,	     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,	     * providing control over how the result is split into fields.	     * <p>	     * This method allows you to normalize a period.	     * However to achieve this it makes the assumption that all years are	     * 12 months, all weeks are 7 days, all days are 24 hours,	     * all hours are 60 minutes and all minutes are 60 seconds. This is not	     * true when daylight savings time is considered, and may also not be true	     * for some chronologies. However, it is included as it is a useful operation	     * for many applications and business rules.	     * <p>	     * If the period contains years or months, then the months will be	     * normalized to be between 0 and 11. The days field and below will be	     * normalized as necessary, however this will not overflow into the months	     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.	     * But a period of 1 month 40 days will remain as 1 month 40 days.	     * <p>	     * The PeriodType parameter controls how the result is created. It allows	     * you to omit certain fields from the result if desired. For example,	     * you may not want the result to include weeks, in which case you pass	     * in <code>PeriodType.yearMonthDayTime()</code>.	     * 	     * @param type  the period type of the new period, null means standard type	     * @return a normalized period equivalent to this period	     * @throws ArithmeticException if any field is too large to be represented	     * @throws UnsupportedOperationException if this period contains non-zero	     *  years or months but the specified period type does not support them	     * @since 1.5	     */	    public Period normalizedStandard(PeriodType type) {	        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs	        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));	        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));	        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));	        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));	        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));	        Period result = new Period(millis, DateTimeUtils.getPeriodType(type), ISOChronology.getInstanceUTC());	        int years = getYears();	        int months = getMonths();	        if (years != 0 || months != 0) {	            years = FieldUtils.safeAdd(years, months / 12);	            months = months % 12;	            if (years != 0) {	                result = result.withYears(years);	            }	            if (months != 0) {	                result = result.withMonths(months);	            }	        }	        return result;	    }	
/**	     * Parses a {@code DateTime} from the specified string.	     * <p>	     * This uses {@link ISODateTimeFormat#dateTimeParser()}.	     * 	     * @param str  the string to parse, not null	     * @since 2.0	     */	    @FromString	    public static DateTime parse(String str) {	        return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed());	    }	
/**	     * Parses a {@code DateTime} from the specified string using a formatter.	     * 	     * @param str  the string to parse, not null	     * @param formatter  the formatter to use, not null	     * @since 2.0	     */	    public static DateTime parse(String str, DateTimeFormatter formatter) {	        return formatter.parseDateTime(str);	    }	
/**	     * Constructs an instance set to the current system millisecond time	     * using <code>ISOChronology</code> in the default time zone.	     */	    public DateTime() {	        super();	    }	
/**	     * Constructs an instance set to the current system millisecond time	     * using <code>ISOChronology</code> in the specified time zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     *	     * @param zone  the time zone, null means default zone	     */	    public DateTime(DateTimeZone zone) {	        super(zone);	    }	
/**	     * Constructs an instance set to the current system millisecond time	     * using the specified chronology.	     * <p>	     * If the chronology is null, <code>ISOChronology</code>	     * in the default time zone is used.	     *	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public DateTime(Chronology chronology) {	        super(chronology);	    }	
/**	     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z	     * using <code>ISOChronology</code> in the default time zone.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     */	    public DateTime(long instant) {	        super(instant);	    }	
/**	     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z	     * using <code>ISOChronology</code> in the specified time zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param zone  the time zone, null means default zone	     */	    public DateTime(long instant, DateTimeZone zone) {	        super(instant, zone);	    }	
/**	     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z	     * using the specified chronology.	     * <p>	     * If the chronology is null, <code>ISOChronology</code>	     * in the default time zone is used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public DateTime(long instant, Chronology chronology) {	        super(instant, chronology);	    }	
/**	     * Constructs an instance from an Object that represents a datetime.	     * <p>	     * If the object implies a chronology (such as GregorianCalendar does),	     * then that chronology will be used. Otherwise, ISO default is used.	     * Thus if a GregorianCalendar is passed in, the chronology used will	     * be GJ, but if a Date is passed in the chronology will be ISO.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.	     *	     * @param instant  the datetime object, null means now	     * @throws IllegalArgumentException if the instant is invalid	     */	    public DateTime(Object instant) {	        super(instant, (Chronology) null);	    }	
/**	     * Constructs an instance from an Object that represents a datetime,	     * forcing the time zone to that specified.	     * <p>	     * If the object implies a chronology (such as GregorianCalendar does),	     * then that chronology will be used, but with the time zone adjusted.	     * Otherwise, ISO is used in the specified time zone.	     * If the specified time zone is null, the default zone is used.	     * Thus if a GregorianCalendar is passed in, the chronology used will	     * be GJ, but if a Date is passed in the chronology will be ISO.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.	     *	     * @param instant  the datetime object, null means now	     * @param zone  the time zone, null means default time zone	     * @throws IllegalArgumentException if the instant is invalid	     */	    public DateTime(Object instant, DateTimeZone zone) {	        super(instant, zone);	    }	
/**	     * Constructs an instance from an Object that represents a datetime,	     * using the specified chronology.	     * <p>	     * If the chronology is null, ISO in the default time zone is used.	     * Any chronology implied by the object (such as GregorianCalendar does)	     * is ignored.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.	     *	     * @param instant  the datetime object, null means now	     * @param chronology  the chronology, null means ISO in default zone	     * @throws IllegalArgumentException if the instant is invalid	     */	    public DateTime(Object instant, Chronology chronology) {	        super(instant, DateTimeUtils.getChronology(chronology));	    }	
/**	     * Constructs an instance from datetime field values	     * using <code>ISOChronology</code> in the default time zone.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @since 2.0	     */	    public DateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour) {	        super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, 0, 0);	    }	
/**	     * Constructs an instance from datetime field values	     * using <code>ISOChronology</code> in the specified time zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param zone  the time zone, null means default time zone	     * @since 2.0	     */	    public DateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            DateTimeZone zone) {	        super(year, monthOfYear, dayOfMonth,	              hourOfDay, minuteOfHour, 0, 0, zone);	    }	
/**	     * Constructs an instance from datetime field values	     * using the specified chronology.	     * <p>	     * If the chronology is null, <code>ISOChronology</code>	     * in the default time zone is used.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param chronology  the chronology, null means ISOChronology in default zone	     * @since 2.0	     */	    public DateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            Chronology chronology) {	        super(year, monthOfYear, dayOfMonth,	              hourOfDay, minuteOfHour, 0, 0, chronology);	    }	
/**	     * Constructs an instance from datetime field values	     * using <code>ISOChronology</code> in the default time zone.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @since 2.0	     */	    public DateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute) {	        super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, 0);	    }	
/**	     * Constructs an instance from datetime field values	     * using <code>ISOChronology</code> in the specified time zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param zone  the time zone, null means default time zone	     * @since 2.0	     */	    public DateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute,	            DateTimeZone zone) {	        super(year, monthOfYear, dayOfMonth,	              hourOfDay, minuteOfHour, secondOfMinute, 0, zone);	    }	
/**	     * Constructs an instance from datetime field values	     * using the specified chronology.	     * <p>	     * If the chronology is null, <code>ISOChronology</code>	     * in the default time zone is used.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param chronology  the chronology, null means ISOChronology in default zone	     * @since 2.0	     */	    public DateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute,	            Chronology chronology) {	        super(year, monthOfYear, dayOfMonth,	              hourOfDay, minuteOfHour, secondOfMinute, 0, chronology);	    }	
/**	     * Constructs an instance from datetime field values	     * using <code>ISOChronology</code> in the default time zone.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     */	    public DateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute,	            int millisOfSecond) {	        super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	    }	
/**	     * Constructs an instance from datetime field values	     * using <code>ISOChronology</code> in the specified time zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     * @param zone  the time zone, null means default time zone	     */	    public DateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute,	            int millisOfSecond,	            DateTimeZone zone) {	        super(year, monthOfYear, dayOfMonth,	              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);	    }	
/**	     * Constructs an instance from datetime field values	     * using the specified chronology.	     * <p>	     * If the chronology is null, <code>ISOChronology</code>	     * in the default time zone is used.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public DateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute,	            int millisOfSecond,	            Chronology chronology) {	        super(year, monthOfYear, dayOfMonth,	              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);	    }	
/**	     * Get this object as a DateTime by returning <code>this</code>.	     * 	     * @return <code>this</code>	     */	    public DateTime toDateTime() {	        return this;	    }	
/**	     * Get this object as a DateTime using ISOChronology in the default zone,	     * returning <code>this</code> if possible.	     * 	     * @return a DateTime using the same millis	     */	    public DateTime toDateTimeISO() {	        if (getChronology() == ISOChronology.getInstance()) {	            return this;	        }	        return super.toDateTimeISO();	    }	
/**	     * Get this object as a DateTime, returning <code>this</code> if possible.	     * 	     * @param zone time zone to apply, or default if null	     * @return a DateTime using the same millis	     */	    public DateTime toDateTime(DateTimeZone zone) {	        zone = DateTimeUtils.getZone(zone);	        if (getZone() == zone) {	            return this;	        }	        return super.toDateTime(zone);	    }	
/**	     * Get this object as a DateTime, returning <code>this</code> if possible.	     * 	     * @param chronology chronology to apply, or ISOChronology if null	     * @return a DateTime using the same millis	     */	    public DateTime toDateTime(Chronology chronology) {	        chronology = DateTimeUtils.getChronology(chronology);	        if (getChronology() == chronology) {	            return this;	        }	        return super.toDateTime(chronology);	    }	
/**	     * Returns a copy of this datetime with different millis.	     * <p>	     * The returned object will be either be a new instance or <code>this</code>.	     * Only the millis will change, the chronology and time zone are kept.	     *	     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z	     * @return a copy of this datetime with different millis	     */	    public DateTime withMillis(long newMillis) {	        return (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));	    }	
/**	     * Returns a copy of this datetime with a different chronology.	     * <p>	     * The returned object will be either be a new instance or <code>this</code>.	     * Only the chronology will change, the millis are kept.	     *	     * @param newChronology  the new chronology, null means ISO default	     * @return a copy of this datetime with a different chronology	     */	    public DateTime withChronology(Chronology newChronology) {	        newChronology = DateTimeUtils.getChronology(newChronology);	        return (newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology));	    }	
/**	     * Returns a copy of this datetime with a different time zone, preserving the	     * millisecond instant.	     * <p>	     * This method is useful for finding the local time in another timezone.	     * For example, if this instant holds 12:30 in Europe/London, the result	     * from this method with Europe/Paris would be 13:30.	     * <p>	     * The returned object will be a new instance of the same implementation type.	     * This method changes the time zone, and does not change the	     * millisecond instant, with the effect that the field values usually change.	     * The returned object will be either be a new instance or <code>this</code>.	     *	     * @param newZone  the new time zone	     * @return a copy of this datetime with a different time zone	     * @see #withZoneRetainFields	     */	    public DateTime withZone(DateTimeZone newZone) {	        return withChronology(getChronology().withZone(newZone));	    }	
/**	     * Returns a copy of this datetime with a different time zone, preserving the	     * field values.	     * <p>	     * This method is useful for finding the millisecond time in another timezone.	     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),	     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).	     * <p>	     * The returned object will be a new instance of the same implementation type.	     * This method changes the time zone and the millisecond instant to keep	     * the field values the same.	     * The returned object will be either be a new instance or <code>this</code>.	     *	     * @param newZone  the new time zone, null means default	     * @return a copy of this datetime with a different time zone	     * @see #withZone	     */	    public DateTime withZoneRetainFields(DateTimeZone newZone) {	        newZone = DateTimeUtils.getZone(newZone);	        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());	        if (newZone == originalZone) {	            return this;	        }	        	        long millis = originalZone.getMillisKeepLocal(newZone, getMillis());	        return new DateTime(millis, getChronology().withZone(newZone));	    }	
/**	     * Returns a copy of this datetime with the specified date, retaining the time fields.	     * <p>	     * If the date is already the date passed in, then <code>this</code> is returned.	     * <p>	     * To set a single field use the properties, for example:	     * <pre>	     * DateTime set = monthOfYear().setCopy(6);	     * </pre>	     *	     * @param year  the new year value	     * @param monthOfYear  the new monthOfYear value	     * @param dayOfMonth  the new dayOfMonth value	     * @return a copy of this datetime with a different date	     * @throws IllegalArgumentException if any value if invalid	     */	    public DateTime withDate(int year, int monthOfYear, int dayOfMonth) {	        Chronology chrono = getChronology();	        long instant = getMillis();	        instant = chrono.year().set(instant, year);	        instant = chrono.monthOfYear().set(instant, monthOfYear);	        instant = chrono.dayOfMonth().set(instant, dayOfMonth);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime with the specified time, retaining the date fields.	     * <p>	     * If the time is already the time passed in, then <code>this</code> is returned.	     * <p>	     * To set a single field use the properties, for example:	     * <pre>	     * DateTime set = dt.hourOfDay().setCopy(6);	     * </pre>	     *	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     * @return a copy of this datetime with a different time	     * @throws IllegalArgumentException if any value if invalid	     */	    public DateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {	        Chronology chrono = getChronology();	        long instant = getMillis();	        instant = chrono.hourOfDay().set(instant, hourOfDay);	        instant = chrono.minuteOfHour().set(instant, minuteOfHour);	        instant = chrono.secondOfMinute().set(instant, secondOfMinute);	        instant = chrono.millisOfSecond().set(instant, millisOfSecond);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime with the partial set of fields replacing those	     * from this instance.	     * <p>	     * For example, if the partial is a <code>TimeOfDay</code> then the time fields	     * would be changed in the returned instance.	     * If the partial is null, then <code>this</code> is returned.	     *	     * @param partial  the partial set of fields to apply to this datetime, null ignored	     * @return a copy of this datetime with a different set of fields	     * @throws IllegalArgumentException if any value is invalid	     */	    public DateTime withFields(ReadablePartial partial) {	        if (partial == null) {	            return this;	        }	        return withMillis(getChronology().set(partial, getMillis()));	    }	
/**	     * Returns a copy of this datetime with the specified field set to a new value.	     * <p>	     * For example, if the field type is <code>hourOfDay</code> then the hour of day	     * field would be changed in the returned instance.	     * If the field type is null, then <code>this</code> is returned.	     * <p>	     * These three lines are equivalent:	     * <pre>	     * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);	     * DateTime updated = dt.dayOfMonth().setCopy(6);	     * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);	     * </pre>	     *	     * @param fieldType  the field type to set, not null	     * @param value  the value to set	     * @return a copy of this datetime with the field set	     * @throws IllegalArgumentException if the value is null or invalid	     */	    public DateTime withField(DateTimeFieldType fieldType, int value) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field must not be null");	        }	        long instant = fieldType.getField(getChronology()).set(getMillis(), value);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime with the value of the specified field increased.	     * <p>	     * If the addition is zero or the field is null, then <code>this</code> is returned.	     * <p>	     * These three lines are equivalent:	     * <pre>	     * DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);	     * DateTime added = dt.plusYears(6);	     * DateTime added = dt.plus(Period.years(6));	     * </pre>	     * 	     * @param fieldType  the field type to add to, not null	     * @param amount  the amount to add	     * @return a copy of this datetime with the field updated	     * @throws IllegalArgumentException if the value is null or invalid	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateTime withFieldAdded(DurationFieldType fieldType, int amount) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field must not be null");	        }	        if (amount == 0) {	            return this;	        }	        long instant = fieldType.getField(getChronology()).add(getMillis(), amount);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime with the specified duration added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * 	     * @param durationToAdd  the duration to add to this one	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this datetime with the duration added	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateTime withDurationAdded(long durationToAdd, int scalar) {	        if (durationToAdd == 0 || scalar == 0) {	            return this;	        }	        long instant = getChronology().add(getMillis(), durationToAdd, scalar);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime with the specified duration added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * 	     * @param durationToAdd  the duration to add to this one, null means zero	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this datetime with the duration added	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {	        if (durationToAdd == null || scalar == 0) {	            return this;	        }	        return withDurationAdded(durationToAdd.getMillis(), scalar);	    }	
/**	     * Returns a copy of this datetime with the specified period added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * <p>	     * This method is typically used to add multiple copies of complex	     * period instances. Adding one field is best achieved using methods	     * like {@link #withFieldAdded(DurationFieldType, int)}	     * or {@link #plusYears(int)}.	     * 	     * @param period  the period to add to this one, null means zero	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this datetime with the period added	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateTime withPeriodAdded(ReadablePeriod period, int scalar) {	        if (period == null || scalar == 0) {	            return this;	        }	        long instant = getChronology().add(period, getMillis(), scalar);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime with the specified duration added.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * This datetime instance is immutable and unaffected by this method call.	     * 	     * @param duration  the duration, in millis, to add to this one	     * @return a copy of this datetime with the duration added	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateTime plus(long duration) {	        return withDurationAdded(duration, 1);	    }	
/**	     * Returns a copy of this datetime with the specified duration added.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * This datetime instance is immutable and unaffected by this method call.	     * 	     * @param duration  the duration to add to this one, null means zero	     * @return a copy of this datetime with the duration added	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateTime plus(ReadableDuration duration) {	        return withDurationAdded(duration, 1);	    }	
/**	     * Returns a copy of this datetime with the specified period added.	     * <p>	     * This method will add each element of the period one by one, from largest	     * to smallest, adjusting the datetime to be accurate between each.	     * <p>	     * Thus, adding a period of one month and one day to 2007-03-31 will	     * work as follows:	     * First add one month and adjust, resulting in 2007-04-30	     * Then add one day and adjust, resulting in 2007-05-01.	     * <p>	     * This method is typically used to add complex period instances.	     * Adding one field is best achieved using methods	     * like {@link #plusYears(int)}.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * This datetime instance is immutable and unaffected by this method call.	     * 	     * @param period  the duration to add to this one, null means zero	     * @return a copy of this datetime with the period added	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateTime plus(ReadablePeriod period) {	        return withPeriodAdded(period, 1);	    }	
/**	     * Returns a copy of this datetime plus the specified number of years.	     * <p>	     * The calculation will do its best to only change the year field	     * retaining the same month of year.	     * However, in certain circumstances, it may be necessary to alter	     * smaller fields. For example, 2008-02-29 plus one year cannot result	     * in 2009-02-29, so the day of month is adjusted to 2009-02-28.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime added = dt.plusYears(6);	     * DateTime added = dt.plus(Period.years(6));	     * DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param years  the amount of years to add, may be negative	     * @return the new datetime plus the increased years	     * @since 1.1	     */	    public DateTime plusYears(int years) {	        if (years == 0) {	            return this;	        }	        long instant = getChronology().years().add(getMillis(), years);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime plus the specified number of months.	     * <p>	     * The calculation will do its best to only change the month field	     * retaining the same day of month.	     * However, in certain circumstances, it may be necessary to alter	     * smaller fields. For example, 2007-03-31 plus one month cannot result	     * in 2007-04-31, so the day of month is adjusted to 2007-04-30.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime added = dt.plusMonths(6);	     * DateTime added = dt.plus(Period.months(6));	     * DateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param months  the amount of months to add, may be negative	     * @return the new datetime plus the increased months	     * @since 1.1	     */	    public DateTime plusMonths(int months) {	        if (months == 0) {	            return this;	        }	        long instant = getChronology().months().add(getMillis(), months);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime plus the specified number of weeks.	     * <p>	     * The calculation operates as if it were adding the equivalent in days.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime added = dt.plusWeeks(6);	     * DateTime added = dt.plus(Period.weeks(6));	     * DateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param weeks  the amount of weeks to add, may be negative	     * @return the new datetime plus the increased weeks	     * @since 1.1	     */	    public DateTime plusWeeks(int weeks) {	        if (weeks == 0) {	            return this;	        }	        long instant = getChronology().weeks().add(getMillis(), weeks);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime plus the specified number of days.	     * <p>	     * The calculation will do its best to only change the day field	     * retaining the same time of day.	     * However, in certain circumstances, typically daylight savings cutover,	     * it may be necessary to alter the time fields.	     * <p>	     * In spring an hour is typically removed. If adding one day results in	     * the time being within the cutover then the time is adjusted to be	     * within summer time. For example, if the cutover is from 01:59 to 03:00	     * and the result of this method would have been 02:30, then the result	     * will be adjusted to 03:30.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime added = dt.plusDays(6);	     * DateTime added = dt.plus(Period.days(6));	     * DateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param days  the amount of days to add, may be negative	     * @return the new datetime plus the increased days	     * @since 1.1	     */	    public DateTime plusDays(int days) {	        if (days == 0) {	            return this;	        }	        long instant = getChronology().days().add(getMillis(), days);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime plus the specified number of hours.	     * <p>	     * The calculation will add a duration equivalent to the number of hours	     * expressed in milliseconds.	     * <p>	     * For example, if a spring daylight savings cutover is from 01:59 to 03:00	     * then adding one hour to 01:30 will result in 03:30. This is a duration	     * of one hour later, even though the hour field value changed from 1 to 3.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime added = dt.plusHours(6);	     * DateTime added = dt.plus(Period.hours(6));	     * DateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param hours  the amount of hours to add, may be negative	     * @return the new datetime plus the increased hours	     * @since 1.1	     */	    public DateTime plusHours(int hours) {	        if (hours == 0) {	            return this;	        }	        long instant = getChronology().hours().add(getMillis(), hours);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime plus the specified number of minutes.	     * <p>	     * The calculation will add a duration equivalent to the number of minutes	     * expressed in milliseconds.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime added = dt.plusMinutes(6);	     * DateTime added = dt.plus(Period.minutes(6));	     * DateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param minutes  the amount of minutes to add, may be negative	     * @return the new datetime plus the increased minutes	     * @since 1.1	     */	    public DateTime plusMinutes(int minutes) {	        if (minutes == 0) {	            return this;	        }	        long instant = getChronology().minutes().add(getMillis(), minutes);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime plus the specified number of seconds.	     * <p>	     * The calculation will add a duration equivalent to the number of seconds	     * expressed in milliseconds.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime added = dt.plusSeconds(6);	     * DateTime added = dt.plus(Period.seconds(6));	     * DateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param seconds  the amount of seconds to add, may be negative	     * @return the new datetime plus the increased seconds	     * @since 1.1	     */	    public DateTime plusSeconds(int seconds) {	        if (seconds == 0) {	            return this;	        }	        long instant = getChronology().seconds().add(getMillis(), seconds);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime plus the specified number of millis.	     * <p>	     * The calculation will add a duration equivalent to the number of milliseconds.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime added = dt.plusMillis(6);	     * DateTime added = dt.plus(Period.millis(6));	     * DateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param millis  the amount of millis to add, may be negative	     * @return the new datetime plus the increased millis	     * @since 1.1	     */	    public DateTime plusMillis(int millis) {	        if (millis == 0) {	            return this;	        }	        long instant = getChronology().millis().add(getMillis(), millis);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime with the specified duration taken away.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * This datetime instance is immutable and unaffected by this method call.	     * 	     * @param duration  the duration, in millis, to reduce this instant by	     * @return a copy of this datetime with the duration taken away	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateTime minus(long duration) {	        return withDurationAdded(duration, -1);	    }	
/**	     * Returns a copy of this datetime with the specified duration taken away.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * This datetime instance is immutable and unaffected by this method call.	     * 	     * @param duration  the duration to reduce this instant by	     * @return a copy of this datetime with the duration taken away	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateTime minus(ReadableDuration duration) {	        return withDurationAdded(duration, -1);	    }	
/**	     * Returns a copy of this datetime with the specified period taken away.	     * <p>	     * This method will subtract each element of the period one by one, from	     * largest to smallest, adjusting the datetime to be accurate between each.	     * <p>	     * Thus, subtracting a period of one month and one day from 2007-05-31 will	     * work as follows:	     * First subtract one month and adjust, resulting in 2007-04-30	     * Then subtract one day and adjust, resulting in 2007-04-29.	     * Note that the day has been adjusted by two.	     * <p>	     * This method is typically used to subtract complex period instances.	     * Subtracting one field is best achieved using methods	     * like {@link #minusYears(int)}.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * This datetime instance is immutable and unaffected by this method call.	     * 	     * @param period  the period to reduce this instant by	     * @return a copy of this datetime with the period taken away	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public DateTime minus(ReadablePeriod period) {	        return withPeriodAdded(period, -1);	    }	
/**	     * Returns a copy of this datetime minus the specified number of years.	     * <p>	     * The calculation will do its best to only change the year field	     * retaining the same month of year.	     * However, in certain circumstances, it may be necessary to alter	     * smaller fields. For example, 2008-02-29 minus one year cannot result	     * in 2007-02-29, so the day of month is adjusted to 2007-02-28.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime subtracted = dt.minusYears(6);	     * DateTime subtracted = dt.minus(Period.years(6));	     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param years  the amount of years to subtract, may be negative	     * @return the new datetime minus the increased years	     * @since 1.1	     */	    public DateTime minusYears(int years) {	        if (years == 0) {	            return this;	        }	        long instant = getChronology().years().subtract(getMillis(), years);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime minus the specified number of months.	     * <p>	     * The calculation will do its best to only change the month field	     * retaining the same day of month.	     * However, in certain circumstances, it may be necessary to alter	     * smaller fields. For example, 2007-05-31 minus one month cannot result	     * in 2007-04-31, so the day of month is adjusted to 2007-04-30.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime subtracted = dt.minusMonths(6);	     * DateTime subtracted = dt.minus(Period.months(6));	     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param months  the amount of months to subtract, may be negative	     * @return the new datetime minus the increased months	     * @since 1.1	     */	    public DateTime minusMonths(int months) {	        if (months == 0) {	            return this;	        }	        long instant = getChronology().months().subtract(getMillis(), months);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime minus the specified number of weeks.	     * <p>	     * The calculation operates as if it were subtracting the equivalent in days.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime subtracted = dt.minusWeeks(6);	     * DateTime subtracted = dt.minus(Period.weeks(6));	     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param weeks  the amount of weeks to subtract, may be negative	     * @return the new datetime minus the increased weeks	     * @since 1.1	     */	    public DateTime minusWeeks(int weeks) {	        if (weeks == 0) {	            return this;	        }	        long instant = getChronology().weeks().subtract(getMillis(), weeks);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime minus the specified number of days.	     * <p>	     * The calculation will do its best to only change the day field	     * retaining the same time of day.	     * However, in certain circumstances, typically daylight savings cutover,	     * it may be necessary to alter the time fields.	     * <p>	     * In spring an hour is typically removed. If subtracting one day results	     * in the time being within the cutover then the time is adjusted to be	     * within summer time. For example, if the cutover is from 01:59 to 03:00	     * and the result of this method would have been 02:30, then the result	     * will be adjusted to 03:30.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime subtracted = dt.minusDays(6);	     * DateTime subtracted = dt.minus(Period.days(6));	     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param days  the amount of days to subtract, may be negative	     * @return the new datetime minus the increased days	     * @since 1.1	     */	    public DateTime minusDays(int days) {	        if (days == 0) {	            return this;	        }	        long instant = getChronology().days().subtract(getMillis(), days);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime minus the specified number of hours.	     * <p>	     * The calculation will subtract a duration equivalent to the number of	     * hours expressed in milliseconds.	     * <p>	     * For example, if a spring daylight savings cutover is from 01:59 to 03:00	     * then subtracting one hour from 03:30 will result in 01:30. This is a	     * duration of one hour earlier, even though the hour field value changed	     * from 3 to 1.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime subtracted = dt.minusHours(6);	     * DateTime subtracted = dt.minus(Period.hours(6));	     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param hours  the amount of hours to subtract, may be negative	     * @return the new datetime minus the increased hours	     * @since 1.1	     */	    public DateTime minusHours(int hours) {	        if (hours == 0) {	            return this;	        }	        long instant = getChronology().hours().subtract(getMillis(), hours);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime minus the specified number of minutes.	     * <p>	     * The calculation will subtract a duration equivalent to the number of	     * minutes expressed in milliseconds.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime subtracted = dt.minusMinutes(6);	     * DateTime subtracted = dt.minus(Period.minutes(6));	     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param minutes  the amount of minutes to subtract, may be negative	     * @return the new datetime minus the increased minutes	     * @since 1.1	     */	    public DateTime minusMinutes(int minutes) {	        if (minutes == 0) {	            return this;	        }	        long instant = getChronology().minutes().subtract(getMillis(), minutes);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime minus the specified number of seconds.	     * <p>	     * The calculation will subtract a duration equivalent to the number of	     * seconds expressed in milliseconds.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime subtracted = dt.minusSeconds(6);	     * DateTime subtracted = dt.minus(Period.seconds(6));	     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param seconds  the amount of seconds to subtract, may be negative	     * @return the new datetime minus the increased seconds	     * @since 1.1	     */	    public DateTime minusSeconds(int seconds) {	        if (seconds == 0) {	            return this;	        }	        long instant = getChronology().seconds().subtract(getMillis(), seconds);	        return withMillis(instant);	    }	
/**	     * Returns a copy of this datetime minus the specified number of millis.	     * <p>	     * The calculation will subtract a duration equivalent to the number of	     * milliseconds.	     * <p>	     * The following three lines are identical in effect:	     * <pre>	     * DateTime subtracted = dt.minusMillis(6);	     * DateTime subtracted = dt.minus(Period.millis(6));	     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);	     * </pre>	     * <p>	     * This datetime instance is immutable and unaffected by this method call.	     *	     * @param millis  the amount of millis to subtract, may be negative	     * @return the new datetime minus the increased millis	     * @since 1.1	     */	    public DateTime minusMillis(int millis) {	        if (millis == 0) {	            return this;	        }	        long instant = getChronology().millis().subtract(getMillis(), millis);	        return withMillis(instant);	    }	
/**	     * Gets the property object for the specified type, which contains many useful methods.	     *	     * @param type  the field type to get the chronology for	     * @return the property object	     * @throws IllegalArgumentException if the field is null or unsupported	     */	    public Property property(DateTimeFieldType type) {	        if (type == null) {	            throw new IllegalArgumentException("The DateTimeFieldType must not be null");	        }	        DateTimeField field = type.getField(getChronology());	        if (field.isSupported() == false) {	            throw new IllegalArgumentException("Field '" + type + "' is not supported");	        }	        return new Property(this, field);	    }	
/**	     * Converts this object to a <code>DateMidnight</code> using the	     * same millis and chronology.	     * 	     * @return a DateMidnight using the same millis and chronology	     */	    public DateMidnight toDateMidnight() {	        return new DateMidnight(getMillis(), getChronology());	    }	
/**	     * Converts this object to a <code>YearMonthDay</code> using the	     * same millis and chronology.	     * 	     * @return a YearMonthDay using the same millis and chronology	     * @deprecated Use LocalDate instead of YearMonthDay	     */	    public YearMonthDay toYearMonthDay() {	        return new YearMonthDay(getMillis(), getChronology());	    }	
/**	     * Converts this object to a <code>TimeOfDay</code> using the	     * same millis and chronology.	     * 	     * @return a TimeOfDay using the same millis and chronology	     * @deprecated Use LocalTime instead of TimeOfDay	     */	    public TimeOfDay toTimeOfDay() {	        return new TimeOfDay(getMillis(), getChronology());	    }	
/**	     * Converts this object to a <code>LocalDateTime</code> with	     * the same datetime and chronology.	     *	     * @return a LocalDateTime with the same datetime and chronology	     * @since 1.3	     */	    public LocalDateTime toLocalDateTime() {	        return new LocalDateTime(getMillis(), getChronology());	    }	
/**	     * Converts this object to a <code>LocalDate</code> with the	     * same date and chronology.	     *	     * @return a LocalDate with the same date and chronology	     * @since 1.3	     */	    public LocalDate toLocalDate() {	        return new LocalDate(getMillis(), getChronology());	    }	
/**	     * Converts this object to a <code>LocalTime</code> with the	     * same time and chronology.	     *	     * @return a LocalTime with the same time and chronology	     * @since 1.3	     */	    public LocalTime toLocalTime() {	        return new LocalTime(getMillis(), getChronology());	    }	
/**	     * Returns a copy of this datetime with the era field updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * era changed.	     *	     * @param era  the era to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withEra(int era) {	        return withMillis(getChronology().era().set(getMillis(), era));	    }	
/**	     * Returns a copy of this datetime with the century of era field updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * century of era changed.	     *	     * @param centuryOfEra  the centurey of era to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withCenturyOfEra(int centuryOfEra) {	        return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra));	    }	
/**	     * Returns a copy of this datetime with the year of era field updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * year of era changed.	     *	     * @param yearOfEra  the year of era to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withYearOfEra(int yearOfEra) {	        return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra));	    }	
/**	     * Returns a copy of this datetime with the year of century field updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * year of century changed.	     *	     * @param yearOfCentury  the year of century to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withYearOfCentury(int yearOfCentury) {	        return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury));	    }	
/**	     * Returns a copy of this datetime with the year field updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * year changed.	     *	     * @param year  the year to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withYear(int year) {	        return withMillis(getChronology().year().set(getMillis(), year));	    }	
/**	     * Returns a copy of this datetime with the weekyear field updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * weekyear changed.	     *	     * @param weekyear  the weekyear to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withWeekyear(int weekyear) {	        return withMillis(getChronology().weekyear().set(getMillis(), weekyear));	    }	
/**	     * Returns a copy of this datetime with the month of year field updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * month of year changed.	     *	     * @param monthOfYear  the month of year to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withMonthOfYear(int monthOfYear) {	        return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));	    }	
/**	     * Returns a copy of this datetime with the week of weekyear field updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * week of weekyear changed.	     *	     * @param weekOfWeekyear  the week of weekyear to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withWeekOfWeekyear(int weekOfWeekyear) {	        return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));	    }	
/**	     * Returns a copy of this datetime with the day of year field updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * day of year changed.	     *	     * @param dayOfYear  the day of year to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withDayOfYear(int dayOfYear) {	        return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));	    }	
/**	     * Returns a copy of this datetime with the day of month field updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * day of month changed.	     *	     * @param dayOfMonth  the day of month to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withDayOfMonth(int dayOfMonth) {	        return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));	    }	
/**	     * Returns a copy of this datetime with the day of week field updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * day of week changed.	     *	     * @param dayOfWeek  the day of week to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withDayOfWeek(int dayOfWeek) {	        return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));	    }	
/**	     * Returns a copy of this datetime with the hour of day field updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * hour of day changed.	     *	     * @param hour  the hour of day to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withHourOfDay(int hour) {	        return withMillis(getChronology().hourOfDay().set(getMillis(), hour));	    }	
/**	     * Returns a copy of this datetime with the minute of hour updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * minute of hour changed.	     *	     * @param minute  the minute of hour to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withMinuteOfHour(int minute) {	        return withMillis(getChronology().minuteOfHour().set(getMillis(), minute));	    }	
/**	     * Returns a copy of this datetime with the second of minute field updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * second of minute changed.	     *	     * @param second  the second of minute to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withSecondOfMinute(int second) {	        return withMillis(getChronology().secondOfMinute().set(getMillis(), second));	    }	
/**	     * Returns a copy of this datetime with the millis of second field updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * millis of second changed.	     *	     * @param millis  the millis of second to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withMillisOfSecond(int millis) {	        return withMillis(getChronology().millisOfSecond().set(getMillis(), millis));	    }	
/**	     * Returns a copy of this datetime with the millis of day field updated.	     * <p>	     * DateTime is immutable, so there are no set methods.	     * Instead, this method returns a new instance with the value of	     * millis of day changed.	     *	     * @param millis  the millis of day to set	     * @return a copy of this object with the field set	     * @throws IllegalArgumentException if the value is invalid	     * @since 1.3	     */	    public DateTime withMillisOfDay(int millis) {	        return withMillis(getChronology().millisOfDay().set(getMillis(), millis));	    }	
/**	     * Get the era property which provides access to advanced functionality.	     * 	     * @return the era property	     */	    public Property era() {	        return new Property(this, getChronology().era());	    }	
/**	     * Get the century of era property which provides access to advanced functionality.	     * 	     * @return the year of era property	     */	    public Property centuryOfEra() {	        return new Property(this, getChronology().centuryOfEra());	    }	
/**	     * Get the year of century property which provides access to advanced functionality.	     * 	     * @return the year of era property	     */	    public Property yearOfCentury() {	        return new Property(this, getChronology().yearOfCentury());	    }	
/**	     * Get the year of era property which provides access to advanced functionality.	     * 	     * @return the year of era property	     */	    public Property yearOfEra() {	        return new Property(this, getChronology().yearOfEra());	    }	
/**	     * Get the year property which provides access to advanced functionality.	     * 	     * @return the year property	     */	    public Property year() {	        return new Property(this, getChronology().year());	    }	
/**	     * Get the year of a week based year property which provides access to advanced functionality.	     * 	     * @return the year of a week based year property	     */	    public Property weekyear() {	        return new Property(this, getChronology().weekyear());	    }	
/**	     * Get the month of year property which provides access to advanced functionality.	     * 	     * @return the month of year property	     */	    public Property monthOfYear() {	        return new Property(this, getChronology().monthOfYear());	    }	
/**	     * Get the week of a week based year property which provides access to advanced functionality.	     * 	     * @return the week of a week based year property	     */	    public Property weekOfWeekyear() {	        return new Property(this, getChronology().weekOfWeekyear());	    }	
/**	     * Get the day of year property which provides access to advanced functionality.	     * 	     * @return the day of year property	     */	    public Property dayOfYear() {	        return new Property(this, getChronology().dayOfYear());	    }	
/**	     * Get the day of month property which provides access to advanced functionality.	     * 	     * @return the day of month property	     */	    public Property dayOfMonth() {	        return new Property(this, getChronology().dayOfMonth());	    }	
/**	     * Get the day of week property which provides access to advanced functionality.	     * 	     * @return the day of week property	     */	    public Property dayOfWeek() {	        return new Property(this, getChronology().dayOfWeek());	    }	
/**	     * Get the hour of day field property which provides access to advanced functionality.	     * 	     * @return the hour of day property	     */	    public Property hourOfDay() {	        return new Property(this, getChronology().hourOfDay());	    }	
/**	     * Get the minute of day property which provides access to advanced functionality.	     * 	     * @return the minute of day property	     */	    public Property minuteOfDay() {	        return new Property(this, getChronology().minuteOfDay());	    }	
/**	     * Get the minute of hour field property which provides access to advanced functionality.	     * 	     * @return the minute of hour property	     */	    public Property minuteOfHour() {	        return new Property(this, getChronology().minuteOfHour());	    }	
/**	     * Get the second of day property which provides access to advanced functionality.	     * 	     * @return the second of day property	     */	    public Property secondOfDay() {	        return new Property(this, getChronology().secondOfDay());	    }	
/**	     * Get the second of minute field property which provides access to advanced functionality.	     * 	     * @return the second of minute property	     */	    public Property secondOfMinute() {	        return new Property(this, getChronology().secondOfMinute());	    }	
/**	     * Get the millis of day property which provides access to advanced functionality.	     * 	     * @return the millis of day property	     */	    public Property millisOfDay() {	        return new Property(this, getChronology().millisOfDay());	    }	
/**	     * Get the millis of second property which provides access to advanced functionality.	     * 	     * @return the millis of second property	     */	    public Property millisOfSecond() {	        return new Property(this, getChronology().millisOfSecond());	    }	
/**	         * Constructor.	         * 	         * @param instant  the instant to set	         * @param field  the field to use	         */	        Property(DateTime instant, DateTimeField field) {	            super();	            iInstant = instant;	            iField = field;	        }	
/**	         * Writes the property in a safe serialization format.	         */	        private void writeObject(ObjectOutputStream oos) throws IOException {	            oos.writeObject(iInstant);	            oos.writeObject(iField.getType());	        }	
/**	         * Reads the property from a safe serialization format.	         */	        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {	            iInstant = (DateTime) oos.readObject();	            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();	            iField = type.getField(iInstant.getChronology());	        }	
/**	         * Gets the field being used.	         * 	         * @return the field	         */	        public DateTimeField getField() {	            return iField;	        }	
/**	         * Gets the milliseconds of the datetime that this property is linked to.	         * 	         * @return the milliseconds	         */	        protected long getMillis() {	            return iInstant.getMillis();	        }	
/**	         * Gets the chronology of the datetime that this property is linked to.	         * 	         * @return the chronology	         * @since 1.4	         */	        protected Chronology getChronology() {	            return iInstant.getChronology();	        }	
/**	         * Gets the datetime being used.	         * 	         * @return the datetime	         */	        public DateTime getDateTime() {	            return iInstant;	        }	
/**	         * Adds to this field in a copy of this DateTime.	         * <p>	         * The DateTime attached to this property is unchanged by this call.	         * This operation is faster than converting a DateTime to a MutableDateTime	         * and back again when setting one field. When setting multiple fields,	         * it is generally quicker to make the conversion to MutableDateTime.	         * 	         * @param value  the value to add to the field in the copy	         * @return a copy of the DateTime with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public DateTime addToCopy(int value) {	            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));	        }	
/**	         * Adds to this field in a copy of this DateTime.	         * <p>	         * The DateTime attached to this property is unchanged by this call.	         * This operation is faster than converting a DateTime to a MutableDateTime	         * and back again when setting one field. When setting multiple fields,	         * it is generally quicker to make the conversion to MutableDateTime.	         * 	         * @param value  the value to add to the field in the copy	         * @return a copy of the DateTime with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public DateTime addToCopy(long value) {	            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));	        }	
/**	         * Adds to this field, possibly wrapped, in a copy of this DateTime.	         * A wrapped operation only changes this field.	         * Thus 31st January addWrapField one day goes to the 1st January.	         * <p>	         * The DateTime attached to this property is unchanged by this call.	         * This operation is faster than converting a DateTime to a MutableDateTime	         * and back again when setting one field. When setting multiple fields,	         * it is generally quicker to make the conversion to MutableDateTime.	         * 	         * @param value  the value to add to the field in the copy	         * @return a copy of the DateTime with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public DateTime addWrapFieldToCopy(int value) {	            return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value));	        }	
/**	         * Sets this field in a copy of the DateTime.	         * <p>	         * The DateTime attached to this property is unchanged by this call.	         * This operation is faster than converting a DateTime to a MutableDateTime	         * and back again when setting one field. When setting multiple fields,	         * it is generally quicker to make the conversion to MutableDateTime.	         * 	         * @param value  the value to set the field in the copy to	         * @return a copy of the DateTime with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public DateTime setCopy(int value) {	            return iInstant.withMillis(iField.set(iInstant.getMillis(), value));	        }	
/**	         * Sets this field in a copy of the DateTime to a parsed text value.	         * <p>	         * The DateTime attached to this property is unchanged by this call.	         * This operation is faster than converting a DateTime to a MutableDateTime	         * and back again when setting one field. When setting multiple fields,	         * it is generally quicker to make the conversion to MutableDateTime.	         * 	         * @param text  the text value to set	         * @param locale  optional locale to use for selecting a text symbol	         * @return a copy of the DateTime with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public DateTime setCopy(String text, Locale locale) {	            return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale));	        }	
/**	         * Sets this field in a copy of the DateTime to a parsed text value.	         * <p>	         * The DateTime attached to this property is unchanged by this call.	         * This operation is faster than converting a DateTime to a MutableDateTime	         * and back again when setting one field. When setting multiple fields,	         * it is generally quicker to make the conversion to MutableDateTime.	         * 	         * @param text  the text value to set	         * @return a copy of the DateTime with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public DateTime setCopy(String text) {	            return setCopy(text, null);	        }	
/**	         * Returns a new DateTime with this field set to the maximum value	         * for this field.	         * <p>	         * This operation is useful for obtaining a DateTime on the last day	         * of the month, as month lengths vary.	         * <pre>	         * DateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();	         * </pre>	         * <p>	         * The DateTime attached to this property is unchanged by this call.	         *	         * @return a copy of the DateTime with this field set to its maximum	         * @since 1.2	         */	        public DateTime withMaximumValue() {	            return setCopy(getMaximumValue());	        }	
/**	         * Returns a new DateTime with this field set to the minimum value	         * for this field.	         * <p>	         * The DateTime attached to this property is unchanged by this call.	         *	         * @return a copy of the DateTime with this field set to its minimum	         * @since 1.2	         */	        public DateTime withMinimumValue() {	            return setCopy(getMinimumValue());	        }	
/**	         * Rounds to the lowest whole unit of this field on a copy of this DateTime.	         *	         * @return a copy of the DateTime with the field value changed	         */	        public DateTime roundFloorCopy() {	            return iInstant.withMillis(iField.roundFloor(iInstant.getMillis()));	        }	
/**	         * Rounds to the highest whole unit of this field on a copy of this DateTime.	         *	         * @return a copy of the DateTime with the field value changed	         */	        public DateTime roundCeilingCopy() {	            return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis()));	        }	
/**	         * Rounds to the nearest whole unit of this field on a copy of this DateTime,	         * favoring the floor if halfway.	         *	         * @return a copy of the DateTime with the field value changed	         */	        public DateTime roundHalfFloorCopy() {	            return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis()));	        }	
/**	         * Rounds to the nearest whole unit of this field on a copy of this DateTime,	         * favoring the ceiling if halfway.	         *	         * @return a copy of the DateTime with the field value changed	         */	        public DateTime roundHalfCeilingCopy() {	            return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis()));	        }	
/**	         * Rounds to the nearest whole unit of this field on a copy of this	         * DateTime.  If halfway, the ceiling is favored over the floor only if	         * it makes this field's value even.	         *	         * @return a copy of the DateTime with the field value changed	         */	        public DateTime roundHalfEvenCopy() {	            return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));	        }	
/**	     * Subtracts a duration value (which may be negative) from the instant.	     * 	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to subtract from	     * @param value  the value to subtract, in the units of the field	     * @return the updated milliseconds	     * @since 1.1	     */	    public long subtract(long instant, int value) {	        if (value == Integer.MIN_VALUE) {	            return subtract(instant, (long) value);	        }	        return add(instant, -value);	    }	
/**	     * Subtracts a duration value (which may be negative) from the instant.	     * 	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to subtract from	     * @param value  the value to subtract, in the units of the field	     * @return the updated milliseconds	     * @since 1.1	     */	    public long subtract(long instant, long value) {	        if (value == Long.MIN_VALUE) {	            throw new ArithmeticException("Long.MIN_VALUE cannot be negated");	        }	        return add(instant, -value);	    }	
/**	     * Obtains an instance of <code>Days</code> that may be cached.	     * <code>Days</code> is immutable, so instances can be cached and shared.	     * This factory method provides access to shared instances.	     *	     * @param days  the number of days to obtain an instance for	     * @return the instance of Days	     */	    public static Days days(int days) {	        switch (days) {	            case 0:	                return ZERO;	            case 1:	                return ONE;	            case 2:	                return TWO;	            case 3:	                return THREE;	            case 4:	                return FOUR;	            case 5:	                return FIVE;	            case 6:	                return SIX;	            case 7:	                return SEVEN;	            case Integer.MAX_VALUE:	                return MAX_VALUE;	            case Integer.MIN_VALUE:	                return MIN_VALUE;	            default:	                return new Days(days);	        }	    }	
/**	     * Creates a <code>Days</code> representing the number of whole days	     * between the two specified datetimes. This method corectly handles	     * any daylight savings time changes that may occur during the interval.	     *	     * @param start  the start instant, must not be null	     * @param end  the end instant, must not be null	     * @return the period in days	     * @throws IllegalArgumentException if the instants are null or invalid	     */	    public static Days daysBetween(ReadableInstant start, ReadableInstant end) {	        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.days());	        return Days.days(amount);	    }	
/**	     * Creates a <code>Days</code> representing the number of whole days	     * between the two specified partial datetimes.	     * <p>	     * The two partials must contain the same fields, for example you can specify	     * two <code>LocalDate</code> objects.	     *	     * @param start  the start partial date, must not be null	     * @param end  the end partial date, must not be null	     * @return the period in days	     * @throws IllegalArgumentException if the partials are null or invalid	     */	    public static Days daysBetween(ReadablePartial start, ReadablePartial end) {	        if (start instanceof LocalDate && end instanceof LocalDate)   {	            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());	            int days = chrono.days().getDifference(	                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());	            return Days.days(days);	        }	        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);	        return Days.days(amount);	    }	
/**	     * Creates a <code>Days</code> representing the number of whole days	     * in the specified interval. This method corectly handles any daylight	     * savings time changes that may occur during the interval.	     *	     * @param interval  the interval to extract days from, null returns zero	     * @return the period in days	     * @throws IllegalArgumentException if the partials are null or invalid	     */	    public static Days daysIn(ReadableInterval interval) {	        if (interval == null)   {	            return Days.ZERO;	        }	        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.days());	        return Days.days(amount);	    }	
/**	     * Creates a new <code>Days</code> representing the number of complete	     * standard length days in the specified period.	     * <p>	     * This factory method converts all fields from the period to hours using standardised	     * durations for each field. Only those fields which have a precise duration in	     * the ISO UTC chronology can be converted.	     * <ul>	     * <li>One week consists of 7 days.	     * <li>One day consists of 24 hours.	     * <li>One hour consists of 60 minutes.	     * <li>One minute consists of 60 seconds.	     * <li>One second consists of 1000 milliseconds.	     * </ul>	     * Months and Years are imprecise and periods containing these values cannot be converted.	     *	     * @param period  the period to get the number of hours from, null returns zero	     * @return the period in days	     * @throws IllegalArgumentException if the period contains imprecise duration values	     */	    public static Days standardDaysIn(ReadablePeriod period) {	        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_DAY);	        return Days.days(amount);	    }	
/**	     * Creates a new <code>Days</code> by parsing a string in the ISO8601 format 'PnD'.	     * <p>	     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the	     * days component may be non-zero. If any other component is non-zero, an exception	     * will be thrown.	     *	     * @param periodStr  the period string, null returns zero	     * @return the period in days	     * @throws IllegalArgumentException if the string format is invalid	     */	    @FromString	    public static Days parseDays(String periodStr) {	        if (periodStr == null) {	            return Days.ZERO;	        }	        Period p = PARSER.parsePeriod(periodStr);	        return Days.days(p.getDays());	    }	
/**	     * Creates a new instance representing a number of days.	     * You should consider using the factory method {@link #days(int)}	     * instead of the constructor.	     *	     * @param days  the number of days to represent	     */	    private Days(int days) {	        super(days);	    }	
/**	     * Resolves singletons.	     * 	     * @return the singleton instance	     */	    private Object readResolve() {	        return Days.days(getValue());	    }	
/**	     * Gets the duration field type, which is <code>days</code>.	     *	     * @return the period type	     */	    public DurationFieldType getFieldType() {	        return DurationFieldType.days();	    }	
/**	     * Gets the period type, which is <code>days</code>.	     *	     * @return the period type	     */	    public PeriodType getPeriodType() {	        return PeriodType.days();	    }	
/**	     * Converts this period in days to a period in weeks assuming a	     * 7 day week.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all weeks are	     * 7 days long.	     * This may not be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of weeks for this number of days	     */	    public Weeks toStandardWeeks() {	        return Weeks.weeks(getValue() / DateTimeConstants.DAYS_PER_WEEK);	    }	
/**	     * Converts this period in days to a period in hours assuming a	     * 24 hour day.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all days are 24 hours long.	     * This is not true when daylight savings is considered and may also not	     * be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of hours for this number of days	     * @throws ArithmeticException if the number of hours is too large to be represented	     */	    public Hours toStandardHours() {	        return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_DAY));	    }	
/**	     * Converts this period in days to a period in minutes assuming a	     * 24 hour day and 60 minute hour.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all days are 24 hours	     * long and all hours are 60 minutes long.	     * This is not true when daylight savings is considered and may also not	     * be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of minutes for this number of days	     * @throws ArithmeticException if the number of minutes is too large to be represented	     */	    public Minutes toStandardMinutes() {	        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_DAY));	    }	
/**	     * Converts this period in days to a period in seconds assuming a	     * 24 hour day, 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert between different types of period.	     * However to achieve this it makes the assumption that all days are 24 hours	     * long, all hours are 60 minutes long and all minutes are 60 seconds long.	     * This is not true when daylight savings is considered and may also not	     * be true for some unusual chronologies. However, it is included	     * as it is a useful operation for many applications and business rules.	     * 	     * @return a period representing the number of seconds for this number of days	     * @throws ArithmeticException if the number of seconds is too large to be represented	     */	    public Seconds toStandardSeconds() {	        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_DAY));	    }	
/**	     * Converts this period in days to a duration in milliseconds assuming a	     * 24 hour day, 60 minute hour and 60 second minute.	     * <p>	     * This method allows you to convert from a period to a duration.	     * However to achieve this it makes the assumption that all days are 24 hours	     * long, all hours are 60 minutes and all minutes are 60 seconds.	     * This is not true when daylight savings time is considered, and may also	     * not be true for some unusual chronologies. However, it is included as it	     * is a useful operation for many applications and business rules.	     * 	     * @return a duration equivalent to this number of days	     */	    public Duration toStandardDuration() {	        long days = getValue();  // assign to a long	        return new Duration(days * DateTimeConstants.MILLIS_PER_DAY);	    }	
/**	     * Gets the number of days that this period represents.	     *	     * @return the number of days in the period	     */	    public int getDays() {	        return getValue();	    }	
/**	     * Returns a new instance with the specified number of days added.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param days  the amount of days to add, may be negative	     * @return the new period plus the specified number of days	     * @throws ArithmeticException if the result overflows an int	     */	    public Days plus(int days) {	        if (days == 0) {	            return this;	        }	        return Days.days(FieldUtils.safeAdd(getValue(), days));	    }	
/**	     * Returns a new instance with the specified number of days added.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param days  the amount of days to add, may be negative, null means zero	     * @return the new period plus the specified number of days	     * @throws ArithmeticException if the result overflows an int	     */	    public Days plus(Days days) {	        if (days == null) {	            return this;	        }	        return plus(days.getValue());	    }	
/**	     * Returns a new instance with the specified number of days taken away.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param days  the amount of days to take away, may be negative	     * @return the new period minus the specified number of days	     * @throws ArithmeticException if the result overflows an int	     */	    public Days minus(int days) {	        return plus(FieldUtils.safeNegate(days));	    }	
/**	     * Returns a new instance with the specified number of days taken away.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param days  the amount of days to take away, may be negative, null means zero	     * @return the new period minus the specified number of days	     * @throws ArithmeticException if the result overflows an int	     */	    public Days minus(Days days) {	        if (days == null) {	            return this;	        }	        return minus(days.getValue());	    }	
/**	     * Returns a new instance with the days multiplied by the specified scalar.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param scalar  the amount to multiply by, may be negative	     * @return the new period multiplied by the specified scalar	     * @throws ArithmeticException if the result overflows an int	     */	    public Days multipliedBy(int scalar) {	        return Days.days(FieldUtils.safeMultiply(getValue(), scalar));	    }	
/**	     * Returns a new instance with the days divided by the specified divisor.	     * The calculation uses integer division, thus 3 divided by 2 is 1.	     * <p>	     * This instance is immutable and unaffected by this method call.	     *	     * @param divisor  the amount to divide by, may be negative	     * @return the new period divided by the specified divisor	     * @throws ArithmeticException if the divisor is zero	     */	    public Days dividedBy(int divisor) {	        if (divisor == 1) {	            return this;	        }	        return Days.days(getValue() / divisor);	    }	
/**	     * Returns a new instance with the days value negated.	     *	     * @return the new period with a negated value	     * @throws ArithmeticException if the result overflows an int	     */	    public Days negated() {	        return Days.days(FieldUtils.safeNegate(getValue()));	    }	
/**	     * Is this days instance greater than the specified number of days.	     *	     * @param other  the other period, null means zero	     * @return true if this days instance is greater than the specified one	     */	    public boolean isGreaterThan(Days other) {	        if (other == null) {	            return getValue() > 0;	        }	        return getValue() > other.getValue();	    }	
/**	     * Is this days instance less than the specified number of days.	     *	     * @param other  the other period, null means zero	     * @return true if this days instance is less than the specified one	     */	    public boolean isLessThan(Days other) {	        if (other == null) {	            return getValue() < 0;	        }	        return getValue() < other.getValue();	    }	
/**	     * Gets this instance as a String in the ISO8601 duration format.	     * <p>	     * For example, "P4D" represents 4 days.	     *	     * @return the value as an ISO8601 string	     */	    @ToString	    public String toString() {	        return "P" + String.valueOf(getValue()) + "D";	    }	
/**	     * Restrictive constructor	     */	    protected DateTimeConstants() {	    }	
/**	     * Constructs a Partial with no fields or values, which can be considered	     * to represent any date.	     * <p>	     * This is most useful when constructing partials, for example:	     * <pre>	     * Partial p = new Partial()	     *     .with(DateTimeFieldType.dayOfWeek(), 5)	     *     .with(DateTimeFieldType.hourOfDay(), 12)	     *     .with(DateTimeFieldType.minuteOfHour(), 20);	     * </pre>	     * Note that, although this is a clean way to write code, it is fairly	     * inefficient internally.	     * <p>	     * The constructor uses the default ISO chronology.	     */	    public Partial() {	        this((Chronology) null);	    }	
/**	     * Constructs a Partial with no fields or values, which can be considered	     * to represent any date.	     * <p>	     * This is most useful when constructing partials, for example:	     * <pre>	     * Partial p = new Partial(chrono)	     *     .with(DateTimeFieldType.dayOfWeek(), 5)	     *     .with(DateTimeFieldType.hourOfDay(), 12)	     *     .with(DateTimeFieldType.minuteOfHour(), 20);	     * </pre>	     * Note that, although this is a clean way to write code, it is fairly	     * inefficient internally.	     *	     * @param chrono  the chronology, null means ISO	     */	    public Partial(Chronology chrono) {	        super();	        iChronology = DateTimeUtils.getChronology(chrono).withUTC();	        iTypes = new DateTimeFieldType[0];	        iValues = new int[0];	    }	
/**	     * Constructs a Partial with the specified field and value.	     * <p>	     * The constructor uses the default ISO chronology.	     * 	     * @param type  the single type to create the partial from, not null	     * @param value  the value to store	     * @throws IllegalArgumentException if the type or value is invalid	     */	    public Partial(DateTimeFieldType type, int value) {	        this(type, value, null);	    }	
/**	     * Constructs a Partial with the specified field and value.	     * <p>	     * The constructor uses the specified chronology.	     * 	     * @param type  the single type to create the partial from, not null	     * @param value  the value to store	     * @param chronology  the chronology, null means ISO	     * @throws IllegalArgumentException if the type or value is invalid	     */	    public Partial(DateTimeFieldType type, int value, Chronology chronology) {	        super();	        chronology = DateTimeUtils.getChronology(chronology).withUTC();	        iChronology = chronology;	        if (type == null) {	            throw new IllegalArgumentException("The field type must not be null");	        }	        iTypes = new DateTimeFieldType[] {type};	        iValues = new int[] {value};	        chronology.validate(this, iValues);	    }	
/**	     * Constructs a Partial with the specified fields and values.	     * The fields must be specified in the order largest to smallest.	     * <p>	     * The constructor uses the specified chronology.	     * 	     * @param types  the types to create the partial from, not null	     * @param values  the values to store, not null	     * @throws IllegalArgumentException if the types or values are invalid	     */	    public Partial(DateTimeFieldType[] types, int[] values) {	        this(types, values, null);	    }	
/**	     * Constructs a Partial with the specified fields and values.	     * The fields must be specified in the order largest to smallest.	     * <p>	     * The constructor uses the specified chronology.	     * 	     * @param types  the types to create the partial from, not null	     * @param values  the values to store, not null	     * @param chronology  the chronology, null means ISO	     * @throws IllegalArgumentException if the types or values are invalid	     */	    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {	        super();	        chronology = DateTimeUtils.getChronology(chronology).withUTC();	        iChronology = chronology;	        if (types == null) {	            throw new IllegalArgumentException("Types array must not be null");	        }	        if (values == null) {	            throw new IllegalArgumentException("Values array must not be null");	        }	        if (values.length != types.length) {	            throw new IllegalArgumentException("Values array must be the same length as the types array");	        }	        if (types.length == 0) {	            iTypes = types;	            iValues = values;	            return;	        }	        for (int i = 0; i < types.length; i++) {	            if (types[i] == null) {	                throw new IllegalArgumentException("Types array must not contain null: index " + i);	            }	        }	        DurationField lastUnitField = null;	        for (int i = 0; i < types.length; i++) {	            DateTimeFieldType loopType = types[i];	            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);	            if (i > 0) {	                int compare = lastUnitField.compareTo(loopUnitField);	                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {	                    throw new IllegalArgumentException("Types array must be in order largest-smallest: " +	                            types[i - 1].getName() + " < " + loopType.getName());	                } else if (compare == 0) {	                    if (types[i - 1].getRangeDurationType() == null) {	                        if (loopType.getRangeDurationType() == null) {	                            throw new IllegalArgumentException("Types array must not contain duplicate: " + loopType.getName());	                        }	                    } else {	                        if (loopType.getRangeDurationType() == null) {	                            throw new IllegalArgumentException("Types array must be in order largest-smallest: " +	                                    types[i - 1].getName() + " < " + loopType.getName());	                        }	                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);	                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);	                        if (lastRangeField.compareTo(loopRangeField) < 0) {	                            throw new IllegalArgumentException("Types array must be in order largest-smallest: " +	                                    types[i - 1].getName() + " < " + loopType.getName());	                        }	                        if (lastRangeField.compareTo(loopRangeField) == 0) {	                            throw new IllegalArgumentException("Types array must not contain duplicate: " + loopType.getName());	                        }	                    }	                }	            }	            lastUnitField = loopUnitField;	        }	        	        iTypes = (DateTimeFieldType[]) types.clone();	        chronology.validate(this, values);	        iValues = (int[]) values.clone();	    }	
/**	     * Constructs a Partial by copying all the fields and types from	     * another partial.	     * <p>	     * This is most useful when copying from a YearMonthDay or TimeOfDay.	     */	    public Partial(ReadablePartial partial) {	        super();	        if (partial == null) {	            throw new IllegalArgumentException("The partial must not be null");	        }	        iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();	        iTypes = new DateTimeFieldType[partial.size()];	        iValues = new int[partial.size()];	        for (int i = 0; i < partial.size(); i++) {	            iTypes[i] = partial.getFieldType(i);	            iValues[i] = partial.getValue(i);	        }	    }	
/**	     * Constructs a Partial with the specified values.	     * This constructor assigns and performs no validation.	     * 	     * @param partial  the partial to copy	     * @param values  the values to store	     * @throws IllegalArgumentException if the types or values are invalid	     */	    Partial(Partial partial, int[] values) {	        super();	        iChronology = partial.iChronology;	        iTypes = partial.iTypes;	        iValues = values;	    }	
/**	     * Constructs a Partial with the specified chronology, fields and values.	     * This constructor assigns and performs no validation.	     * 	     * @param chronology  the chronology	     * @param types  the types to create the partial from	     * @param values  the values to store	     * @throws IllegalArgumentException if the types or values are invalid	     */	    Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {	        super();	        iChronology = chronology;	        iTypes = types;	        iValues = values;	    }	
/**	     * Gets the number of fields in this partial.	     * 	     * @return the field count	     */	    public int size() {	        return iTypes.length;	    }	
/**	     * Gets the chronology of the partial which is never null.	     * <p>	     * The {@link Chronology} is the calculation engine behind the partial and	     * provides conversion and validation of the fields in a particular calendar system.	     * 	     * @return the chronology, never null	     */	    public Chronology getChronology() {	        return iChronology;	    }	
/**	     * Gets the field for a specific index in the chronology specified.	     * 	     * @param index  the index to retrieve	     * @param chrono  the chronology to use	     * @return the field	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    protected DateTimeField getField(int index, Chronology chrono) {	        return iTypes[index].getField(chrono);	    }	
/**	     * Gets the field type at the specified index.	     *	     * @param index  the index to retrieve	     * @return the field at the specified index	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public DateTimeFieldType getFieldType(int index) {	        return iTypes[index];	    }	
/**	     * Gets an array of the field type of each of the fields that	     * this partial supports.	     * <p>	     * The fields are returned largest to smallest.	     *	     * @return the array of field types (cloned), largest to smallest	     */	    public DateTimeFieldType[] getFieldTypes() {	        return (DateTimeFieldType[]) iTypes.clone();	    }	
/**	     * Gets the value of the field at the specifed index.	     * 	     * @param index  the index	     * @return the value	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public int getValue(int index) {	        return iValues[index];	    }	
/**	     * Gets an array of the value of each of the fields that	     * this partial supports.	     * <p>	     * The fields are returned largest to smallest.	     * Each value corresponds to the same array index as <code>getFieldTypes()</code>	     *	     * @return the current values of each field (cloned), largest to smallest	     */	    public int[] getValues() {	        return (int[]) iValues.clone();	    }	
/**	     * Creates a new Partial instance with the specified chronology.	     * This instance is immutable and unaffected by this method call.	     * <p>	     * This method retains the values of the fields, thus the result will	     * typically refer to a different instant.	     * <p>	     * The time zone of the specified chronology is ignored, as Partial	     * operates without a time zone.	     *	     * @param newChronology  the new chronology, null means ISO	     * @return a copy of this datetime with a different chronology	     * @throws IllegalArgumentException if the values are invalid for the new chronology	     */	    public Partial withChronologyRetainFields(Chronology newChronology) {	        newChronology = DateTimeUtils.getChronology(newChronology);	        newChronology = newChronology.withUTC();	        if (newChronology == getChronology()) {	            return this;	        } else {	            Partial newPartial = new Partial(newChronology, iTypes, iValues);	            newChronology.validate(newPartial, iValues);	            return newPartial;	        }	    }	
/**	     * Gets a copy of this date with the specified field set to a new value.	     * <p>	     * If this partial did not previously support the field, the new one will.	     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.	     * <p>	     * For example, if the field type is <code>dayOfMonth</code> then the day	     * would be changed/added in the returned instance.	     *	     * @param fieldType  the field type to set, not null	     * @param value  the value to set	     * @return a copy of this instance with the field set	     * @throws IllegalArgumentException if the value is null or invalid	     */	    public Partial with(DateTimeFieldType fieldType, int value) {	        if (fieldType == null) {	            throw new IllegalArgumentException("The field type must not be null");	        }	        int index = indexOf(fieldType);	        if (index == -1) {	            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];	            int[] newValues = new int[newTypes.length];	            	            // find correct insertion point to keep largest-smallest order	            int i = 0;	            DurationField unitField = fieldType.getDurationType().getField(iChronology);	            if (unitField.isSupported()) {	                for (; i < iTypes.length; i++) {	                    DateTimeFieldType loopType = iTypes[i];	                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);	                    if (loopUnitField.isSupported()) {	                        int compare = unitField.compareTo(loopUnitField);	                        if (compare > 0) {	                            break;	                        } else if (compare == 0) {	                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);	                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);	                            if (rangeField.compareTo(loopRangeField) > 0) {	                                break;	                            }	                        }	                    }	                }	            }	            System.arraycopy(iTypes, 0, newTypes, 0, i);	            System.arraycopy(iValues, 0, newValues, 0, i);	            newTypes[i] = fieldType;	            newValues[i] = value;	            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);	            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);	            	            Partial newPartial = new Partial(iChronology, newTypes, newValues);	            iChronology.validate(newPartial, newValues);	            return newPartial;	        }	        if (value == getValue(index)) {	            return this;	        }	        int[] newValues = getValues();	        newValues = getField(index).set(this, index, newValues, value);	        return new Partial(this, newValues);	    }	
/**	     * Gets a copy of this date with the specified field removed.	     * <p>	     * If this partial did not previously support the field, no error occurs.	     *	     * @param fieldType  the field type to remove, may be null	     * @return a copy of this instance with the field removed	     */	    public Partial without(DateTimeFieldType fieldType) {	        int index = indexOf(fieldType);	        if (index != -1) {	            DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];	            int[] newValues = new int[size() - 1];	            System.arraycopy(iTypes, 0, newTypes, 0, index);	            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);	            System.arraycopy(iValues, 0, newValues, 0, index);	            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);	            Partial newPartial = new Partial(iChronology, newTypes, newValues);	            iChronology.validate(newPartial, newValues);	            return newPartial;	        }	        return this;	    }	
/**	     * Gets a copy of this Partial with the specified field set to a new value.	     * <p>	     * If this partial does not support the field, an exception is thrown.	     * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.	     * <p>	     * For example, if the field type is <code>dayOfMonth</code> then the day	     * would be changed in the returned instance if supported.	     *	     * @param fieldType  the field type to set, not null	     * @param value  the value to set	     * @return a copy of this instance with the field set	     * @throws IllegalArgumentException if the value is null or invalid	     */	    public Partial withField(DateTimeFieldType fieldType, int value) {	        int index = indexOfSupported(fieldType);	        if (value == getValue(index)) {	            return this;	        }	        int[] newValues = getValues();	        newValues = getField(index).set(this, index, newValues, value);	        return new Partial(this, newValues);	    }	
/**	     * Gets a copy of this Partial with the value of the specified field increased.	     * If this partial does not support the field, an exception is thrown.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * The addition will overflow into larger fields (eg. minute to hour).	     * However, it will not wrap around if the top maximum is reached.	     *	     * @param fieldType  the field type to add to, not null	     * @param amount  the amount to add	     * @return a copy of this instance with the field updated	     * @throws IllegalArgumentException if the value is null or invalid	     * @throws ArithmeticException if the new datetime exceeds the capacity	     */	    public Partial withFieldAdded(DurationFieldType fieldType, int amount) {	        int index = indexOfSupported(fieldType);	        if (amount == 0) {	            return this;	        }	        int[] newValues = getValues();	        newValues = getField(index).add(this, index, newValues, amount);	        return new Partial(this, newValues);	    }	
/**	     * Gets a copy of this Partial with the value of the specified field increased.	     * If this partial does not support the field, an exception is thrown.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * The addition will overflow into larger fields (eg. minute to hour).	     * If the maximum is reached, the addition will wra.	     *	     * @param fieldType  the field type to add to, not null	     * @param amount  the amount to add	     * @return a copy of this instance with the field updated	     * @throws IllegalArgumentException if the value is null or invalid	     * @throws ArithmeticException if the new datetime exceeds the capacity	     */	    public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {	        int index = indexOfSupported(fieldType);	        if (amount == 0) {	            return this;	        }	        int[] newValues = getValues();	        newValues = getField(index).addWrapPartial(this, index, newValues, amount);	        return new Partial(this, newValues);	    }	
/**	     * Gets a copy of this Partial with the specified period added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * Fields in the period that aren't present in the partial are ignored.	     * <p>	     * This method is typically used to add multiple copies of complex	     * period instances. Adding one field is best achieved using the method	     * {@link #withFieldAdded(DurationFieldType, int)}.	     * 	     * @param period  the period to add to this one, null means zero	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this instance with the period added	     * @throws ArithmeticException if the new datetime exceeds the capacity	     */	    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {	        if (period == null || scalar == 0) {	            return this;	        }	        int[] newValues = getValues();	        for (int i = 0; i < period.size(); i++) {	            DurationFieldType fieldType = period.getFieldType(i);	            int index = indexOf(fieldType);	            if (index >= 0) {	                newValues = getField(index).add(this, index, newValues,	                        FieldUtils.safeMultiply(period.getValue(i), scalar));	            }	        }	        return new Partial(this, newValues);	    }	
/**	     * Gets a copy of this instance with the specified period added.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     *	     * @param period  the duration to add to this one, null means zero	     * @return a copy of this instance with the period added	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public Partial plus(ReadablePeriod period) {	        return withPeriodAdded(period, 1);	    }	
/**	     * Gets a copy of this instance with the specified period take away.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     *	     * @param period  the period to reduce this instant by	     * @return a copy of this instance with the period taken away	     * @throws ArithmeticException if the new datetime exceeds the capacity of a long	     */	    public Partial minus(ReadablePeriod period) {	        return withPeriodAdded(period, -1);	    }	
/**	     * Gets the property object for the specified type, which contains	     * many useful methods for getting and manipulating the partial.	     * <p>	     * See also {@link ReadablePartial#get(DateTimeFieldType)}.	     *	     * @param type  the field type to get the property for, not null	     * @return the property object	     * @throws IllegalArgumentException if the field is null or unsupported	     */	    public Property property(DateTimeFieldType type) {	        return new Property(this, indexOfSupported(type));	    }	
/**	     * Does this partial match the specified instant.	     * <p>	     * A match occurs when all the fields of this partial are the same as the	     * corresponding fields on the specified instant.	     *	     * @param instant  an instant to check against, null means now in default zone	     * @return true if this partial matches the specified instant	     */	    public boolean isMatch(ReadableInstant instant) {	        long millis = DateTimeUtils.getInstantMillis(instant);	        Chronology chrono = DateTimeUtils.getInstantChronology(instant);	        for (int i = 0; i < iTypes.length; i++) {	            int value = iTypes[i].getField(chrono).get(millis);	            if (value != iValues[i]) {	                return false;	            }	        }	        return true;	    }	
/**	     * Does this partial match the specified partial.	     * <p>	     * A match occurs when all the fields of this partial are the same as the	     * corresponding fields on the specified partial.	     *	     * @param partial  a partial to check against, must not be null	     * @return true if this partial matches the specified partial	     * @throws IllegalArgumentException if the partial is null	     * @throws IllegalArgumentException if the fields of the two partials do not match	     * @since 1.5	     */	    public boolean isMatch(ReadablePartial partial) {	        if (partial == null) {	            throw new IllegalArgumentException("The partial must not be null");	        }	        for (int i = 0; i < iTypes.length; i++) {	            int value = partial.get(iTypes[i]);	            if (value != iValues[i]) {	                return false;	            }	        }	        return true;	    }	
/**	     * Gets a formatter suitable for the fields in this partial.	     * <p>	     * If there is no appropriate ISO format, null is returned.	     * This method may return a formatter that does not display all the	     * fields of the partial. This might occur when you have overlapping	     * fields, such as dayOfWeek and dayOfMonth.	     *	     * @return a formatter suitable for the fields in this partial, null	     *  if none is suitable	     */	    public DateTimeFormatter getFormatter() {	        DateTimeFormatter[] f = iFormatter;	        if (f == null) {	            if (size() == 0) {	                return null;	            }	            f = new DateTimeFormatter[2];	            try {	                List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));	                f[0] = ISODateTimeFormat.forFields(list, true, false);	                if (list.size() == 0) {	                    f[1] = f[0];	                }	            } catch (IllegalArgumentException ex) {	                // ignore	            }	            iFormatter = f;	        }	        return f[0];	    }	
/**	     * Output the date in an appropriate ISO8601 format.	     * <p>	     * This method will output the partial in one of two ways.	     * If {@link #getFormatter()}	     * <p>	     * If there is no appropriate ISO format a dump of the fields is output	     * via {@link #toStringList()}.	     * 	     * @return ISO8601 formatted string	     */	    public String toString() {	        DateTimeFormatter[] f = iFormatter;	        if (f == null) {	            getFormatter();	            f = iFormatter;	            if (f == null) {	                return toStringList();	            }	        }	        DateTimeFormatter f1 = f[1];	        if (f1 == null) {	            return toStringList();	        }	        return f1.print(this);	    }	
/**	     * Gets a string version of the partial that lists all the fields.	     * <p>	     * This method exists to provide a better debugging toString than	     * the standard toString. This method lists all the fields and their	     * values in a style similar to the collections framework.	     *	     * @return a toString format that lists all the fields	     */	    public String toStringList() {	        int size = size();	        StringBuffer buf = new StringBuffer(20 * size);	        buf.append('[');	        for (int i = 0; i < size; i++) {	            if (i > 0) {	                buf.append(',').append(' ');	            }	            buf.append(iTypes[i].getName());	            buf.append('=');	            buf.append(iValues[i]);	        }	        buf.append(']');	        return buf.toString();	    }	
/**	     * Output the date using the specified format pattern.	     * Unsupported fields will appear as special unicode characters.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @see org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern) {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).print(this);	    }	
/**	     * Output the date using the specified format pattern.	     * Unsupported fields will appear as special unicode characters.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @param locale  Locale to use, null means default	     * @see org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern, Locale locale) {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);	    }	
/**	         * Constructs a property.	         * 	         * @param partial  the partial instance	         * @param fieldIndex  the index in the partial	         */	        Property(Partial partial, int fieldIndex) {	            super();	            iPartial = partial;	            iFieldIndex = fieldIndex;	        }	
/**	         * Gets the field that this property uses.	         * 	         * @return the field	         */	        public DateTimeField getField() {	            return iPartial.getField(iFieldIndex);	        }	
/**	         * Gets the partial that this property belongs to.	         * 	         * @return the partial	         */	        protected ReadablePartial getReadablePartial() {	            return iPartial;	        }	
/**	         * Gets the partial that this property belongs to.	         * 	         * @return the partial	         */	        public Partial getPartial() {	            return iPartial;	        }	
/**	         * Gets the value of this field.	         * 	         * @return the field value	         */	        public int get() {	            return iPartial.getValue(iFieldIndex);	        }	
/**	         * Adds to the value of this field in a copy of this Partial.	         * <p>	         * The value will be added to this field. If the value is too large to be	         * added solely to this field then it will affect larger fields.	         * Smaller fields are unaffected.	         * <p>	         * If the result would be too large, beyond the maximum year, then an	         * IllegalArgumentException is thrown.	         * <p>	         * The Partial attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param valueToAdd  the value to add to the field in the copy	         * @return a copy of the Partial with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public Partial addToCopy(int valueToAdd) {	            int[] newValues = iPartial.getValues();	            newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);	            return new Partial(iPartial, newValues);	        }	
/**	         * Adds to the value of this field in a copy of this Partial wrapping	         * within this field if the maximum value is reached.	         * <p>	         * The value will be added to this field. If the value is too large to be	         * added solely to this field then it wraps within this field.	         * Other fields are unaffected.	         * <p>	         * For example,	         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.	         * <p>	         * The Partial attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param valueToAdd  the value to add to the field in the copy	         * @return a copy of the Partial with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public Partial addWrapFieldToCopy(int valueToAdd) {	            int[] newValues = iPartial.getValues();	            newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);	            return new Partial(iPartial, newValues);	        }	
/**	         * Sets this field in a copy of the Partial.	         * <p>	         * The Partial attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param value  the value to set the field in the copy to	         * @return a copy of the Partial with the field value changed	         * @throws IllegalArgumentException if the value isn't valid	         */	        public Partial setCopy(int value) {	            int[] newValues = iPartial.getValues();	            newValues = getField().set(iPartial, iFieldIndex, newValues, value);	            return new Partial(iPartial, newValues);	        }	
/**	         * Sets this field in a copy of the Partial to a parsed text value.	         * <p>	         * The Partial attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param text  the text value to set	         * @param locale  optional locale to use for selecting a text symbol	         * @return a copy of the Partial with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public Partial setCopy(String text, Locale locale) {	            int[] newValues = iPartial.getValues();	            newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale);	            return new Partial(iPartial, newValues);	        }	
/**	         * Sets this field in a copy of the Partial to a parsed text value.	         * <p>	         * The Partial attached to this property is unchanged by this call.	         * Instead, a new instance is returned.	         * 	         * @param text  the text value to set	         * @return a copy of the Partial with the field value changed	         * @throws IllegalArgumentException if the text value isn't valid	         */	        public Partial setCopy(String text) {	            return setCopy(text, null);	        }	
/**	         * Returns a new Partial with this field set to the maximum value	         * for this field.	         * <p>	         * The Partial attached to this property is unchanged by this call.	         *	         * @return a copy of the Partial with this field set to its maximum	         * @since 1.2	         */	        public Partial withMaximumValue() {	            return setCopy(getMaximumValue());	        }	
/**	         * Returns a new Partial with this field set to the minimum value	         * for this field.	         * <p>	         * The Partial attached to this property is unchanged by this call.	         *	         * @return a copy of the Partial with this field set to its minimum	         * @since 1.2	         */	        public Partial withMinimumValue() {	            return setCopy(getMinimumValue());	        }	
/**	     * Parses a {@code Instant} from the specified string.	     * <p>	     * This uses {@link ISODateTimeFormat#dateTimeParser()}.	     * 	     * @param str  the string to parse, not null	     * @since 2.0	     */	    @FromString	    public static Instant parse(String str) {	        return parse(str, ISODateTimeFormat.dateTimeParser());	    }	
/**	     * Parses a {@code Instant} from the specified string using a formatter.	     * 	     * @param str  the string to parse, not null	     * @param formatter  the formatter to use, not null	     * @since 2.0	     */	    public static Instant parse(String str, DateTimeFormatter formatter) {	        return formatter.parseDateTime(str).toInstant();	    }	
/**	     * Constructs an instance set to the current system millisecond time.	     */	    public Instant() {	        super();	        iMillis = DateTimeUtils.currentTimeMillis();	    }	
/**	     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z.	     * 	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     */	    public Instant(long instant) {	        super();	        iMillis = instant;	    }	
/**	     * Constructs an instance from an Object that represents a datetime.	     * <p>	     * The recognised object types are defined in {@link ConverterManager} and	     * include String, Calendar and Date.	     *	     * @param instant  the datetime object, null means now	     * @throws IllegalArgumentException if the instant is invalid	     */	    public Instant(Object instant) {	        super();	        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);	        iMillis = converter.getInstantMillis(instant, ISOChronology.getInstanceUTC());	    }	
/**	     * Get this object as an Instant by returning <code>this</code>.	     * 	     * @return <code>this</code>	     */	    public Instant toInstant() {	        return this;	    }	
/**	     * Gets a copy of this instant with different millis.	     * <p>	     * The returned object will be either be a new Instant or <code>this</code>.	     *	     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z	     * @return a copy of this instant with different millis	     */	    public Instant withMillis(long newMillis) {	        return (newMillis == iMillis ? this : new Instant(newMillis));	    }	
/**	     * Gets a copy of this instant with the specified duration added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * 	     * @param durationToAdd  the duration to add to this one	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this instant with the duration added	     * @throws ArithmeticException if the new instant exceeds the capacity of a long	     */	    public Instant withDurationAdded(long durationToAdd, int scalar) {	        if (durationToAdd == 0 || scalar == 0) {	            return this;	        }	        long instant = getChronology().add(getMillis(), durationToAdd, scalar);	        return withMillis(instant);	    }	
/**	     * Gets a copy of this instant with the specified duration added.	     * <p>	     * If the addition is zero, then <code>this</code> is returned.	     * 	     * @param durationToAdd  the duration to add to this one, null means zero	     * @param scalar  the amount of times to add, such as -1 to subtract once	     * @return a copy of this instant with the duration added	     * @throws ArithmeticException if the new instant exceeds the capacity of a long	     */	    public Instant withDurationAdded(ReadableDuration durationToAdd, int scalar) {	        if (durationToAdd == null || scalar == 0) {	            return this;	        }	        return withDurationAdded(durationToAdd.getMillis(), scalar);	    }	
/**	     * Gets a copy of this instant with the specified duration added.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * 	     * @param duration  the duration to add to this one	     * @return a copy of this instant with the duration added	     * @throws ArithmeticException if the new instant exceeds the capacity of a long	     */	    public Instant plus(long duration) {	        return withDurationAdded(duration, 1);	    }	
/**	     * Gets a copy of this instant with the specified duration added.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * 	     * @param duration  the duration to add to this one, null means zero	     * @return a copy of this instant with the duration added	     * @throws ArithmeticException if the new instant exceeds the capacity of a long	     */	    public Instant plus(ReadableDuration duration) {	        return withDurationAdded(duration, 1);	    }	
/**	     * Gets a copy of this instant with the specified duration taken away.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * 	     * @param duration  the duration to reduce this instant by	     * @return a copy of this instant with the duration taken away	     * @throws ArithmeticException if the new instant exceeds the capacity of a long	     */	    public Instant minus(long duration) {	        return withDurationAdded(duration, -1);	    }	
/**	     * Gets a copy of this instant with the specified duration taken away.	     * <p>	     * If the amount is zero or null, then <code>this</code> is returned.	     * 	     * @param duration  the duration to reduce this instant by	     * @return a copy of this instant with the duration taken away	     * @throws ArithmeticException if the new instant exceeds the capacity of a long	     */	    public Instant minus(ReadableDuration duration) {	        return withDurationAdded(duration, -1);	    }	
/**	     * Gets the milliseconds of the instant.	     * 	     * @return the number of milliseconds since 1970-01-01T00:00:00Z	     */	    public long getMillis() {	        return iMillis;	    }	
/**	     * Gets the chronology of the instant, which is ISO in the UTC zone.	     * <p>	     * This method returns {@link ISOChronology#getInstanceUTC()} which	     * corresponds to the definition of the Java epoch 1970-01-01T00:00:00Z.	     * 	     * @return ISO in the UTC zone	     */	    public Chronology getChronology() {	        return ISOChronology.getInstanceUTC();	    }	
/**	     * Get this object as a DateTime using ISOChronology in the default zone.	     * <p>	     * This method returns a DateTime object in the default zone.	     * This differs from the similarly named method on DateTime, DateMidnight	     * or MutableDateTime which retains the time zone. The difference is	     * because Instant really represents a time <i>without</i> a zone,	     * thus calling this method we really have no zone to 'retain' and	     * hence expect to switch to the default zone.	     * <p>	     * This method definition preserves compatibility with earlier versions	     * of Joda-Time.	     *	     * @return a DateTime using the same millis	     */	    public DateTime toDateTime() {	        return new DateTime(getMillis(), ISOChronology.getInstance());	    }	
/**	     * Get this object as a DateTime using ISOChronology in the default zone.	     * This method is identical to <code>toDateTime()</code>.	     * <p>	     * This method returns a DateTime object in the default zone.	     * This differs from the similarly named method on DateTime, DateMidnight	     * or MutableDateTime which retains the time zone. The difference is	     * because Instant really represents a time <i>without</i> a zone,	     * thus calling this method we really have no zone to 'retain' and	     * hence expect to switch to the default zone.	     * <p>	     * This method is deprecated because it is a duplicate of {@link #toDateTime()}.	     * However, removing it would cause the superclass implementation to be used,	     * which would create silent bugs in any caller depending on this implementation.	     * As such, the method itself is not currently planned to be removed.	     * <p>	     * This method definition preserves compatibility with earlier versions	     * of Joda-Time.	     *	     * @return a DateTime using the same millis with ISOChronology	     * @deprecated Use toDateTime() as it is identical	     */	    public DateTime toDateTimeISO() {	        return toDateTime();	    }	
/**	     * Get this object as a MutableDateTime using ISOChronology in the default zone.	     * <p>	     * This method returns a MutableDateTime object in the default zone.	     * This differs from the similarly named method on DateTime, DateMidnight	     * or MutableDateTime which retains the time zone. The difference is	     * because Instant really represents a time <i>without</i> a zone,	     * thus calling this method we really have no zone to 'retain' and	     * hence expect to switch to the default zone.	     * <p>	     * This method definition preserves compatibility with earlier versions	     * of Joda-Time.	     *	     * @return a MutableDateTime using the same millis	     */	    public MutableDateTime toMutableDateTime() {	        return new MutableDateTime(getMillis(), ISOChronology.getInstance());	    }	
/**	     * Get this object as a MutableDateTime using ISOChronology in the default zone.	     * This method is identical to <code>toMutableDateTime()</code>.	     * <p>	     * This method returns a MutableDateTime object in the default zone.	     * This differs from the similarly named method on DateTime, DateMidnight	     * or MutableDateTime which retains the time zone. The difference is	     * because Instant really represents a time <i>without</i> a zone,	     * thus calling this method we really have no zone to 'retain' and	     * hence expect to switch to the default zone.	     * <p>	     * This method is deprecated because it is a duplicate of {@link #toMutableDateTime()}.	     * However, removing it would cause the superclass implementation to be used,	     * which would create silent bugs in any caller depending on this implementation.	     * As such, the method itself is not currently planned to be removed.	     * <p>	     * This method definition preserves compatibility with earlier versions	     * of Joda-Time.	     *	     * @return a MutableDateTime using the same millis with ISOChronology	     * @deprecated Use toMutableDateTime() as it is identical	     */	    public MutableDateTime toMutableDateTimeISO() {	        return toMutableDateTime();	    }	
/**	     * Gets a type that defines all standard fields.	     * <ul>	     * <li>years	     * <li>months	     * <li>weeks	     * <li>days	     * <li>hours	     * <li>minutes	     * <li>seconds	     * <li>milliseconds	     * </ul>	     *	     * @return the period type	     */	    public static PeriodType standard() {	        PeriodType type = cStandard;	        if (type == null) {	            type = new PeriodType(	                "Standard",	                new DurationFieldType[] {	                    DurationFieldType.years(), DurationFieldType.months(),	                    DurationFieldType.weeks(), DurationFieldType.days(),	                    DurationFieldType.hours(), DurationFieldType.minutes(),	                    DurationFieldType.seconds(), DurationFieldType.millis(),	                },	                new int[] { 0, 1, 2, 3, 4, 5, 6, 7, }	            );	            cStandard = type;	        }	        return type;	    }	
/**	     * Gets a type that defines all standard fields except weeks.	     * <ul>	     * <li>years	     * <li>months	     * <li>days	     * <li>hours	     * <li>minutes	     * <li>seconds	     * <li>milliseconds	     * </ul>	     *	     * @return the period type	     */	    public static PeriodType yearMonthDayTime() {	        PeriodType type = cYMDTime;	        if (type == null) {	            type = new PeriodType(	                "YearMonthDayTime",	                new DurationFieldType[] {	                    DurationFieldType.years(), DurationFieldType.months(),	                    DurationFieldType.days(),	                    DurationFieldType.hours(), DurationFieldType.minutes(),	                    DurationFieldType.seconds(), DurationFieldType.millis(),	                },	                new int[] { 0, 1, -1, 2, 3, 4, 5, 6, }	            );	            cYMDTime = type;	        }	        return type;	    }	
/**	     * Gets a type that defines the year, month and day fields.	     * <ul>	     * <li>years	     * <li>months	     * <li>days	     * </ul>	     *	     * @return the period type	     * @since 1.1	     */	    public static PeriodType yearMonthDay() {	        PeriodType type = cYMD;	        if (type == null) {	            type = new PeriodType(	                "YearMonthDay",	                new DurationFieldType[] {	                    DurationFieldType.years(), DurationFieldType.months(),	                    DurationFieldType.days(),	                },	                new int[] { 0, 1, -1, 2, -1, -1, -1, -1, }	            );	            cYMD = type;	        }	        return type;	    }	
/**	     * Gets a type that defines all standard fields except months.	     * <ul>	     * <li>years	     * <li>weeks	     * <li>days	     * <li>hours	     * <li>minutes	     * <li>seconds	     * <li>milliseconds	     * </ul>	     *	     * @return the period type	     */	    public static PeriodType yearWeekDayTime() {	        PeriodType type = cYWDTime;	        if (type == null) {	            type = new PeriodType(	                "YearWeekDayTime",	                new DurationFieldType[] {	                    DurationFieldType.years(),	                    DurationFieldType.weeks(), DurationFieldType.days(),	                    DurationFieldType.hours(), DurationFieldType.minutes(),	                    DurationFieldType.seconds(), DurationFieldType.millis(),	                },	                new int[] { 0, -1, 1, 2, 3, 4, 5, 6, }	            );	            cYWDTime = type;	        }	        return type;	    }	
/**	     * Gets a type that defines year, week and day fields.	     * <ul>	     * <li>years	     * <li>weeks	     * <li>days	     * </ul>	     *	     * @return the period type	     * @since 1.1	     */	    public static PeriodType yearWeekDay() {	        PeriodType type = cYWD;	        if (type == null) {	            type = new PeriodType(	                "YearWeekDay",	                new DurationFieldType[] {	                    DurationFieldType.years(),	                    DurationFieldType.weeks(), DurationFieldType.days(),	                },	                new int[] { 0, -1, 1, 2, -1, -1, -1, -1, }	            );	            cYWD = type;	        }	        return type;	    }	
/**	     * Gets a type that defines all standard fields except months and weeks.	     * <ul>	     * <li>years	     * <li>days	     * <li>hours	     * <li>minutes	     * <li>seconds	     * <li>milliseconds	     * </ul>	     *	     * @return the period type	     */	    public static PeriodType yearDayTime() {	        PeriodType type = cYDTime;	        if (type == null) {	            type = new PeriodType(	                "YearDayTime",	                new DurationFieldType[] {	                    DurationFieldType.years(), DurationFieldType.days(),	                    DurationFieldType.hours(), DurationFieldType.minutes(),	                    DurationFieldType.seconds(), DurationFieldType.millis(),	                },	                new int[] { 0, -1, -1, 1, 2, 3, 4, 5, }	            );	            cYDTime = type;	        }	        return type;	    }	
/**	     * Gets a type that defines the year and day fields.	     * <ul>	     * <li>years	     * <li>days	     * </ul>	     *	     * @return the period type	     * @since 1.1	     */	    public static PeriodType yearDay() {	        PeriodType type = cYD;	        if (type == null) {	            type = new PeriodType(	                "YearDay",	                new DurationFieldType[] {	                    DurationFieldType.years(), DurationFieldType.days(),	                },	                new int[] { 0, -1, -1, 1, -1, -1, -1, -1, }	            );	            cYD = type;	        }	        return type;	    }	
/**	     * Gets a type that defines all standard fields from days downwards.	     * <ul>	     * <li>days	     * <li>hours	     * <li>minutes	     * <li>seconds	     * <li>milliseconds	     * </ul>	     *	     * @return the period type	     */	    public static PeriodType dayTime() {	        PeriodType type = cDTime;	        if (type == null) {	            type = new PeriodType(	                "DayTime",	                new DurationFieldType[] {	                    DurationFieldType.days(),	                    DurationFieldType.hours(), DurationFieldType.minutes(),	                    DurationFieldType.seconds(), DurationFieldType.millis(),	                },	                new int[] { -1, -1, -1, 0, 1, 2, 3, 4, }	            );	            cDTime = type;	        }	        return type;	    }	
/**	     * Gets a type that defines all standard time fields.	     * <ul>	     * <li>hours	     * <li>minutes	     * <li>seconds	     * <li>milliseconds	     * </ul>	     *	     * @return the period type	     */	    public static PeriodType time() {	        PeriodType type = cTime;	        if (type == null) {	            type = new PeriodType(	                "Time",	                new DurationFieldType[] {	                    DurationFieldType.hours(), DurationFieldType.minutes(),	                    DurationFieldType.seconds(), DurationFieldType.millis(),	                },	                new int[] { -1, -1, -1, -1, 0, 1, 2, 3, }	            );	            cTime = type;	        }	        return type;	    }	
/**	     * Gets a type that defines just the years field.	     *	     * @return the period type	     */	    public static PeriodType years() {	        PeriodType type = cYears;	        if (type == null) {	            type = new PeriodType(	                "Years",	                new DurationFieldType[] { DurationFieldType.years() },	                new int[] { 0, -1, -1, -1, -1, -1, -1, -1, }	            );	            cYears = type;	        }	        return type;	    }	
/**	     * Gets a type that defines just the months field.	     *	     * @return the period type	     */	    public static PeriodType months() {	        PeriodType type = cMonths;	        if (type == null) {	            type = new PeriodType(	                "Months",	                new DurationFieldType[] { DurationFieldType.months() },	                new int[] { -1, 0, -1, -1, -1, -1, -1, -1, }	            );	            cMonths = type;	        }	        return type;	    }	
/**	     * Gets a type that defines just the weeks field.	     *	     * @return the period type	     */	    public static PeriodType weeks() {	        PeriodType type = cWeeks;	        if (type == null) {	            type = new PeriodType(	                "Weeks",	                new DurationFieldType[] { DurationFieldType.weeks() },	                new int[] { -1, -1, 0, -1, -1, -1, -1, -1, }	            );	            cWeeks = type;	        }	        return type;	    }	
/**	     * Gets a type that defines just the days field.	     *	     * @return the period type	     */	    public static PeriodType days() {	        PeriodType type = cDays;	        if (type == null) {	            type = new PeriodType(	                "Days",	                new DurationFieldType[] { DurationFieldType.days() },	                new int[] { -1, -1, -1, 0, -1, -1, -1, -1, }	            );	            cDays = type;	        }	        return type;	    }	
/**	     * Gets a type that defines just the hours field.	     *	     * @return the period type	     */	    public static PeriodType hours() {	        PeriodType type = cHours;	        if (type == null) {	            type = new PeriodType(	                "Hours",	                new DurationFieldType[] { DurationFieldType.hours() },	                new int[] { -1, -1, -1, -1, 0, -1, -1, -1, }	            );	            cHours = type;	        }	        return type;	    }	
/**	     * Gets a type that defines just the minutes field.	     *	     * @return the period type	     */	    public static PeriodType minutes() {	        PeriodType type = cMinutes;	        if (type == null) {	            type = new PeriodType(	                "Minutes",	                new DurationFieldType[] { DurationFieldType.minutes() },	                new int[] { -1, -1, -1, -1, -1, 0, -1, -1, }	            );	            cMinutes = type;	        }	        return type;	    }	
/**	     * Gets a type that defines just the seconds field.	     *	     * @return the period type	     */	    public static PeriodType seconds() {	        PeriodType type = cSeconds;	        if (type == null) {	            type = new PeriodType(	                "Seconds",	                new DurationFieldType[] { DurationFieldType.seconds() },	                new int[] { -1, -1, -1, -1, -1, -1, 0, -1, }	            );	            cSeconds = type;	        }	        return type;	    }	
/**	     * Gets a type that defines just the millis field.	     *	     * @return the period type	     */	    public static PeriodType millis() {	        PeriodType type = cMillis;	        if (type == null) {	            type = new PeriodType(	                "Millis",	                new DurationFieldType[] { DurationFieldType.millis() },	                new int[] { -1, -1, -1, -1, -1, -1, -1, 0, }	            );	            cMillis = type;	        }	        return type;	    }	
/**	     * Gets a period type that contains the duration types of the array.	     * <p>	     * Only the 8 standard duration field types are supported.	     *	     * @param types  the types to include in the array.	     * @return the period type	     * @since 1.1	     */	    public static synchronized PeriodType forFields(DurationFieldType[] types) {	        if (types == null || types.length == 0) {	            throw new IllegalArgumentException("Types array must not be null or empty");	        }	        for (int i = 0; i < types.length; i++) {	            if (types[i] == null) {	                throw new IllegalArgumentException("Types array must not contain null");	            }	        }	        Map<PeriodType, Object> cache = cTypes;	        if (cache.isEmpty()) {	            cache.put(standard(), standard());	            cache.put(yearMonthDayTime(), yearMonthDayTime());	            cache.put(yearMonthDay(), yearMonthDay());	            cache.put(yearWeekDayTime(), yearWeekDayTime());	            cache.put(yearWeekDay(), yearWeekDay());	            cache.put(yearDayTime(), yearDayTime());	            cache.put(yearDay(), yearDay());	            cache.put(dayTime(), dayTime());	            cache.put(time(), time());	            cache.put(years(), years());	            cache.put(months(), months());	            cache.put(weeks(), weeks());	            cache.put(days(), days());	            cache.put(hours(), hours());	            cache.put(minutes(), minutes());	            cache.put(seconds(), seconds());	            cache.put(millis(), millis());	        }	        PeriodType inPartType = new PeriodType(null, types, null);	        Object cached = cache.get(inPartType);	        if (cached instanceof PeriodType) {	            return (PeriodType) cached;	        }	        if (cached != null) {	            throw new IllegalArgumentException("PeriodType does not support fields: " + cached);	        }	        PeriodType type = standard();	        List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types));	        if (list.remove(DurationFieldType.years()) == false) {	            type = type.withYearsRemoved();	        }	        if (list.remove(DurationFieldType.months()) == false) {	            type = type.withMonthsRemoved();	        }	        if (list.remove(DurationFieldType.weeks()) == false) {	            type = type.withWeeksRemoved();	        }	        if (list.remove(DurationFieldType.days()) == false) {	            type = type.withDaysRemoved();	        }	        if (list.remove(DurationFieldType.hours()) == false) {	            type = type.withHoursRemoved();	        }	        if (list.remove(DurationFieldType.minutes()) == false) {	            type = type.withMinutesRemoved();	        }	        if (list.remove(DurationFieldType.seconds()) == false) {	            type = type.withSecondsRemoved();	        }	        if (list.remove(DurationFieldType.millis()) == false) {	            type = type.withMillisRemoved();	        }	        if (list.size() > 0) {	            cache.put(inPartType, list);	            throw new IllegalArgumentException("PeriodType does not support fields: " + list);	        }	        // recheck cache in case initial array order was wrong	        PeriodType checkPartType = new PeriodType(null, type.iTypes, null);	        PeriodType checkedType = (PeriodType) cache.get(checkPartType);	        if (checkedType != null) {	            cache.put(inPartType, checkedType);	            return checkedType;	        }	        cache.put(inPartType, type);	        return type;	    }	
/**	     * Constructor.	     *	     * @param name  the name	     * @param types  the types	     * @param indices  the indices	     */	    protected PeriodType(String name, DurationFieldType[] types, int[] indices) {	        super();	        iName = name;	        iTypes = types;	        iIndices = indices;	    }	
/**	     * Gets the name of the period type.	     * 	     * @return the name	     */	    public String getName() {	        return iName;	    }	
/**	     * Gets the number of fields in the period type.	     * 	     * @return the number of fields	     */	    public int size() {	        return iTypes.length;	    }	
/**	     * Gets the field type by index.	     * 	     * @param index  the index to retrieve	     * @return the field type	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public DurationFieldType getFieldType(int index) {	        return iTypes[index];	    }	
/**	     * Checks whether the field specified is supported by this period.	     *	     * @param type  the type to check, may be null which returns false	     * @return true if the field is supported	     */	    public boolean isSupported(DurationFieldType type) {	        return (indexOf(type) >= 0);	    }	
/**	     * Gets the index of the field in this period.	     *	     * @param type  the type to check, may be null which returns -1	     * @return the index of -1 if not supported	     */	    public int indexOf(DurationFieldType type) {	        for (int i = 0, isize = size(); i < isize; i++) {	            if (iTypes[i] == type) {	                return i;	            }	        }	        return -1;	    }	
/**	     * Gets a debugging to string.	     * 	     * @return a string	     */	    public String toString() {	        return "PeriodType[" + getName() + "]";	    }	
/**	     * Gets the indexed field part of the period.	     * 	     * @param period  the period to query	     * @param index  the index to use	     * @return the value of the field, zero if unsupported	     */	    int getIndexedField(ReadablePeriod period, int index) {	        int realIndex = iIndices[index];	        return (realIndex == -1 ? 0 : period.getValue(realIndex));	    }	
/**	     * Sets the indexed field part of the period.	     * 	     * @param period  the period to query	     * @param index  the index to use	     * @param values  the array to populate	     * @param newValue  the value to set	     * @throws UnsupportedOperationException if not supported	     */	    boolean setIndexedField(ReadablePeriod period, int index, int[] values, int newValue) {	        int realIndex = iIndices[index];	        if (realIndex == -1) {	            throw new UnsupportedOperationException("Field is not supported");	        }	        values[realIndex] = newValue;	        return true;	    }	
/**	     * Adds to the indexed field part of the period.	     * 	     * @param period  the period to query	     * @param index  the index to use	     * @param values  the array to populate	     * @param valueToAdd  the value to add	     * @return true if the array is updated	     * @throws UnsupportedOperationException if not supported	     */	    boolean addIndexedField(ReadablePeriod period, int index, int[] values, int valueToAdd) {	        if (valueToAdd == 0) {	            return false;	        }	        int realIndex = iIndices[index];	        if (realIndex == -1) {	            throw new UnsupportedOperationException("Field is not supported");	        }	        values[realIndex] = FieldUtils.safeAdd(values[realIndex], valueToAdd);	        return true;	    }	
/**	     * Returns a version of this PeriodType instance that does not support years.	     * 	     * @return a new period type that supports the original set of fields except years	     */	    public PeriodType withYearsRemoved() {	        return withFieldRemoved(0, "NoYears");	    }	
/**	     * Returns a version of this PeriodType instance that does not support months.	     * 	     * @return a new period type that supports the original set of fields except months	     */	    public PeriodType withMonthsRemoved() {	        return withFieldRemoved(1, "NoMonths");	    }	
/**	     * Returns a version of this PeriodType instance that does not support weeks.	     * 	     * @return a new period type that supports the original set of fields except weeks	     */	    public PeriodType withWeeksRemoved() {	        return withFieldRemoved(2, "NoWeeks");	    }	
/**	     * Returns a version of this PeriodType instance that does not support days.	     * 	     * @return a new period type that supports the original set of fields except days	     */	    public PeriodType withDaysRemoved() {	        return withFieldRemoved(3, "NoDays");	    }	
/**	     * Returns a version of this PeriodType instance that does not support hours.	     * 	     * @return a new period type that supports the original set of fields except hours	     */	    public PeriodType withHoursRemoved() {	        return withFieldRemoved(4, "NoHours");	    }	
/**	     * Returns a version of this PeriodType instance that does not support minutes.	     * 	     * @return a new period type that supports the original set of fields except minutes	     */	    public PeriodType withMinutesRemoved() {	        return withFieldRemoved(5, "NoMinutes");	    }	
/**	     * Returns a version of this PeriodType instance that does not support seconds.	     * 	     * @return a new period type that supports the original set of fields except seconds	     */	    public PeriodType withSecondsRemoved() {	        return withFieldRemoved(6, "NoSeconds");	    }	
/**	     * Returns a version of this PeriodType instance that does not support milliseconds.	     * 	     * @return a new period type that supports the original set of fields except milliseconds	     */	    public PeriodType withMillisRemoved() {	        return withFieldRemoved(7, "NoMillis");	    }	
/**	     * Removes the field specified by indices index.	     * 	     * @param indicesIndex  the index to remove	     * @param name  the name addition	     * @return the new type	     */	    private PeriodType withFieldRemoved(int indicesIndex, String name) {	        int fieldIndex = iIndices[indicesIndex];	        if (fieldIndex == -1) {	            return this;	        }	        	        DurationFieldType[] types = new DurationFieldType[size() - 1];	        for (int i = 0; i < iTypes.length; i++) {	            if (i < fieldIndex) {	                types[i] = iTypes[i];	            } else if (i > fieldIndex) {	                types[i - 1] = iTypes[i];	            }	        }	        	        int[] indices = new int[8];	        for (int i = 0; i < indices.length; i++) {	            if (i < indicesIndex) {	                indices[i] = iIndices[i];	            } else if (i > indicesIndex) {	                indices[i] = (iIndices[i] == -1 ? -1 : iIndices[i] - 1);	            } else {	                indices[i] = -1;	            }	        }	        return new PeriodType(getName() + name, types, indices);	    }	
/**	     * Compares this type to another object.	     * To be equal, the object must be a PeriodType with the same set of fields.	     * 	     * @param obj  the object to compare to	     * @return true if equal	     */	    public boolean equals(Object obj) {	        if (this == obj) {	            return true;	        }	        if (obj instanceof PeriodType == false) {	            return false;	        }	        PeriodType other = (PeriodType) obj;	        return (Arrays.equals(iTypes, other.iTypes));	    }	
/**	     * Returns a hashcode based on the field types.	     * 	     * @return a suitable hashcode	     */	    public int hashCode() {	        int hash = 0;	        for (int i = 0; i < iTypes.length; i++) {	            hash += iTypes[i].hashCode();	        }	        return hash;	    }	
/**	     * Creates a message for the exception.	     *	     * @param fieldName  the field name	     * @param value  the value rejected	     * @param lowerBound  the lower bound allowed	     * @param upperBound  the uppe bound allowed	     * @param explain  an explanation	     * @return the message	     */	    private static String createMessage(String fieldName, Number value,	                                        Number lowerBound, Number upperBound, String explain) {	        StringBuffer buf = new StringBuffer()	            .append("Value ").append(value).append(" for ").append(fieldName).append(' ');		        if (lowerBound == null) {	            if (upperBound == null) {	                buf.append("is not supported");	            } else {	                buf.append("must not be larger than ").append(upperBound);	            }	        } else if (upperBound == null) {	            buf.append("must not be smaller than ").append(lowerBound);	        } else {	            buf.append("must be in the range [")	                .append(lowerBound)	                .append(',')	                .append(upperBound)	                .append(']');	        }	        if (explain != null) {	            buf.append(": ").append(explain);	        }		        return buf.toString();	    }	
/**	     * Creates a message for the exception.	     *	     * @param fieldName  the field name	     * @param value  the value rejected	     * @return the message	     */	    private static String createMessage(String fieldName, String value) {	        StringBuffer buf = new StringBuffer().append("Value ");		        if (value == null) {	            buf.append("null");	        } else {	            buf.append('"');	            buf.append(value);	            buf.append('"');	        }		        buf.append(" for ").append(fieldName).append(' ').append("is not supported");	        	        return buf.toString();	    }	
/**	     * Constructor.	     * 	     * @param fieldType  type of field being set	     * @param value  illegal value being set	     * @param lowerBound  lower legal field value, or null if not applicable	     * @param upperBound  upper legal field value, or null if not applicable	     */	    public IllegalFieldValueException(DateTimeFieldType fieldType,	                                      Number value, Number lowerBound, Number upperBound) {	        super(createMessage(fieldType.getName(), value, lowerBound, upperBound, null));	        iDateTimeFieldType = fieldType;	        iDurationFieldType = null;	        iFieldName = fieldType.getName();	        iNumberValue = value;	        iStringValue = null;	        iLowerBound = lowerBound;	        iUpperBound = upperBound;	        iMessage = super.getMessage();	    }	
/**	     * Constructor.	     * 	     * @param fieldType  type of field being set	     * @param value  illegal value being set	     * @param explain  an explanation	     * @since 1.5	     */	    public IllegalFieldValueException(DateTimeFieldType fieldType,	                                      Number value, String explain) {	        super(createMessage(fieldType.getName(), value, null, null, explain));	        iDateTimeFieldType = fieldType;	        iDurationFieldType = null;	        iFieldName = fieldType.getName();	        iNumberValue = value;	        iStringValue = null;	        iLowerBound = null;	        iUpperBound = null;	        iMessage = super.getMessage();	    }	
/**	     * Constructor.	     * 	     * @param fieldType  type of field being set	     * @param value  illegal value being set	     * @param lowerBound  lower legal field value, or null if not applicable	     * @param upperBound  upper legal field value, or null if not applicable	     */	    public IllegalFieldValueException(DurationFieldType fieldType,	                                      Number value, Number lowerBound, Number upperBound) {	        super(createMessage(fieldType.getName(), value, lowerBound, upperBound, null));	        iDateTimeFieldType = null;	        iDurationFieldType = fieldType;	        iFieldName = fieldType.getName();	        iNumberValue = value;	        iStringValue = null;	        iLowerBound = lowerBound;	        iUpperBound = upperBound;	        iMessage = super.getMessage();	    }	
/**	     * Constructor.	     * 	     * @param fieldName  name of field being set	     * @param value  illegal value being set	     * @param lowerBound  lower legal field value, or null if not applicable	     * @param upperBound  upper legal field value, or null if not applicable	     */	    public IllegalFieldValueException(String fieldName,	                                      Number value, Number lowerBound, Number upperBound) {	        super(createMessage(fieldName, value, lowerBound, upperBound, null));	        iDateTimeFieldType = null;	        iDurationFieldType = null;	        iFieldName = fieldName;	        iNumberValue = value;	        iStringValue = null;	        iLowerBound = lowerBound;	        iUpperBound = upperBound;	        iMessage = super.getMessage();	    }	
/**	     * Constructor.	     * 	     * @param fieldType  type of field being set	     * @param value  illegal value being set	     */	    public IllegalFieldValueException(DateTimeFieldType fieldType, String value) {	        super(createMessage(fieldType.getName(), value));	        iDateTimeFieldType = fieldType;	        iDurationFieldType = null;	        iFieldName = fieldType.getName();	        iStringValue = value;	        iNumberValue = null;	        iLowerBound = null;	        iUpperBound = null;	        iMessage = super.getMessage();	    }	
/**	     * Constructor.	     * 	     * @param fieldType  type of field being set	     * @param value  illegal value being set	     */	    public IllegalFieldValueException(DurationFieldType fieldType, String value) {	        super(createMessage(fieldType.getName(), value));	        iDateTimeFieldType = null;	        iDurationFieldType = fieldType;	        iFieldName = fieldType.getName();	        iStringValue = value;	        iNumberValue = null;	        iLowerBound = null;	        iUpperBound = null;	        iMessage = super.getMessage();	    }	
/**	     * Constructor.	     * 	     * @param fieldName  name of field being set	     * @param value  illegal value being set	     */	    public IllegalFieldValueException(String fieldName, String value) {	        super(createMessage(fieldName, value));	        iDateTimeFieldType = null;	        iDurationFieldType = null;	        iFieldName = fieldName;	        iStringValue = value;	        iNumberValue = null;	        iLowerBound = null;	        iUpperBound = null;	        iMessage = super.getMessage();	    }	
/**	     * Returns the DateTimeFieldType whose value was invalid, or null if not applicable.	     * 	     * @return the datetime field type	     */	    public DateTimeFieldType getDateTimeFieldType() {	        return iDateTimeFieldType;	    }	
/**	     * Returns the DurationFieldType whose value was invalid, or null if not applicable.	     * 	     * @return the duration field type	     */	    public DurationFieldType getDurationFieldType() {	        return iDurationFieldType;	    }	
/**	     * Returns the name of the field whose value was invalid.	     * 	     * @return the field name	     */	    public String getFieldName() {	        return iFieldName;	    }	
/**	     * Returns the illegal integer value assigned to the field, or null if not applicable.	     * 	     * @return the value	     */	    public Number getIllegalNumberValue() {	        return iNumberValue;	    }	
/**	     * Returns the illegal string value assigned to the field, or null if not applicable.	     * 	     * @return the value	     */	    public String getIllegalStringValue() {	        return iStringValue;	    }	
/**	     * Returns the illegal value assigned to the field as a non-null string.	     * 	     * @return the value	     */	    public String getIllegalValueAsString() {	        String value = iStringValue;	        if (value == null) {	            value = String.valueOf(iNumberValue);	        }	        return value;	    }	
/**	     * Returns the lower bound of the legal value range, or null if not applicable.	     * 	     * @return the lower bound	     */	    public Number getLowerBound() {	        return iLowerBound;	    }	
/**	     * Returns the upper bound of the legal value range, or null if not applicable.	     * 	     * @return the upper bound	     */	    public Number getUpperBound() {	        return iUpperBound;	    }	
public String getMessage() {	        return iMessage;	    }	
/**	     * Provide additional detail by prepending a message to the existing message.	     * A colon is separator is automatically inserted between the messages.	     * @since 1.3	     */	    public void prependMessage(String message) {	        if (iMessage == null) {	            iMessage = message;	        } else if (message != null) {	            iMessage = message + ": " + iMessage;	        }	    }	
/**	     * Restricted constructor.	     */	    protected ReadableDurationConverter() {	        super();	    }	
/**	     * Extracts the millis from an object of this convertor's type.	     * 	     * @param object  the object to convert, must not be null	     * @return the millisecond value	     * @throws NullPointerException if the object is null	     * @throws ClassCastException if the object is an invalid type	     * @throws IllegalArgumentException if the object is invalid	     */	    public long getDurationMillis(Object object) {	        return ((ReadableDuration) object).getMillis();	    }	
/**	     * Extracts duration values from an object of this converter's type, and	     * sets them into the given ReadWritableDuration.	     *	     * @param writablePeriod  period to get modified	     * @param object  the object to convert, must not be null	     * @param chrono  the chronology to use, must not be null	     * @throws NullPointerException if the duration or object is null	     * @throws ClassCastException if the object is an invalid type	     * @throws IllegalArgumentException if the object is invalid	     */	    public void setInto(ReadWritablePeriod writablePeriod, Object object, Chronology chrono) {	        ReadableDuration dur = (ReadableDuration) object;	        chrono = DateTimeUtils.getChronology(chrono);	        long duration = dur.getMillis();	        int[] values = chrono.get(writablePeriod, duration);	        for (int i = 0; i < values.length; i++) {	            writablePeriod.setValue(i, values[i]);	        }	    }	
/**	     * Returns ReadableDuration.class.	     * 	     * @return ReadableDuration.class	     */	    public Class<?> getSupportedType() {	        return ReadableDuration.class;	    }	
/**	     * Restricted constructor.	     */	    protected NullConverter() {	        super();	    }	
/**	     * Gets the millisecond duration, which is zero.	     * 	     * @param object  the object to convert, which is null	     * @return the millisecond duration	     */	    public long getDurationMillis(Object object) {	        return 0L;	    }	
/**	     * Sets the given ReadWritableDuration to zero milliseconds.	     *	     * @param duration duration to get modified	     * @param object  the object to convert, which is null	     * @param chrono  the chronology to use	     * @throws NullPointerException if the duration is null	     */	    public void setInto(ReadWritablePeriod duration, Object object, Chronology chrono) {	        duration.setPeriod((Period) null);	    }	
/**	     * Extracts interval endpoint values from an object of this converter's	     * type, and sets them into the given ReadWritableInterval.	     *	     * @param writableInterval interval to get modified, not null	     * @param object  the object to convert, which is null	     * @param chrono  the chronology to use, may be null	     * @throws NullPointerException if the interval is null	     */	    public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) {	        writableInterval.setChronology(chrono);	        long now = DateTimeUtils.currentTimeMillis();	        writableInterval.setInterval(now, now);	    }	
/**	     * Returns null.	     * 	     * @return null	     */	    public Class<?> getSupportedType() {	        return null;	    }	
public static ConverterManager getInstance() {	        if (INSTANCE == null) {	            INSTANCE = new ConverterManager();	        }	        return INSTANCE;	    }	
/**	     * Restricted constructor.	     */	    protected ConverterManager() {	        super();		        iInstantConverters = new ConverterSet(new Converter[] {	            ReadableInstantConverter.INSTANCE,	            StringConverter.INSTANCE,	            CalendarConverter.INSTANCE,	            DateConverter.INSTANCE,	            LongConverter.INSTANCE,	            NullConverter.INSTANCE,	        });		        iPartialConverters = new ConverterSet(new Converter[] {	            ReadablePartialConverter.INSTANCE,	            ReadableInstantConverter.INSTANCE,	            StringConverter.INSTANCE,	            CalendarConverter.INSTANCE,	            DateConverter.INSTANCE,	            LongConverter.INSTANCE,	            NullConverter.INSTANCE,	        });		        iDurationConverters = new ConverterSet(new Converter[] {	            ReadableDurationConverter.INSTANCE,	            ReadableIntervalConverter.INSTANCE,	            StringConverter.INSTANCE,	            LongConverter.INSTANCE,	            NullConverter.INSTANCE,	        });		        iPeriodConverters = new ConverterSet(new Converter[] {	            ReadableDurationConverter.INSTANCE,	            ReadablePeriodConverter.INSTANCE,	            ReadableIntervalConverter.INSTANCE,	            StringConverter.INSTANCE,	            NullConverter.INSTANCE,	        });		        iIntervalConverters = new ConverterSet(new Converter[] {	            ReadableIntervalConverter.INSTANCE,	            StringConverter.INSTANCE,	            NullConverter.INSTANCE,	        });	    }	
/**	     * Gets the best converter for the object specified.	     * 	     * @param object  the object to convert	     * @return the converter to use	     * @throws IllegalArgumentException if no suitable converter	     * @throws IllegalStateException if multiple converters match the type	     * equally well	     */	    public InstantConverter getInstantConverter(Object object) {	        InstantConverter converter =	            (InstantConverter)iInstantConverters.select(object == null ? null : object.getClass());	        if (converter != null) {	            return converter;	        }	        throw new IllegalArgumentException("No instant converter found for type: " +	            (object == null ? "null" : object.getClass().getName()));	    }	
/**	     * Gets a copy of the set of converters.	     * 	     * @return the converters, a copy of the real data, never null	     */	    public InstantConverter[] getInstantConverters() {	        ConverterSet set = iInstantConverters;	        InstantConverter[] converters = new InstantConverter[set.size()];	        set.copyInto(converters);	        return converters;	    }	
/**	     * Adds a converter to the set of converters. If a matching converter is	     * already in the set, the given converter replaces it. If the converter is	     * exactly the same as one already in the set, no changes are made.	     * <p>	     * The order in which converters are added is not relevent. The best	     * converter is selected by examining the object hierarchy.	     * 	     * @param converter  the converter to add, null ignored	     * @return replaced converter, or null	     */	    public InstantConverter addInstantConverter(InstantConverter converter)	            throws SecurityException {	        	        checkAlterInstantConverters();	        if (converter == null) {	            return null;	        }	        InstantConverter[] removed = new InstantConverter[1];	        iInstantConverters = iInstantConverters.add(converter, removed);	        return removed[0];	    }	
/**	     * Removes a converter from the set of converters. If the converter was	     * not in the set, no changes are made.	     * 	     * @param converter  the converter to remove, null ignored	     * @return replaced converter, or null	     */	    public InstantConverter removeInstantConverter(InstantConverter converter)	            throws SecurityException {	        	        checkAlterInstantConverters();	        if (converter == null) {	            return null;	        }	        InstantConverter[] removed = new InstantConverter[1];	        iInstantConverters = iInstantConverters.remove(converter, removed);	        return removed[0];	    }	
/**	     * Checks whether the user has permission 'ConverterManager.alterInstantConverters'.	     * 	     * @throws SecurityException if the user does not have the permission	     */	    private void checkAlterInstantConverters() throws SecurityException {	        SecurityManager sm = System.getSecurityManager();	        if (sm != null) {	            sm.checkPermission(new JodaTimePermission("ConverterManager.alterInstantConverters"));	        }	    }	
/**	     * Gets the best converter for the object specified.	     * 	     * @param object  the object to convert	     * @return the converter to use	     * @throws IllegalArgumentException if no suitable converter	     * @throws IllegalStateException if multiple converters match the type	     * equally well	     */	    public PartialConverter getPartialConverter(Object object) {	        PartialConverter converter =	            (PartialConverter)iPartialConverters.select(object == null ? null : object.getClass());	        if (converter != null) {	            return converter;	        }	        throw new IllegalArgumentException("No partial converter found for type: " +	            (object == null ? "null" : object.getClass().getName()));	    }	
/**	     * Gets a copy of the set of converters.	     * 	     * @return the converters, a copy of the real data, never null	     */	    public PartialConverter[] getPartialConverters() {	        ConverterSet set = iPartialConverters;	        PartialConverter[] converters = new PartialConverter[set.size()];	        set.copyInto(converters);	        return converters;	    }	
/**	     * Adds a converter to the set of converters. If a matching converter is	     * already in the set, the given converter replaces it. If the converter is	     * exactly the same as one already in the set, no changes are made.	     * <p>	     * The order in which converters are added is not relevent. The best	     * converter is selected by examining the object hierarchy.	     * 	     * @param converter  the converter to add, null ignored	     * @return replaced converter, or null	     */	    public PartialConverter addPartialConverter(PartialConverter converter)	            throws SecurityException {	        	        checkAlterPartialConverters();	        if (converter == null) {	            return null;	        }	        PartialConverter[] removed = new PartialConverter[1];	        iPartialConverters = iPartialConverters.add(converter, removed);	        return removed[0];	    }	
/**	     * Removes a converter from the set of converters. If the converter was	     * not in the set, no changes are made.	     * 	     * @param converter  the converter to remove, null ignored	     * @return replaced converter, or null	     */	    public PartialConverter removePartialConverter(PartialConverter converter)	            throws SecurityException {	        	        checkAlterPartialConverters();	        if (converter == null) {	            return null;	        }	        PartialConverter[] removed = new PartialConverter[1];	        iPartialConverters = iPartialConverters.remove(converter, removed);	        return removed[0];	    }	
/**	     * Checks whether the user has permission 'ConverterManager.alterPartialConverters'.	     * 	     * @throws SecurityException if the user does not have the permission	     */	    private void checkAlterPartialConverters() throws SecurityException {	        SecurityManager sm = System.getSecurityManager();	        if (sm != null) {	            sm.checkPermission(new JodaTimePermission("ConverterManager.alterPartialConverters"));	        }	    }	
/**	     * Gets the best converter for the object specified.	     * 	     * @param object  the object to convert	     * @return the converter to use	     * @throws IllegalArgumentException if no suitable converter	     * @throws IllegalStateException if multiple converters match the type	     * equally well	     */	    public DurationConverter getDurationConverter(Object object) {	        DurationConverter converter =	            (DurationConverter)iDurationConverters.select(object == null ? null : object.getClass());	        if (converter != null) {	            return converter;	        }	        throw new IllegalArgumentException("No duration converter found for type: " +	            (object == null ? "null" : object.getClass().getName()));	    }	
/**	     * Gets a copy of the list of converters.	     * 	     * @return the converters, a copy of the real data, never null	     */	    public DurationConverter[] getDurationConverters() {	        ConverterSet set = iDurationConverters;	        DurationConverter[] converters = new DurationConverter[set.size()];	        set.copyInto(converters);	        return converters;	    }	
/**	     * Adds a converter to the set of converters. If a matching converter is	     * already in the set, the given converter replaces it. If the converter is	     * exactly the same as one already in the set, no changes are made.	     * <p>	     * The order in which converters are added is not relevent. The best	     * converter is selected by examining the object hierarchy.	     * 	     * @param converter  the converter to add, null ignored	     * @return replaced converter, or null	     */	    public DurationConverter addDurationConverter(DurationConverter converter)	            throws SecurityException {	        	        checkAlterDurationConverters();	        if (converter == null) {	            return null;	        }	        DurationConverter[] removed = new DurationConverter[1];	        iDurationConverters = iDurationConverters.add(converter, removed);	        return removed[0];	    }	
/**	     * Removes a converter from the set of converters. If the converter was	     * not in the set, no changes are made.	     * 	     * @param converter  the converter to remove, null ignored	     * @return replaced converter, or null	     */	    public DurationConverter removeDurationConverter(DurationConverter converter)	            throws SecurityException {	        	        checkAlterDurationConverters();	        if (converter == null) {	            return null;	        }	        DurationConverter[] removed = new DurationConverter[1];	        iDurationConverters = iDurationConverters.remove(converter, removed);	        return removed[0];	    }	
/**	     * Checks whether the user has permission 'ConverterManager.alterDurationConverters'.	     * 	     * @throws SecurityException if the user does not have the permission	     */	    private void checkAlterDurationConverters() throws SecurityException {	        SecurityManager sm = System.getSecurityManager();	        if (sm != null) {	            sm.checkPermission(new JodaTimePermission("ConverterManager.alterDurationConverters"));	        }	    }	
/**	     * Gets the best converter for the object specified.	     * 	     * @param object  the object to convert	     * @return the converter to use	     * @throws IllegalArgumentException if no suitable converter	     * @throws IllegalStateException if multiple converters match the type	     * equally well	     */	    public PeriodConverter getPeriodConverter(Object object) {	        PeriodConverter converter =	            (PeriodConverter)iPeriodConverters.select(object == null ? null : object.getClass());	        if (converter != null) {	            return converter;	        }	        throw new IllegalArgumentException("No period converter found for type: " +	            (object == null ? "null" : object.getClass().getName()));	    }	
/**	     * Gets a copy of the list of converters.	     * 	     * @return the converters, a copy of the real data, never null	     */	    public PeriodConverter[] getPeriodConverters() {	        ConverterSet set = iPeriodConverters;	        PeriodConverter[] converters = new PeriodConverter[set.size()];	        set.copyInto(converters);	        return converters;	    }	
/**	     * Adds a converter to the set of converters. If a matching converter is	     * already in the set, the given converter replaces it. If the converter is	     * exactly the same as one already in the set, no changes are made.	     * <p>	     * The order in which converters are added is not relevent. The best	     * converter is selected by examining the object hierarchy.	     * 	     * @param converter  the converter to add, null ignored	     * @return replaced converter, or null	     */	    public PeriodConverter addPeriodConverter(PeriodConverter converter)	            throws SecurityException {	        	        checkAlterPeriodConverters();	        if (converter == null) {	            return null;	        }	        PeriodConverter[] removed = new PeriodConverter[1];	        iPeriodConverters = iPeriodConverters.add(converter, removed);	        return removed[0];	    }	
/**	     * Removes a converter from the set of converters. If the converter was	     * not in the set, no changes are made.	     * 	     * @param converter  the converter to remove, null ignored	     * @return replaced converter, or null	     */	    public PeriodConverter removePeriodConverter(PeriodConverter converter)	            throws SecurityException {	        	        checkAlterPeriodConverters();	        if (converter == null) {	            return null;	        }	        PeriodConverter[] removed = new PeriodConverter[1];	        iPeriodConverters = iPeriodConverters.remove(converter, removed);	        return removed[0];	    }	
/**	     * Checks whether the user has permission 'ConverterManager.alterPeriodConverters'.	     * 	     * @throws SecurityException if the user does not have the permission	     */	    private void checkAlterPeriodConverters() throws SecurityException {	        SecurityManager sm = System.getSecurityManager();	        if (sm != null) {	            sm.checkPermission(new JodaTimePermission("ConverterManager.alterPeriodConverters"));	        }	    }	
/**	     * Gets the best converter for the object specified.	     * 	     * @param object  the object to convert	     * @return the converter to use	     * @throws IllegalArgumentException if no suitable converter	     * @throws IllegalStateException if multiple converters match the type	     * equally well	     */	    public IntervalConverter getIntervalConverter(Object object) {	        IntervalConverter converter =	            (IntervalConverter)iIntervalConverters.select(object == null ? null : object.getClass());	        if (converter != null) {	            return converter;	        }	        throw new IllegalArgumentException("No interval converter found for type: " +	            (object == null ? "null" : object.getClass().getName()));	    }	
/**	     * Gets a copy of the list of converters.	     * 	     * @return the converters, a copy of the real data, never null	     */	    public IntervalConverter[] getIntervalConverters() {	        ConverterSet set = iIntervalConverters;	        IntervalConverter[] converters = new IntervalConverter[set.size()];	        set.copyInto(converters);	        return converters;	    }	
/**	     * Adds a converter to the set of converters. If a matching converter is	     * already in the set, the given converter replaces it. If the converter is	     * exactly the same as one already in the set, no changes are made.	     * <p>	     * The order in which converters are added is not relevent. The best	     * converter is selected by examining the object hierarchy.	     * 	     * @param converter  the converter to add, null ignored	     * @return replaced converter, or null	     */	    public IntervalConverter addIntervalConverter(IntervalConverter converter) 	            throws SecurityException {	        	        checkAlterIntervalConverters();	        if (converter == null) {	            return null;	        }	        IntervalConverter[] removed = new IntervalConverter[1];	        iIntervalConverters = iIntervalConverters.add(converter, removed);	        return removed[0];	    }	
/**	     * Removes a converter from the set of converters. If the converter was	     * not in the set, no changes are made.	     * 	     * @param converter  the converter to remove, null ignored	     * @return replaced converter, or null	     */	    public IntervalConverter removeIntervalConverter(IntervalConverter converter)	            throws SecurityException {	        	        checkAlterIntervalConverters();	        if (converter == null) {	            return null;	        }	        IntervalConverter[] removed = new IntervalConverter[1];	        iIntervalConverters = iIntervalConverters.remove(converter, removed);	        return removed[0];	    }	
/**	     * Checks whether the user has permission 'ConverterManager.alterIntervalConverters'.	     * 	     * @throws SecurityException if the user does not have the permission	     */	    private void checkAlterIntervalConverters() throws SecurityException {	        SecurityManager sm = System.getSecurityManager();	        if (sm != null) {	            sm.checkPermission(new JodaTimePermission("ConverterManager.alterIntervalConverters"));	        }	    }	
/**	     * Gets a debug representation of the object.	     */	    public String toString() {	        return "ConverterManager[" +	            iInstantConverters.size() + " instant," +	            iPartialConverters.size() + " partial," +	            iDurationConverters.size() + " duration," +	            iPeriodConverters.size() + " period," +	            iIntervalConverters.size() + " interval]";	    }	
ConverterSet(Converter[] converters) {	        // Since this is a package private constructor, we trust ourselves not	        // to alter the array outside this class.	        iConverters = converters;	        iSelectEntries = new Entry[1 << 4]; // 16	    }	
/**	     * Returns the closest matching converter for the given type, or null if	     * none found.	     *	     * @param type type to select, which may be null	     * @throws IllegalStateException if multiple converters match the type	     * equally well	     */	    Converter select(Class<?> type) throws IllegalStateException {	        // Check the hashtable first.	        Entry[] entries = iSelectEntries;	        int length = entries.length;	        int index = type == null ? 0 : type.hashCode() & (length - 1);		        Entry e;	        // This loop depends on there being at least one null slot.	        while ((e = entries[index]) != null) {	            if (e.iType == type) {	                return e.iConverter;	            }	            if (++index >= length) {	                index = 0;	            }	        }		        // Not found in the hashtable, so do actual work.		        Converter converter = selectSlow(this, type);	        e = new Entry(type, converter);		        // Save the entry for future selects. This class must be threadsafe,	        // but there is no synchronization. Since the hashtable is being used	        // as a cache, it is okay to destroy existing entries. This isn't	        // likely to occur unless there is a high amount of concurrency. As	        // time goes on, cache updates will occur less often, and the cache	        // will fill with all the necessary entries.		        // Do all updates on a copy: slots in iSelectEntries must not be	        // updated by multiple threads as this can allow all null slots to be	        // consumed.	        entries = (Entry[])entries.clone();		        // Add new entry.	        entries[index] = e;		        // Verify that at least one null slot exists!	        for (int i=0; i<length; i++) {	            if (entries[i] == null) {	                // Found a null slot, swap in new hashtable.	                iSelectEntries = entries;	                return converter;	            }	        }		        // Double capacity and re-hash.		        int newLength = length << 1;	        Entry[] newEntries = new Entry[newLength];	        for (int i=0; i<length; i++) {	            e = entries[i];	            type = e.iType;	            index = type == null ? 0 : type.hashCode() & (newLength - 1);	            while (newEntries[index] != null) {	                if (++index >= newLength) {	                    index = 0;	                }	            }	            newEntries[index] = e;	        }		        // Swap in new hashtable.	        iSelectEntries = newEntries;	        return converter;	    }	
/**	     * Returns the amount of converters in the set.	     */	    int size() {	        return iConverters.length;	    }	
/**	     * Copies all the converters in the set to the given array.	     */	    void copyInto(Converter[] converters) {	        System.arraycopy(iConverters, 0, converters, 0, iConverters.length);	    }	
/**	     * Returns a copy of this set, with the given converter added. If a	     * matching converter is already in the set, the given converter replaces	     * it. If the converter is exactly the same as one already in the set, the	     * original set is returned.	     *	     * @param converter  converter to add, must not be null	     * @param removed  if not null, element 0 is set to the removed converter	     * @throws NullPointerException if converter is null	     */	    ConverterSet add(Converter converter, Converter[] removed) {	        Converter[] converters = iConverters;	        int length = converters.length;		        for (int i=0; i<length; i++) {	            Converter existing = converters[i];	            if (converter.equals(existing)) {	                // Already in the set.	                if (removed != null) {	                    removed[0] = null;	                }	                return this;	            }	            	            if (converter.getSupportedType() == existing.getSupportedType()) {	                // Replace the converter.	                Converter[] copy = new Converter[length];	                    	                for (int j=0; j<length; j++) {	                    if (j != i) {	                        copy[j] = converters[j];	                    } else {	                        copy[j] = converter;	                    }	                }		                if (removed != null) {	                    removed[0] = existing;	                }	                return new ConverterSet(copy);	            }	        }		        // Not found, so add it.	        Converter[] copy = new Converter[length + 1];	        System.arraycopy(converters, 0, copy, 0, length);	        copy[length] = converter;	        	        if (removed != null) {	            removed[0] = null;	        }	        return new ConverterSet(copy);	    }	
/**	     * Returns a copy of this set, with the given converter removed. If the	     * converter was not in the set, the original set is returned.	     *	     * @param converter  converter to remove, must not be null	     * @param removed  if not null, element 0 is set to the removed converter	     * @throws NullPointerException if converter is null	     */	    ConverterSet remove(Converter converter, Converter[] removed) {	        Converter[] converters = iConverters;	        int length = converters.length;		        for (int i=0; i<length; i++) {	            if (converter.equals(converters[i])) {	                return remove(i, removed);	            }	        }		        // Not found.	        if (removed != null) {	            removed[0] = null;	        }	        return this;	    }	
/**	     * Returns a copy of this set, with the converter at the given index	     * removed.	     *	     * @param index index of converter to remove	     * @param removed if not null, element 0 is set to the removed converter	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    ConverterSet remove(final int index, Converter[] removed) {	        Converter[] converters = iConverters;	        int length = converters.length;	        if (index >= length) {	            throw new IndexOutOfBoundsException();	        }		        if (removed != null) {	            removed[0] = converters[index];	        }		        Converter[] copy = new Converter[length - 1];	                	        int j = 0;	        for (int i=0; i<length; i++) {	            if (i != index) {	                copy[j++] = converters[i];	            }	        }	        	        return new ConverterSet(copy);	    }	
/**	     * Returns the closest matching converter for the given type, but not very	     * efficiently.	     */	    private static Converter selectSlow(ConverterSet set, Class<?> type) {	        Converter[] converters = set.iConverters;	        int length = converters.length;	        Converter converter;		        for (int i=length; --i>=0; ) {	            converter = converters[i];	            Class<?> supportedType = converter.getSupportedType();		            if (supportedType == type) {	                // Exact match.	                return converter;	            }		            if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) {	                // Eliminate the impossible.	                set = set.remove(i, null);	                converters = set.iConverters;	                length = converters.length;	            }	        }		        // Haven't found exact match, so check what remains in the set.		        if (type == null || length == 0) {	            return null;	        }	        if (length == 1) {	            // Found the one best match.	            return converters[0];	        }		        // At this point, there exist multiple potential converters.		        // Eliminate supertypes.	        for (int i=length; --i>=0; ) {	            converter = converters[i];	            Class<?> supportedType = converter.getSupportedType();	            for (int j=length; --j>=0; ) {	                if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) {	                    // Eliminate supertype.	                    set = set.remove(j, null);	                    converters = set.iConverters;	                    length = converters.length;	                    i = length - 1;	                }	            }	        }        	        	        // Check what remains in the set.		        if (length == 1) {	            // Found the one best match.	            return converters[0];	        }		        // Class c implements a, b {}	        // Converters exist only for a and b. Which is better? Neither.		        StringBuffer msg = new StringBuffer();	        msg.append("Unable to find best converter for type \"");	        msg.append(type.getName());	        msg.append("\" from remaining set: ");	        for (int i=0; i<length; i++) {	            converter = converters[i];	            Class<?> supportedType = converter.getSupportedType();		            msg.append(converter.getClass().getName());	            msg.append('[');	            msg.append(supportedType == null ? null : supportedType.getName());	            msg.append("], ");	        }		        throw new IllegalStateException(msg.toString());	    }	
Entry(Class<?> type, Converter converter) {	            iType = type;	            iConverter = converter;	        }	
/**	     * Restricted constructor.	     */	    protected ReadablePartialConverter() {	        super();	    }	
/**	     * Gets the chronology, which is taken from the ReadablePartial.	     * 	     * @param object  the ReadablePartial to convert, must not be null	     * @param zone  the specified zone to use, null means default zone	     * @return the chronology, never null	     */	    public Chronology getChronology(Object object, DateTimeZone zone) {	        return getChronology(object, (Chronology) null).withZone(zone);	    }	
/**	     * Gets the chronology, which is taken from the ReadableInstant.	     * <p>	     * If the passed in chronology is non-null, it is used.	     * Otherwise the chronology from the instant is used.	     * 	     * @param object  the ReadablePartial to convert, must not be null	     * @param chrono  the chronology to use, null means use that from object	     * @return the chronology, never null	     */	    public Chronology getChronology(Object object, Chronology chrono) {	        if (chrono == null) {	            chrono = ((ReadablePartial) object).getChronology();	            chrono = DateTimeUtils.getChronology(chrono);	        }	        return chrono;	    }	
/**	     * Extracts the values of the partial from an object of this converter's type.	     * The chrono parameter is a hint to the converter, should it require a	     * chronology to aid in conversion.	     * 	     * @param fieldSource  a partial that provides access to the fields.	     *  This partial may be incomplete and only getFieldType(int) should be used	     * @param object  the object to convert	     * @param chrono  the chronology to use, which is the non-null result of getChronology()	     * @return the array of field values that match the fieldSource, must be non-null valid	     * @throws ClassCastException if the object is invalid	     */	    public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono) {	        ReadablePartial input = (ReadablePartial) object;	        int size = fieldSource.size();	        int[] values = new int[size];	        for (int i = 0; i < size; i++) {	            values[i] = input.get(fieldSource.getFieldType(i));	        }	        chrono.validate(fieldSource, values);	        return values;	    }	
/**	     * Returns ReadableInstant.class.	     * 	     * @return ReadableInstant.class	     */	    public Class<?> getSupportedType() {	        return ReadablePartial.class;	    }	
/**	     * Restricted constructor.	     */	    protected ReadableIntervalConverter() {	        super();	    }	
/**	     * Gets the millisecond length of the interval.	     * 	     * @param object  the interval	     */	    public long getDurationMillis(Object object) {	        return (((ReadableInterval) object)).toDurationMillis();	    }	
/**	     * Sets the values of the mutable duration from the specified interval.	     * 	     * @param writablePeriod  the period to modify	     * @param object  the interval to set from	     * @param chrono  the chronology to use	     */	    public void setInto(ReadWritablePeriod writablePeriod, Object object, Chronology chrono) {	        ReadableInterval interval = (ReadableInterval) object;	        chrono = (chrono != null ? chrono : DateTimeUtils.getIntervalChronology(interval));	        long start = interval.getStartMillis();	        long end = interval.getEndMillis();	        int[] values = chrono.get(writablePeriod, start, end);	        for (int i = 0; i < values.length; i++) {	            writablePeriod.setValue(i, values[i]);	        }	    }	
/**	     * Checks if the input is a ReadableInterval.	     * <p>	     * If it is, then the calling code should cast and copy the fields directly.	     *	     * @param object  the object to convert, must not be null	     * @param chrono  the chronology to use, may be null	     * @return true if the input is a ReadableInterval	     * @throws ClassCastException if the object is invalid	     */	    public boolean isReadableInterval(Object object, Chronology chrono) {	        return true;	    }	
/**	     * Extracts interval endpoint values from an object of this converter's	     * type, and sets them into the given ReadWritableInterval.	     *	     * @param writableInterval interval to get modified, not null	     * @param object  the object to convert, must not be null	     * @param chrono  the chronology to use, may be null	     * @throws ClassCastException if the object is invalid	     */	    public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) {	        ReadableInterval input = (ReadableInterval) object;	        writableInterval.setInterval(input);	        if (chrono != null) {	            writableInterval.setChronology(chrono);	        } else {	            writableInterval.setChronology(input.getChronology());	        }	    }	
/**	     * Returns ReadableInterval.class.	     */	    public Class<?> getSupportedType() {	        return ReadableInterval.class;	    }	
/**	     * Restricted constructor.	     */	    protected StringConverter() {	        super();	    }	
/**	     * Gets the millis, which is the ISO parsed string value.	     * 	     * @param object  the String to convert, must not be null	     * @param chrono  the chronology to use, non-null result of getChronology	     * @return the millisecond value	     * @throws IllegalArgumentException if the value if invalid	     */	    public long getInstantMillis(Object object, Chronology chrono) {	        String str = (String) object;	        DateTimeFormatter p = ISODateTimeFormat.dateTimeParser();	        return p.withChronology(chrono).parseMillis(str);	    }	
/**	     * Extracts the values of the partial from an object of this converter's type.	     * This method checks if the parser has a zone, and uses it if present.	     * This is most useful for parsing local times with UTC.	     * 	     * @param fieldSource  a partial that provides access to the fields.	     *  This partial may be incomplete and only getFieldType(int) should be used	     * @param object  the object to convert	     * @param chrono  the chronology to use, which is the non-null result of getChronology()	     * @param parser the parser to use, may be null	     * @return the array of field values that match the fieldSource, must be non-null valid	     * @throws ClassCastException if the object is invalid	     * @throws IllegalArgumentException if the value if invalid	     * @since 1.3	     */	    public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono, DateTimeFormatter parser) {	        if (parser.getZone() != null) {	            chrono = chrono.withZone(parser.getZone());	        }	        long millis = parser.withChronology(chrono).parseMillis((String) object);	        return chrono.get(fieldSource, millis);	    }	
/**	     * Gets the duration of the string using the standard type.	     * This matches the toString() method of ReadableDuration.	     * 	     * @param object  the String to convert, must not be null	     * @throws ClassCastException if the object is invalid	     */	    public long getDurationMillis(Object object) {	        // parse here because duration could be bigger than the int supported	        // by the period parser	        String original = (String) object;	        String str = original;	        int len = str.length();	        if (len >= 4 &&	            (str.charAt(0) == 'P' || str.charAt(0) == 'p') &&	            (str.charAt(1) == 'T' || str.charAt(1) == 't') &&	            (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) {	            // ok	        } else {	            throw new IllegalArgumentException("Invalid format: \"" + original + '"');	        }	        str = str.substring(2, len - 1);	        int dot = -1;	        for (int i = 0; i < str.length(); i++) {	            if ((str.charAt(i) >= '0' && str.charAt(i) <= '9') ||	                (i == 0 && str.charAt(0) == '-')) {	                // ok	            } else if (i > 0 && str.charAt(i) == '.' && dot == -1) {	                // ok	                dot = i;	            } else {	                throw new IllegalArgumentException("Invalid format: \"" + original + '"');	            }	        }	        long millis = 0, seconds = 0;	        if (dot > 0) {	            seconds = Long.parseLong(str.substring(0, dot));	            str = str.substring(dot + 1);	            if (str.length() != 3) {	                str = (str + "000").substring(0, 3);	            }	            millis = Integer.parseInt(str);	        } else {	            seconds = Long.parseLong(str);	        }	        if (seconds < 0) {	            return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), -millis);	        } else {	            return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis);	        }	    }	
/**	     * Extracts duration values from an object of this converter's type, and	     * sets them into the given ReadWritableDuration.	     *	     * @param period  period to get modified	     * @param object  the String to convert, must not be null	     * @param chrono  the chronology to use	     * @return the millisecond duration	     * @throws ClassCastException if the object is invalid	     */	    public void setInto(ReadWritablePeriod period, Object object, Chronology chrono) {	        String str = (String) object;	        PeriodFormatter parser = ISOPeriodFormat.standard();	        period.clear();	        int pos = parser.parseInto(period, str, 0);	        if (pos < str.length()) {	            if (pos < 0) {	                // Parse again to get a better exception thrown.	                parser.withParseType(period.getPeriodType()).parseMutablePeriod(str);	            }	            throw new IllegalArgumentException("Invalid format: \"" + str + '"');	        }	    }	
/**	     * Sets the value of the mutable interval from the string.	     * 	     * @param writableInterval  the interval to set	     * @param object  the String to convert, must not be null	     * @param chrono  the chronology to use, may be null	     */	    public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) {	        String str = (String) object;		        int separator = str.indexOf('/');	        if (separator < 0) {	            throw new IllegalArgumentException("Format requires a '/' separator: " + str);	        }		        String leftStr = str.substring(0, separator);	        if (leftStr.length() <= 0) {	            throw new IllegalArgumentException("Format invalid: " + str);	        }	        String rightStr = str.substring(separator + 1);	        if (rightStr.length() <= 0) {	            throw new IllegalArgumentException("Format invalid: " + str);	        }		        DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser();	        dateTimeParser = dateTimeParser.withChronology(chrono);	        PeriodFormatter periodParser = ISOPeriodFormat.standard();	        long startInstant = 0, endInstant = 0;	        Period period = null;	        Chronology parsedChrono = null;	        	        // before slash	        char c = leftStr.charAt(0);	        if (c == 'P' || c == 'p') {	            period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr);	        } else {	            DateTime start = dateTimeParser.parseDateTime(leftStr);	            startInstant = start.getMillis();	            parsedChrono = start.getChronology();	        }	        	        // after slash	        c = rightStr.charAt(0);	        if (c == 'P' || c == 'p') {	            if (period != null) {	                throw new IllegalArgumentException("Interval composed of two durations: " + str);	            }	            period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr);	            chrono = (chrono != null ? chrono : parsedChrono);	            endInstant = chrono.add(period, startInstant, 1);	        } else {	            DateTime end = dateTimeParser.parseDateTime(rightStr);	            endInstant = end.getMillis();	            parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology());	            chrono = (chrono != null ? chrono : parsedChrono);	            if (period != null) {	                startInstant = chrono.add(period, endInstant, -1);	            }	        }	        	        writableInterval.setInterval(startInstant, endInstant);	        writableInterval.setChronology(chrono);	    }	
/**	     * Returns String.class.	     * 	     * @return String.class	     */	    public Class<?> getSupportedType() {	        return String.class;	    }	
/**	     * Restricted constructor.	     */	    protected ReadablePeriodConverter() {	        super();	    }	
/**	     * Extracts duration values from an object of this converter's type, and	     * sets them into the given ReadWritablePeriod.	     *	     * @param duration duration to get modified	     * @param object  the object to convert, must not be null	     * @param chrono  the chronology to use	     * @throws NullPointerException if the duration or object is null	     * @throws ClassCastException if the object is an invalid type	     * @throws IllegalArgumentException if the object is invalid	     */	    public void setInto(ReadWritablePeriod duration, Object object, Chronology chrono) {	        duration.setPeriod((ReadablePeriod) object);	    }	
/**	     * Selects a suitable period type for the given object.	     *	     * @param object  the object to examine, must not be null	     * @return the period type from the readable duration	     * @throws NullPointerException if the object is null	     * @throws ClassCastException if the object is an invalid type	     */	    public PeriodType getPeriodType(Object object) {	        ReadablePeriod period = (ReadablePeriod) object;	        return period.getPeriodType();	    }	
/**	     * Returns ReadablePeriod class.	     * 	     * @return ReadablePeriod.class	     */	    public Class<?> getSupportedType() {	        return ReadablePeriod.class;	    }	
/**	     * Restricted constructor.	     */	    protected CalendarConverter() {	        super();	    }	
/**	     * Gets the chronology.	     * <p>	     * If a chronology is specified then it is used.	     * Otherwise, it is the GJChronology if a GregorianCalendar is used,	     * BuddhistChronology if a BuddhistCalendar is used or ISOChronology otherwise.	     * The time zone is extracted from the calendar if possible, default used if not.	     * 	     * @param object  the Calendar to convert, must not be null	     * @param chrono  the chronology to use, null means use Calendar	     * @return the chronology, never null	     * @throws NullPointerException if the object is null	     * @throws ClassCastException if the object is an invalid type	     */	    public Chronology getChronology(Object object, Chronology chrono) {	        if (chrono != null) {	            return chrono;	        }	        Calendar cal = (Calendar) object;	        DateTimeZone zone = null;	        try {	            zone = DateTimeZone.forTimeZone(cal.getTimeZone());	            	        } catch (IllegalArgumentException ex) {	            zone = DateTimeZone.getDefault();	        }	        return getChronology(cal, zone);	    }	
/**	     * Gets the chronology, which is the GJChronology if a GregorianCalendar is used,	     * BuddhistChronology if a BuddhistCalendar is used or ISOChronology otherwise.	     * The time zone specified is used in preference to that on the calendar.	     * 	     * @param object  the Calendar to convert, must not be null	     * @param zone  the specified zone to use, null means default zone	     * @return the chronology, never null	     * @throws NullPointerException if the object is null	     * @throws ClassCastException if the object is an invalid type	     */	    public Chronology getChronology(Object object, DateTimeZone zone) {	        if (object.getClass().getName().endsWith(".BuddhistCalendar")) {	            return BuddhistChronology.getInstance(zone);	        } else if (object instanceof GregorianCalendar) {	            GregorianCalendar gc = (GregorianCalendar) object;	            long cutover = gc.getGregorianChange().getTime();	            if (cutover == Long.MIN_VALUE) {	                return GregorianChronology.getInstance(zone);	            } else if (cutover == Long.MAX_VALUE) {	                return JulianChronology.getInstance(zone);	            } else {	                return GJChronology.getInstance(zone, cutover, 4);	            }	        } else {	            return ISOChronology.getInstance(zone);	        }	    }	
/**	     * Gets the millis, which is the Calendar millis value.	     * 	     * @param object  the Calendar to convert, must not be null	     * @param chrono  the chronology result from getChronology, non-null	     * @return the millisecond value	     * @throws NullPointerException if the object is null	     * @throws ClassCastException if the object is an invalid type	     */	    public long getInstantMillis(Object object, Chronology chrono) {	        Calendar calendar = (Calendar) object;	        return calendar.getTime().getTime();	    }	
/**	     * Returns Calendar.class.	     * 	     * @return Calendar.class	     */	    public Class<?> getSupportedType() {	        return Calendar.class;	    }	
/**	     * Restricted constructor.	     */	    protected AbstractConverter() {	        super();	    }	
/**	     * Extracts the millis from an object of this convertor's type.	     * <p>	     * This implementation returns the current time.	     * 	     * @param object  the object to convert	     * @param chrono  the chronology to use, which is always non-null	     * @return the millisecond value	     */	    public long getInstantMillis(Object object, Chronology chrono) {	        return DateTimeUtils.currentTimeMillis();	    }	
/**	     * Extracts the chronology from an object of this convertor's type	     * where the time zone is specified.	     * <p>	     * This implementation returns the ISO chronology.	     * 	     * @param object  the object to convert	     * @param zone  the specified zone to use, null means default zone	     * @return the chronology, never null	     */	    public Chronology getChronology(Object object, DateTimeZone zone) {	        return ISOChronology.getInstance(zone);	    }	
/**	     * Extracts the chronology from an object of this convertor's type	     * where the chronology is specified.	     * <p>	     * This implementation returns the chronology specified, or the	     * ISO chronology in the default zone if null passed in.	     * 	     * @param object  the object to convert	     * @param chrono  the chronology to use, null means ISO default	     * @return the chronology, never null	     */	    public Chronology getChronology(Object object, Chronology chrono) {	        return DateTimeUtils.getChronology(chrono);	    }	
/**	     * Extracts the values of the partial from an object of this converter's type.	     * The chrono parameter is a hint to the converter, should it require a	     * chronology to aid in conversion.	     * <p>	     * This implementation calls {@link #getInstantMillis(Object, Chronology)}.	     * 	     * @param fieldSource  a partial that provides access to the fields.	     *  This partial may be incomplete and only getFieldType(int) should be used	     * @param object  the object to convert	     * @param chrono  the chronology to use, which is the non-null result of getChronology()	     * @return the array of field values that match the fieldSource, must be non-null valid	     * @throws ClassCastException if the object is invalid	     */	    public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono) {	        long instant = getInstantMillis(object, chrono);	        return chrono.get(fieldSource, instant);	    }	
/**	     * Extracts the values of the partial from an object of this converter's type.	     * The chrono parameter is a hint to the converter, should it require a	     * chronology to aid in conversion.	     * <p>	     * This implementation calls {@link #getPartialValues(ReadablePartial, Object, Chronology)}.	     * 	     * @param fieldSource  a partial that provides access to the fields.	     *  This partial may be incomplete and only getFieldType(int) should be used	     * @param object  the object to convert	     * @param chrono  the chronology to use, which is the non-null result of getChronology()	     * @param parser  if converting from a String, the given parser is preferred	     * @return the array of field values that match the fieldSource, must be non-null valid	     * @throws ClassCastException if the object is invalid	     * @since 1.3	     */	    public int[] getPartialValues(ReadablePartial fieldSource,	            Object object, Chronology chrono, DateTimeFormatter parser) {	        return getPartialValues(fieldSource, object, chrono);	    }	
/**	     * Selects a suitable period type for the given object.	     *	     * @param object  the object to examine	     * @return the period type, never null	     */	    public PeriodType getPeriodType(Object object) {	        return PeriodType.standard();	    }	
/**	     * Checks if the input is a ReadableInterval.	     * <p>	     * If it is, then the calling code should cast and copy the fields directly.	     *	     * @param object  the object to convert	     * @param chrono  the chronology to use, may be null	     * @return true if the input is a ReadableInterval	     */	    public boolean isReadableInterval(Object object, Chronology chrono) {	        return false;	    }	
/**	     * Gets a debugging string version of this converter.	     * 	     * @return a debugging string	     */	    public String toString() {	        return "Converter[" + (getSupportedType() == null ? "null" : getSupportedType().getName()) + "]";	    }	
/**	     * Restricted constructor.	     */	    protected DateConverter() {	        super();	    }	
/**	     * Gets the millis, which is the Date millis value.	     * 	     * @param object  the Date to convert, must not be null	     * @param chrono  the non-null result of getChronology	     * @return the millisecond value	     * @throws NullPointerException if the object is null	     * @throws ClassCastException if the object is an invalid type	     */	    public long getInstantMillis(Object object, Chronology chrono) {	        Date date = (Date) object;	        return date.getTime();	    }	
/**	     * Returns Date.class.	     * 	     * @return Date.class	     */	    public Class<?> getSupportedType() {	        return Date.class;	    }	
/**	     * Restricted constructor.	     */	    protected LongConverter() {	        super();	    }	
/**	     * Gets the millisecond instant, which is the Long value.	     * 	     * @param object  the Long to convert, must not be null	     * @param chrono  the chronology to use, which is always non-null	     * @return the millisecond value	     * @throws NullPointerException if the object is null	     * @throws ClassCastException if the object is an invalid type	     */	    public long getInstantMillis(Object object, Chronology chrono) {	        return ((Long) object).longValue();	    }	
/**	     * Gets the millisecond duration, which is the Long value.	     * 	     * @param object  the Long to convert, must not be null	     * @return the millisecond duration	     * @throws NullPointerException if the object is null	     * @throws ClassCastException if the object is an invalid type	     */	    public long getDurationMillis(Object object) {	        return ((Long) object).longValue();	    }	
/**	     * Returns Long.class.	     * 	     * @return Long.class	     */	    public Class<?> getSupportedType() {	        return Long.class;	    }	
/**	     * Restricted constructor.	     */	    protected ReadableInstantConverter() {	        super();	    }	
/**	     * Gets the chronology, which is taken from the ReadableInstant.	     * If the chronology on the instant is null, the ISOChronology in the	     * specified time zone is used.	     * If the chronology on the instant is not in the specified zone, it is	     * adapted.	     * 	     * @param object  the ReadableInstant to convert, must not be null	     * @param zone  the specified zone to use, null means default zone	     * @return the chronology, never null	     */	    public Chronology getChronology(Object object, DateTimeZone zone) {	        Chronology chrono = ((ReadableInstant) object).getChronology();	        if (chrono == null) {	            return ISOChronology.getInstance(zone);	        }	        DateTimeZone chronoZone = chrono.getZone();	        if (chronoZone != zone) {	            chrono = chrono.withZone(zone);	            if (chrono == null) {	                return ISOChronology.getInstance(zone);	            }	        }	        return chrono;	    }	
/**	     * Gets the chronology, which is taken from the ReadableInstant.	     * <p>	     * If the passed in chronology is non-null, it is used.	     * Otherwise the chronology from the instant is used.	     * 	     * @param object  the ReadableInstant to convert, must not be null	     * @param chrono  the chronology to use, null means use that from object	     * @return the chronology, never null	     */	    public Chronology getChronology(Object object, Chronology chrono) {	        if (chrono == null) {	            chrono = ((ReadableInstant) object).getChronology();	            chrono = DateTimeUtils.getChronology(chrono);	        }	        return chrono;	    }	
/**	     * Extracts the millis from an object of this convertor's type.	     * 	     * @param object  the ReadableInstant to convert, must not be null	     * @param chrono  the non-null result of getChronology	     * @return the millisecond value	     * @throws NullPointerException if the object is null	     * @throws ClassCastException if the object is an invalid type	     */	    public long getInstantMillis(Object object, Chronology chrono) {	        return ((ReadableInstant) object).getMillis();	    }	
/**	     * Returns ReadableInstant.class.	     * 	     * @return ReadableInstant.class	     */	    public Class<?> getSupportedType() {	        return ReadableInstant.class;	    }	
/**	     * Creates a DateTimeFormatterBuilder.	     */	    public DateTimeFormatterBuilder() {	        super();	        iElementPairs = new ArrayList<Object>();	    }	
/**	     * Constructs a DateTimeFormatter using all the appended elements.	     * <p>	     * This is the main method used by applications at the end of the build	     * process to create a usable formatter.	     * <p>	     * Subsequent changes to this builder do not affect the returned formatter.	     * <p>	     * The returned formatter may not support both printing and parsing.	     * The methods {@link DateTimeFormatter#isPrinter()} and	     * {@link DateTimeFormatter#isParser()} will help you determine the state	     * of the formatter.	     *	     * @throws UnsupportedOperationException if neither printing nor parsing is supported	     */	    public DateTimeFormatter toFormatter() {	        Object f = getFormatter();	        DateTimePrinter printer = null;	        if (isPrinter(f)) {	            printer = (DateTimePrinter) f;	        }	        DateTimeParser parser = null;	        if (isParser(f)) {	            parser = (DateTimeParser) f;	        }	        if (printer != null || parser != null) {	            return new DateTimeFormatter(printer, parser);	        }	        throw new UnsupportedOperationException("Both printing and parsing not supported");	    }	
/**	     * Internal method to create a DateTimePrinter instance using all the	     * appended elements.	     * <p>	     * Most applications will not use this method.	     * If you want a printer in an application, call {@link #toFormatter()}	     * and just use the printing API.	     * <p>	     * Subsequent changes to this builder do not affect the returned printer.	     *	     * @throws UnsupportedOperationException if printing is not supported	     */	    public DateTimePrinter toPrinter() {	        Object f = getFormatter();	        if (isPrinter(f)) {	            return (DateTimePrinter) f;	        }	        throw new UnsupportedOperationException("Printing is not supported");	    }	
/**	     * Internal method to create a DateTimeParser instance using all the	     * appended elements.	     * <p>	     * Most applications will not use this method.	     * If you want a parser in an application, call {@link #toFormatter()}	     * and just use the parsing API.	     * <p>	     * Subsequent changes to this builder do not affect the returned parser.	     *	     * @throws UnsupportedOperationException if parsing is not supported	     */	    public DateTimeParser toParser() {	        Object f = getFormatter();	        if (isParser(f)) {	            return (DateTimeParser) f;	        }	        throw new UnsupportedOperationException("Parsing is not supported");	    }	
/**	     * Returns true if toFormatter can be called without throwing an	     * UnsupportedOperationException.	     * 	     * @return true if a formatter can be built	     */	    public boolean canBuildFormatter() {	        return isFormatter(getFormatter());	    }	
/**	     * Returns true if toPrinter can be called without throwing an	     * UnsupportedOperationException.	     * 	     * @return true if a printer can be built	     */	    public boolean canBuildPrinter() {	        return isPrinter(getFormatter());	    }	
/**	     * Returns true if toParser can be called without throwing an	     * UnsupportedOperationException.	     * 	     * @return true if a parser can be built	     */	    public boolean canBuildParser() {	        return isParser(getFormatter());	    }	
/**	     * Clears out all the appended elements, allowing this builder to be	     * reused.	     */	    public void clear() {	        iFormatter = null;	        iElementPairs.clear();	    }	
/**	     * Appends another formatter.	     *	     * @param formatter  the formatter to add	     * @return this DateTimeFormatterBuilder, for chaining	     * @throws IllegalArgumentException if formatter is null or of an invalid type	     */	    public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {	        if (formatter == null) {	            throw new IllegalArgumentException("No formatter supplied");	        }	        return append0(formatter.getPrinter(), formatter.getParser());	    }	
/**	     * Appends just a printer. With no matching parser, a parser cannot be	     * built from this DateTimeFormatterBuilder.	     *	     * @param printer  the printer to add	     * @return this DateTimeFormatterBuilder, for chaining	     * @throws IllegalArgumentException if printer is null or of an invalid type	     */	    public DateTimeFormatterBuilder append(DateTimePrinter printer) {	        checkPrinter(printer);	        return append0(printer, null);	    }	
/**	     * Appends just a parser. With no matching printer, a printer cannot be	     * built from this builder.	     *	     * @param parser  the parser to add	     * @return this DateTimeFormatterBuilder, for chaining	     * @throws IllegalArgumentException if parser is null or of an invalid type	     */	    public DateTimeFormatterBuilder append(DateTimeParser parser) {	        checkParser(parser);	        return append0(null, parser);	    }	
/**	     * Appends a printer/parser pair.	     *	     * @param printer  the printer to add	     * @param parser  the parser to add	     * @return this DateTimeFormatterBuilder, for chaining	     * @throws IllegalArgumentException if printer or parser is null or of an invalid type	     */	    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {	        checkPrinter(printer);	        checkParser(parser);	        return append0(printer, parser);	    }	
/**	     * Appends a printer and a set of matching parsers. When parsing, the first	     * parser in the list is selected for parsing. If it fails, the next is	     * chosen, and so on. If none of these parsers succeeds, then the failed	     * position of the parser that made the greatest progress is returned.	     * <p>	     * Only the printer is optional. In addition, it is illegal for any but the	     * last of the parser array elements to be null. If the last element is	     * null, this represents the empty parser. The presence of an empty parser	     * indicates that the entire array of parse formats is optional.	     *	     * @param printer  the printer to add	     * @param parsers  the parsers to add	     * @return this DateTimeFormatterBuilder, for chaining	     * @throws IllegalArgumentException if any printer or parser is of an invalid type	     * @throws IllegalArgumentException if any parser element but the last is null	     */	    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {	        if (printer != null) {	            checkPrinter(printer);	        }	        if (parsers == null) {	            throw new IllegalArgumentException("No parsers supplied");	        }	        int length = parsers.length;	        if (length == 1) {	            if (parsers[0] == null) {	                throw new IllegalArgumentException("No parser supplied");	            }	            return append0(printer, parsers[0]);	        }		        DateTimeParser[] copyOfParsers = new DateTimeParser[length];	        int i;	        for (i = 0; i < length - 1; i++) {	            if ((copyOfParsers[i] = parsers[i]) == null) {	                throw new IllegalArgumentException("Incomplete parser array");	            }	        }	        copyOfParsers[i] = parsers[i];		        return append0(printer, new MatchingParser(copyOfParsers));	    }	
/**	     * Appends just a parser element which is optional. With no matching	     * printer, a printer cannot be built from this DateTimeFormatterBuilder.	     *	     * @return this DateTimeFormatterBuilder, for chaining	     * @throws IllegalArgumentException if parser is null or of an invalid type	     */	    public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {	        checkParser(parser);	        DateTimeParser[] parsers = new DateTimeParser[] {parser, null};	        return append0(null, new MatchingParser(parsers));	    }	
/**	     * Checks if the parser is non null and a provider.	     * 	     * @param parser  the parser to check	     */	    private void checkParser(DateTimeParser parser) {	        if (parser == null) {	            throw new IllegalArgumentException("No parser supplied");	        }	    }	
/**	     * Checks if the printer is non null and a provider.	     * 	     * @param printer  the printer to check	     */	    private void checkPrinter(DateTimePrinter printer) {	        if (printer == null) {	            throw new IllegalArgumentException("No printer supplied");	        }	    }	
private DateTimeFormatterBuilder append0(Object element) {	        iFormatter = null;	        // Add the element as both a printer and parser.	        iElementPairs.add(element);	        iElementPairs.add(element);	        return this;	    }	
private DateTimeFormatterBuilder append0(	            DateTimePrinter printer, DateTimeParser parser) {	        iFormatter = null;	        iElementPairs.add(printer);	        iElementPairs.add(parser);	        return this;	    }	
/**	     * Instructs the printer to emit a specific character, and the parser to	     * expect it. The parser is case-insensitive.	     *	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendLiteral(char c) {	        return append0(new CharacterLiteral(c));	    }	
/**	     * Instructs the printer to emit specific text, and the parser to expect	     * it. The parser is case-insensitive.	     *	     * @return this DateTimeFormatterBuilder, for chaining	     * @throws IllegalArgumentException if text is null	     */	    public DateTimeFormatterBuilder appendLiteral(String text) {	        if (text == null) {	            throw new IllegalArgumentException("Literal must not be null");	        }	        switch (text.length()) {	            case 0:	                return this;	            case 1:	                return append0(new CharacterLiteral(text.charAt(0)));	            default:	                return append0(new StringLiteral(text));	        }	    }	
/**	     * Instructs the printer to emit a field value as a decimal number, and the	     * parser to expect an unsigned decimal number.	     *	     * @param fieldType  type of field to append	     * @param minDigits  minimum number of digits to <i>print</i>	     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated	     * maximum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     * @throws IllegalArgumentException if field type is null	     */	    public DateTimeFormatterBuilder appendDecimal(	            DateTimeFieldType fieldType, int minDigits, int maxDigits) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field type must not be null");	        }	        if (maxDigits < minDigits) {	            maxDigits = minDigits;	        }	        if (minDigits < 0 || maxDigits <= 0) {	            throw new IllegalArgumentException();	        }	        if (minDigits <= 1) {	            return append0(new UnpaddedNumber(fieldType, maxDigits, false));	        } else {	            return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));	        }	    }	
/**	     * Instructs the printer to emit a field value as a fixed-width decimal	     * number (smaller numbers will be left-padded with zeros), and the parser	     * to expect an unsigned decimal number with the same fixed width.	     * 	     * @param fieldType  type of field to append	     * @param numDigits  the exact number of digits to parse or print, except if	     * printed value requires more digits	     * @return this DateTimeFormatterBuilder, for chaining	     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>	     * @since 1.5	     */	    public DateTimeFormatterBuilder appendFixedDecimal(	            DateTimeFieldType fieldType, int numDigits) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field type must not be null");	        }	        if (numDigits <= 0) {	            throw new IllegalArgumentException("Illegal number of digits: " + numDigits);	        }	        return append0(new FixedNumber(fieldType, numDigits, false));	    }	
/**	     * Instructs the printer to emit a field value as a decimal number, and the	     * parser to expect a signed decimal number.	     *	     * @param fieldType  type of field to append	     * @param minDigits  minimum number of digits to <i>print</i>	     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated	     * maximum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     * @throws IllegalArgumentException if field type is null	     */	    public DateTimeFormatterBuilder appendSignedDecimal(	            DateTimeFieldType fieldType, int minDigits, int maxDigits) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field type must not be null");	        }	        if (maxDigits < minDigits) {	            maxDigits = minDigits;	        }	        if (minDigits < 0 || maxDigits <= 0) {	            throw new IllegalArgumentException();	        }	        if (minDigits <= 1) {	            return append0(new UnpaddedNumber(fieldType, maxDigits, true));	        } else {	            return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));	        }	    }	
/**	     * Instructs the printer to emit a field value as a fixed-width decimal	     * number (smaller numbers will be left-padded with zeros), and the parser	     * to expect an signed decimal number with the same fixed width.	     * 	     * @param fieldType  type of field to append	     * @param numDigits  the exact number of digits to parse or print, except if	     * printed value requires more digits	     * @return this DateTimeFormatterBuilder, for chaining	     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>	     * @since 1.5	     */	    public DateTimeFormatterBuilder appendFixedSignedDecimal(	            DateTimeFieldType fieldType, int numDigits) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field type must not be null");	        }	        if (numDigits <= 0) {	            throw new IllegalArgumentException("Illegal number of digits: " + numDigits);	        }	        return append0(new FixedNumber(fieldType, numDigits, true));	    }	
/**	     * Instructs the printer to emit a field value as text, and the	     * parser to expect text.	     *	     * @param fieldType  type of field to append	     * @return this DateTimeFormatterBuilder, for chaining	     * @throws IllegalArgumentException if field type is null	     */	    public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field type must not be null");	        }	        return append0(new TextField(fieldType, false));	    }	
/**	     * Instructs the printer to emit a field value as short text, and the	     * parser to expect text.	     *	     * @param fieldType  type of field to append	     * @return this DateTimeFormatterBuilder, for chaining	     * @throws IllegalArgumentException if field type is null	     */	    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field type must not be null");	        }	        return append0(new TextField(fieldType, true));	    }	
/**	     * Instructs the printer to emit a remainder of time as a decimal fraction,	     * without decimal point. For example, if the field is specified as	     * minuteOfHour and the time is 12:30:45, the value printed is 75. A	     * decimal point is implied, so the fraction is 0.75, or three-quarters of	     * a minute.	     *	     * @param fieldType  type of field to append	     * @param minDigits  minimum number of digits to print.	     * @param maxDigits  maximum number of digits to print or parse.	     * @return this DateTimeFormatterBuilder, for chaining	     * @throws IllegalArgumentException if field type is null	     */	    public DateTimeFormatterBuilder appendFraction(	            DateTimeFieldType fieldType, int minDigits, int maxDigits) {	        if (fieldType == null) {	            throw new IllegalArgumentException("Field type must not be null");	        }	        if (maxDigits < minDigits) {	            maxDigits = minDigits;	        }	        if (minDigits < 0 || maxDigits <= 0) {	            throw new IllegalArgumentException();	        }	        return append0(new Fraction(fieldType, minDigits, maxDigits));	    }	
/**	     * Appends the print/parse of a fractional second.	     * <p>	     * This reliably handles the case where fractional digits are being handled	     * beyond a visible decimal point. The digits parsed will always be treated	     * as the most significant (numerically largest) digits.	     * Thus '23' will be parsed as 230 milliseconds.	     * Contrast this behaviour to {@link #appendMillisOfSecond}.	     * This method does not print or parse the decimal point itself.	     * 	     * @param minDigits  minimum number of digits to print	     * @param maxDigits  maximum number of digits to print or parse	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {	        return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);	    }	
/**	     * Appends the print/parse of a fractional minute.	     * <p>	     * This reliably handles the case where fractional digits are being handled	     * beyond a visible decimal point. The digits parsed will always be treated	     * as the most significant (numerically largest) digits.	     * Thus '23' will be parsed as 0.23 minutes (converted to milliseconds).	     * This method does not print or parse the decimal point itself.	     * 	     * @param minDigits  minimum number of digits to print	     * @param maxDigits  maximum number of digits to print or parse	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {	        return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);	    }	
/**	     * Appends the print/parse of a fractional hour.	     * <p>	     * This reliably handles the case where fractional digits are being handled	     * beyond a visible decimal point. The digits parsed will always be treated	     * as the most significant (numerically largest) digits.	     * Thus '23' will be parsed as 0.23 hours (converted to milliseconds).	     * This method does not print or parse the decimal point itself.	     * 	     * @param minDigits  minimum number of digits to print	     * @param maxDigits  maximum number of digits to print or parse	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {	        return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);	    }	
/**	     * Appends the print/parse of a fractional day.	     * <p>	     * This reliably handles the case where fractional digits are being handled	     * beyond a visible decimal point. The digits parsed will always be treated	     * as the most significant (numerically largest) digits.	     * Thus '23' will be parsed as 0.23 days (converted to milliseconds).	     * This method does not print or parse the decimal point itself.	     * 	     * @param minDigits  minimum number of digits to print	     * @param maxDigits  maximum number of digits to print or parse	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {	        return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);	    }	
/**	     * Instructs the printer to emit a numeric millisOfSecond field.	     * <p>	     * This method will append a field that prints a three digit value.	     * During parsing the value that is parsed is assumed to be three digits.	     * If less than three digits are present then they will be counted as the	     * smallest parts of the millisecond. This is probably not what you want	     * if you are using the field as a fraction. Instead, a fractional	     * millisecond should be produced using {@link #appendFractionOfSecond}.	     *	     * @param minDigits  minimum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {	        return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);	    }	
/**	     * Instructs the printer to emit a numeric millisOfDay field.	     *	     * @param minDigits  minimum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {	        return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);	    }	
/**	     * Instructs the printer to emit a numeric secondOfMinute field.	     *	     * @param minDigits  minimum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {	        return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);	    }	
/**	     * Instructs the printer to emit a numeric secondOfDay field.	     *	     * @param minDigits  minimum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {	        return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);	    }	
/**	     * Instructs the printer to emit a numeric minuteOfHour field.	     *	     * @param minDigits  minimum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {	        return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);	    }	
/**	     * Instructs the printer to emit a numeric minuteOfDay field.	     *	     * @param minDigits  minimum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {	        return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);	    }	
/**	     * Instructs the printer to emit a numeric hourOfDay field.	     *	     * @param minDigits  minimum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {	        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);	    }	
/**	     * Instructs the printer to emit a numeric clockhourOfDay field.	     *	     * @param minDigits minimum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {	        return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);	    }	
/**	     * Instructs the printer to emit a numeric hourOfHalfday field.	     *	     * @param minDigits  minimum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {	        return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);	    }	
/**	     * Instructs the printer to emit a numeric clockhourOfHalfday field.	     *	     * @param minDigits  minimum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {	        return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);	    }	
/**	     * Instructs the printer to emit a numeric dayOfWeek field.	     *	     * @param minDigits  minimum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {	        return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);	    }	
/**	     * Instructs the printer to emit a numeric dayOfMonth field.	     *	     * @param minDigits  minimum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {	        return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);	    }	
/**	     * Instructs the printer to emit a numeric dayOfYear field.	     *	     * @param minDigits  minimum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {	        return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);	    }	
/**	     * Instructs the printer to emit a numeric weekOfWeekyear field.	     *	     * @param minDigits  minimum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {	        return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);	    }	
/**	     * Instructs the printer to emit a numeric weekyear field.	     *	     * @param minDigits  minimum number of digits to <i>print</i>	     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated	     * maximum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {	        return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);	    }	
/**	     * Instructs the printer to emit a numeric monthOfYear field.	     *	     * @param minDigits  minimum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {	        return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);	    }	
/**	     * Instructs the printer to emit a numeric year field.	     *	     * @param minDigits  minimum number of digits to <i>print</i>	     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated	     * maximum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {	        return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);	    }	
/**	     * Instructs the printer to emit a numeric year field which always prints	     * and parses two digits. A pivot year is used during parsing to determine	     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.	     *	     * <pre>	     * pivot   supported range   00 is   20 is   40 is   60 is   80 is	     * ---------------------------------------------------------------	     * 1950      1900..1999      1900    1920    1940    1960    1980	     * 1975      1925..2024      2000    2020    1940    1960    1980	     * 2000      1950..2049      2000    2020    2040    1960    1980	     * 2025      1975..2074      2000    2020    2040    2060    1980	     * 2050      2000..2099      2000    2020    2040    2060    2080	     * </pre>	     *	     * @param pivot  pivot year to use when parsing	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {	        return appendTwoDigitYear(pivot, false);	    }	
/**	     * Instructs the printer to emit a numeric year field which always prints	     * two digits. A pivot year is used during parsing to determine the range	     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If	     * parse is instructed to be lenient and the digit count is not two, it is	     * treated as an absolute year. With lenient parsing, specifying a positive	     * or negative sign before the year also makes it absolute.	     *	     * @param pivot  pivot year to use when parsing	     * @param lenientParse  when true, if digit count is not two, it is treated	     * as an absolute year	     * @return this DateTimeFormatterBuilder, for chaining	     * @since 1.1	     */	    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) {	        return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot, lenientParse));	    }	
/**	     * Instructs the printer to emit a numeric weekyear field which always prints	     * and parses two digits. A pivot year is used during parsing to determine	     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.	     *	     * <pre>	     * pivot   supported range   00 is   20 is   40 is   60 is   80 is	     * ---------------------------------------------------------------	     * 1950      1900..1999      1900    1920    1940    1960    1980	     * 1975      1925..2024      2000    2020    1940    1960    1980	     * 2000      1950..2049      2000    2020    2040    1960    1980	     * 2025      1975..2074      2000    2020    2040    2060    1980	     * 2050      2000..2099      2000    2020    2040    2060    2080	     * </pre>	     *	     * @param pivot  pivot weekyear to use when parsing	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) {	        return appendTwoDigitWeekyear(pivot, false);	    }	
/**	     * Instructs the printer to emit a numeric weekyear field which always prints	     * two digits. A pivot year is used during parsing to determine the range	     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If	     * parse is instructed to be lenient and the digit count is not two, it is	     * treated as an absolute weekyear. With lenient parsing, specifying a positive	     * or negative sign before the weekyear also makes it absolute.	     *	     * @param pivot  pivot weekyear to use when parsing	     * @param lenientParse  when true, if digit count is not two, it is treated	     * as an absolute weekyear	     * @return this DateTimeFormatterBuilder, for chaining	     * @since 1.1	     */	    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) {	        return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse));	    }	
/**	     * Instructs the printer to emit a numeric yearOfEra field.	     *	     * @param minDigits  minimum number of digits to <i>print</i>	     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated	     * maximum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {	        return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);	    }	
/**	     * Instructs the printer to emit a numeric year of century field.	     *	     * @param minDigits  minimum number of digits to print	     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated	     * maximum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {	        return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);	    }	
/**	     * Instructs the printer to emit a numeric century of era field.	     *	     * @param minDigits  minimum number of digits to print	     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated	     * maximum number of digits to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {	        return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);	    }	
/**	     * Instructs the printer to emit a locale-specific AM/PM text, and the	     * parser to expect it. The parser is case-insensitive.	     *	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendHalfdayOfDayText() {	        return appendText(DateTimeFieldType.halfdayOfDay());	    }	
/**	     * Instructs the printer to emit a locale-specific dayOfWeek text. The	     * parser will accept a long or short dayOfWeek text, case-insensitive.	     *	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendDayOfWeekText() {	        return appendText(DateTimeFieldType.dayOfWeek());	    }	
/**	     * Instructs the printer to emit a short locale-specific dayOfWeek	     * text. The parser will accept a long or short dayOfWeek text,	     * case-insensitive.	     *	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendDayOfWeekShortText() {	        return appendShortText(DateTimeFieldType.dayOfWeek());	    }	
/**	     * Instructs the printer to emit a short locale-specific monthOfYear	     * text. The parser will accept a long or short monthOfYear text,	     * case-insensitive.	     *	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendMonthOfYearText() { 	        return appendText(DateTimeFieldType.monthOfYear());	    }	
/**	     * Instructs the printer to emit a locale-specific monthOfYear text. The	     * parser will accept a long or short monthOfYear text, case-insensitive.	     *	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendMonthOfYearShortText() {	        return appendShortText(DateTimeFieldType.monthOfYear());	    }	
/**	     * Instructs the printer to emit a locale-specific era text (BC/AD), and	     * the parser to expect it. The parser is case-insensitive.	     *	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendEraText() {	        return appendText(DateTimeFieldType.era());	    }	
/**	     * Instructs the printer to emit a locale-specific time zone name. A	     * parser cannot be created from this builder if a time zone name is	     * appended.	     *	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendTimeZoneName() {	        return append0(new TimeZoneName(TimeZoneName.LONG_NAME), null);	    }	
/**	     * Instructs the printer to emit a short locale-specific time zone	     * name. A parser cannot be created from this builder if time zone	     * name is appended.	     *	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendTimeZoneShortName() {	        return append0(new TimeZoneName(TimeZoneName.SHORT_NAME), null);	    }	
/**	     * Instructs the printer to emit the identifier of the time zone.	     * This field cannot currently be parsed.	     *	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendTimeZoneId() {	        return append0(new TimeZoneName(TimeZoneName.ID), null);	    }	
/**	     * Instructs the printer to emit text and numbers to display time zone	     * offset from UTC. A parser will use the parsed time zone offset to adjust	     * the datetime.	     * <p>	     * If zero offset text is supplied, then it will be printed when the zone is zero.	     * During parsing, either the zero offset text, or the offset will be parsed.	     *	     * @param zeroOffsetText  the text to use if time zone offset is zero. If	     * null, offset is always shown.	     * @param showSeparators  if true, prints ':' separator before minute and	     * second field and prints '.' separator before fraction field.	     * @param minFields  minimum number of fields to print, stopping when no	     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction	     * @param maxFields  maximum number of fields to print	     * @return this DateTimeFormatterBuilder, for chaining	     */	    public DateTimeFormatterBuilder appendTimeZoneOffset(	            String zeroOffsetText, boolean showSeparators,	            int minFields, int maxFields) {	        return append0(new TimeZoneOffset	                       (zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields));	    }	
/**	     * Instructs the printer to emit text and numbers to display time zone	     * offset from UTC. A parser will use the parsed time zone offset to adjust	     * the datetime.	     * <p>	     * If zero offset print text is supplied, then it will be printed when the zone is zero.	     * If zero offset parse text is supplied, then either it or the offset will be parsed.	     *	     * @param zeroOffsetPrintText  the text to print if time zone offset is zero. If	     * null, offset is always shown.	     * @param zeroOffsetParseText  the text to optionally parse to indicate that the time	     * zone offset is zero. If null, then always use the offset.	     * @param showSeparators  if true, prints ':' separator before minute and	     * second field and prints '.' separator before fraction field.	     * @param minFields  minimum number of fields to print, stopping when no	     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction	     * @param maxFields  maximum number of fields to print	     * @return this DateTimeFormatterBuilder, for chaining	     * @since 2.0	     */	    public DateTimeFormatterBuilder appendTimeZoneOffset(	            String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators,	            int minFields, int maxFields) {	        return append0(new TimeZoneOffset	                       (zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields));	    }	
/**	     * Calls upon {@link DateTimeFormat} to parse the pattern and append the	     * results into this builder.	     *	     * @param pattern  pattern specification	     * @throws IllegalArgumentException if the pattern is invalid	     * @see DateTimeFormat	     */	    public DateTimeFormatterBuilder appendPattern(String pattern) {	        DateTimeFormat.appendPatternTo(this, pattern);	        return this;	    }	
private Object getFormatter() {	        Object f = iFormatter;		        if (f == null) {	            if (iElementPairs.size() == 2) {	                Object printer = iElementPairs.get(0);	                Object parser = iElementPairs.get(1);		                if (printer != null) {	                    if (printer == parser || parser == null) {	                        f = printer;	                    }	                } else {	                    f = parser;	                }	            }		            if (f == null) {	                f = new Composite(iElementPairs);	            }		            iFormatter = f;	        }		        return f;	    }	
private boolean isPrinter(Object f) {	        if (f instanceof DateTimePrinter) {	            if (f instanceof Composite) {	                return ((Composite)f).isPrinter();	            }	            return true;	        }	        return false;	    }	
private boolean isParser(Object f) {	        if (f instanceof DateTimeParser) {	            if (f instanceof Composite) {	                return ((Composite)f).isParser();	            }	            return true;	        }	        return false;	    }	
private boolean isFormatter(Object f) {	        return (isPrinter(f) || isParser(f));	    }	
static void appendUnknownString(StringBuffer buf, int len) {	        for (int i = len; --i >= 0;) {	            buf.append('\ufffd');	        }	    }	
static void printUnknownString(Writer out, int len) throws IOException {	        for (int i = len; --i >= 0;) {	            out.write('\ufffd');	        }	    }	
CharacterLiteral(char value) {	            super();	            iValue = value;	        }	
public int estimatePrintedLength() {	            return 1;	        }	
public void printTo(	                StringBuffer buf, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) {	            buf.append(iValue);	        }	
public void printTo(	                Writer out, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {	            out.write(iValue);	        }	
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {	            buf.append(iValue);	        }	
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {	            out.write(iValue);	        }	
public int estimateParsedLength() {	            return 1;	        }	
public int parseInto(DateTimeParserBucket bucket, String text, int position) {	            if (position >= text.length()) {	                return ~position;	            }		            char a = text.charAt(position);	            char b = iValue;		            if (a != b) {	                a = Character.toUpperCase(a);	                b = Character.toUpperCase(b);	                if (a != b) {	                    a = Character.toLowerCase(a);	                    b = Character.toLowerCase(b);	                    if (a != b) {	                        return ~position;	                    }	                }	            }		            return position + 1;	        }	
StringLiteral(String value) {	            super();	            iValue = value;	        }	
public int estimatePrintedLength() {	            return iValue.length();	        }	
public void printTo(	                StringBuffer buf, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) {	            buf.append(iValue);	        }	
public void printTo(	                Writer out, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {	            out.write(iValue);	        }	
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {	            buf.append(iValue);	        }	
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {	            out.write(iValue);	        }	
public int estimateParsedLength() {	            return iValue.length();	        }	
public int parseInto(DateTimeParserBucket bucket, String text, int position) {	            if (text.regionMatches(true, position, iValue, 0, iValue.length())) {	                return position + iValue.length();	            }	            return ~position;	        }	
NumberFormatter(DateTimeFieldType fieldType,	                int maxParsedDigits, boolean signed) {	            super();	            iFieldType = fieldType;	            iMaxParsedDigits = maxParsedDigits;	            iSigned = signed;	        }	
public int estimateParsedLength() {	            return iMaxParsedDigits;	        }	
public int parseInto(DateTimeParserBucket bucket, String text, int position) {	            int limit = Math.min(iMaxParsedDigits, text.length() - position);		            boolean negative = false;	            int length = 0;	            while (length < limit) {	                char c = text.charAt(position + length);	                if (length == 0 && (c == '-' || c == '+') && iSigned) {	                    negative = c == '-';		                    // Next character must be a digit.	                    if (length + 1 >= limit || 	                        (c = text.charAt(position + length + 1)) < '0' || c > '9')	                    {	                        break;	                    }		                    if (negative) {	                        length++;	                    } else {	                        // Skip the '+' for parseInt to succeed.	                        position++;	                    }	                    // Expand the limit to disregard the sign character.	                    limit = Math.min(limit + 1, text.length() - position);	                    continue;	                }	                if (c < '0' || c > '9') {	                    break;	                }	                length++;	            }		            if (length == 0) {	                return ~position;	            }		            int value;	            if (length >= 9) {	                // Since value may exceed integer limits, use stock parser	                // which checks for this.	                value = Integer.parseInt(text.substring(position, position += length));	            } else {	                int i = position;	                if (negative) {	                    i++;	                }	                try {	                    value = text.charAt(i++) - '0';	                } catch (StringIndexOutOfBoundsException e) {	                    return ~position;	                }	                position += length;	                while (i < position) {	                    value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';	                }	                if (negative) {	                    value = -value;	                }	            }		            bucket.saveField(iFieldType, value);	            return position;	        }	
protected UnpaddedNumber(DateTimeFieldType fieldType,	                       int maxParsedDigits, boolean signed)	        {	            super(fieldType, maxParsedDigits, signed);	        }	
public int estimatePrintedLength() {	            return iMaxParsedDigits;	        }	
public void printTo(	                StringBuffer buf, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) {	            try {	                DateTimeField field = iFieldType.getField(chrono);	                FormatUtils.appendUnpaddedInteger(buf, field.get(instant));	            } catch (RuntimeException e) {	                buf.append('\ufffd');	            }	        }	
public void printTo(	                Writer out, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {	            try {	                DateTimeField field = iFieldType.getField(chrono);	                FormatUtils.writeUnpaddedInteger(out, field.get(instant));	            } catch (RuntimeException e) {	                out.write('\ufffd');	            }	        }	
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {	            if (partial.isSupported(iFieldType)) {	                try {	                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType));	                } catch (RuntimeException e) {	                    buf.append('\ufffd');	                }	            } else {	                buf.append('\ufffd');	            }	        }	
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {	            if (partial.isSupported(iFieldType)) {	                try {	                    FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));	                } catch (RuntimeException e) {	                    out.write('\ufffd');	                }	            } else {	                out.write('\ufffd');	            }	        }	
protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,	                     boolean signed, int minPrintedDigits)	        {	            super(fieldType, maxParsedDigits, signed);	            iMinPrintedDigits = minPrintedDigits;	        }	
public int estimatePrintedLength() {	            return iMaxParsedDigits;	        }	
public void printTo(	                StringBuffer buf, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) {	            try {	                DateTimeField field = iFieldType.getField(chrono);	                FormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits);	            } catch (RuntimeException e) {	                appendUnknownString(buf, iMinPrintedDigits);	            }	        }	
public void printTo(	                Writer out, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {	            try {	                DateTimeField field = iFieldType.getField(chrono);	                FormatUtils.writePaddedInteger(out, field.get(instant), iMinPrintedDigits);	            } catch (RuntimeException e) {	                printUnknownString(out, iMinPrintedDigits);	            }	        }	
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {	            if (partial.isSupported(iFieldType)) {	                try {	                    FormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits);	                } catch (RuntimeException e) {	                    appendUnknownString(buf, iMinPrintedDigits);	                }	            } else {	                appendUnknownString(buf, iMinPrintedDigits);	            }	        }	
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {	            if (partial.isSupported(iFieldType)) {	                try {	                    FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);	                } catch (RuntimeException e) {	                    printUnknownString(out, iMinPrintedDigits);	                }	            } else {	                printUnknownString(out, iMinPrintedDigits);	            }	        }	
protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed) {	            super(fieldType, numDigits, signed, numDigits);	        }	
public int parseInto(DateTimeParserBucket bucket, String text, int position) {	            int newPos = super.parseInto(bucket, text, position);	            if (newPos < 0) {	                return newPos;	            }	            int expectedPos = position + iMaxParsedDigits;	            if (newPos != expectedPos) {	                if (iSigned) {	                    char c = text.charAt(position);	                    if (c == '-' || c == '+') {	                        expectedPos++;	                    }	                }	                if (newPos > expectedPos) {	                    // The failure is at the position of the first extra digit.	                    return ~(expectedPos + 1);	                } else if (newPos < expectedPos) {	                    // The failure is at the position where the next digit should be.	                    return ~newPos;	                }	            }	            return newPos;	        }	
TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse) {	            super();	            iType = type;	            iPivot = pivot;	            iLenientParse = lenientParse;	        }	
public int estimateParsedLength() {	            return iLenientParse ? 4 : 2;	        }	
public int parseInto(DateTimeParserBucket bucket, String text, int position) {	            int limit = text.length() - position;		            if (!iLenientParse) {	                limit = Math.min(2, limit);	                if (limit < 2) {	                    return ~position;	                }	            } else {	                boolean hasSignChar = false;	                boolean negative = false;	                int length = 0;	                while (length < limit) {	                    char c = text.charAt(position + length);	                    if (length == 0 && (c == '-' || c == '+')) {	                        hasSignChar = true;	                        negative = c == '-';	                        if (negative) {	                            length++;	                        } else {	                            // Skip the '+' for parseInt to succeed.	                            position++;	                            limit--;	                        }	                        continue;	                    }	                    if (c < '0' || c > '9') {	                        break;	                    }	                    length++;	                }	                	                if (length == 0) {	                    return ~position;	                }		                if (hasSignChar || length != 2) {	                    int value;	                    if (length >= 9) {	                        // Since value may exceed integer limits, use stock	                        // parser which checks for this.	                        value = Integer.parseInt(text.substring(position, position += length));	                    } else {	                        int i = position;	                        if (negative) {	                            i++;	                        }	                        try {	                            value = text.charAt(i++) - '0';	                        } catch (StringIndexOutOfBoundsException e) {	                            return ~position;	                        }	                        position += length;	                        while (i < position) {	                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';	                        }	                        if (negative) {	                            value = -value;	                        }	                    }	                    	                    bucket.saveField(iType, value);	                    return position;	                }	            }		            int year;	            char c = text.charAt(position);	            if (c < '0' || c > '9') {	                return ~position;	            }	            year = c - '0';	            c = text.charAt(position + 1);	            if (c < '0' || c > '9') {	                return ~position;	            }	            year = ((year << 3) + (year << 1)) + c - '0';		            int pivot = iPivot;	            // If the bucket pivot year is non-null, use that when parsing	            if (bucket.getPivotYear() != null) {	                pivot = bucket.getPivotYear().intValue();	            }		            int low = pivot - 50;		            int t;	            if (low >= 0) {	                t = low % 100;	            } else {	                t = 99 + ((low + 1) % 100);	            }		            year += low + ((year < t) ? 100 : 0) - t;		            bucket.saveField(iType, year);	            return position + 2;	        }	
public int estimatePrintedLength() {	            return 2;	        }	
public void printTo(	                StringBuffer buf, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) {	            int year = getTwoDigitYear(instant, chrono);	            if (year < 0) {	                buf.append('\ufffd');	                buf.append('\ufffd');	            } else {	                FormatUtils.appendPaddedInteger(buf, year, 2);	            }	        }	
public void printTo(	                Writer out, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {	            int year = getTwoDigitYear(instant, chrono);	            if (year < 0) {	                out.write('\ufffd');	                out.write('\ufffd');	            } else {	                FormatUtils.writePaddedInteger(out, year, 2);	            }	        }	
private int getTwoDigitYear(long instant, Chronology chrono) {	            try {	                int year = iType.getField(chrono).get(instant);	                if (year < 0) {	                    year = -year;	                }	                return year % 100;	            } catch (RuntimeException e) {	                return -1;	            }	        }	
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {	            int year = getTwoDigitYear(partial);	            if (year < 0) {	                buf.append('\ufffd');	                buf.append('\ufffd');	            } else {	                FormatUtils.appendPaddedInteger(buf, year, 2);	            }	        }	
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {	            int year = getTwoDigitYear(partial);	            if (year < 0) {	                out.write('\ufffd');	                out.write('\ufffd');	            } else {	                FormatUtils.writePaddedInteger(out, year, 2);	            }	        }	
private int getTwoDigitYear(ReadablePartial partial) {	            if (partial.isSupported(iType)) {	                try {	                    int year = partial.get(iType);	                    if (year < 0) {	                        year = -year;	                    }	                    return year % 100;	                } catch (RuntimeException e) {}	            } 	            return -1;	        }	
TextField(DateTimeFieldType fieldType, boolean isShort) {	            super();	            iFieldType = fieldType;	            iShort = isShort;	        }	
public int estimatePrintedLength() {	            return iShort ? 6 : 20;	        }	
public void printTo(	                StringBuffer buf, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) {	            try {	                buf.append(print(instant, chrono, locale));	            } catch (RuntimeException e) {	                buf.append('\ufffd');	            }	        }	
public void printTo(	                Writer out, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {	            try {	                out.write(print(instant, chrono, locale));	            } catch (RuntimeException e) {	                out.write('\ufffd');	            }	        }	
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {	            try {	                buf.append(print(partial, locale));	            } catch (RuntimeException e) {	                buf.append('\ufffd');	            }	        }	
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {	            try {	                out.write(print(partial, locale));	            } catch (RuntimeException e) {	                out.write('\ufffd');	            }	        }	
private String print(long instant, Chronology chrono, Locale locale) {	            DateTimeField field = iFieldType.getField(chrono);	            if (iShort) {	                return field.getAsShortText(instant, locale);	            } else {	                return field.getAsText(instant, locale);	            }	        }	
private String print(ReadablePartial partial, Locale locale) {	            if (partial.isSupported(iFieldType)) {	                DateTimeField field = iFieldType.getField(partial.getChronology());	                if (iShort) {	                    return field.getAsShortText(partial, locale);	                } else {	                    return field.getAsText(partial, locale);	                }	            } else {	                return "\ufffd";	            }	        }	
public int estimateParsedLength() {	            return estimatePrintedLength();	        }	
@SuppressWarnings("unchecked")	        public int parseInto(DateTimeParserBucket bucket, String text, int position) {	            Locale locale = bucket.getLocale();	            // handle languages which might have non ASCII A-Z or punctuation	            // bug 1788282	            Set<String> validValues = null;	            int maxLength = 0;	            synchronized (cParseCache) {	                Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale);	                if (innerMap == null) {	                    innerMap = new HashMap<DateTimeFieldType, Object[]>();	                    cParseCache.put(locale, innerMap);	                }	                Object[] array = innerMap.get(iFieldType);	                if (array == null) {	                    validValues = new HashSet<String>(32);	                    MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);	                    Property property = dt.property(iFieldType);	                    int min = property.getMinimumValueOverall();	                    int max = property.getMaximumValueOverall();	                    if (max - min > 32) {  // protect against invalid fields	                        return ~position;	                    }	                    maxLength = property.getMaximumTextLength(locale);	                    for (int i = min; i <= max; i++) {	                        property.set(i);	                        validValues.add(property.getAsShortText(locale));	                        validValues.add(property.getAsShortText(locale).toLowerCase(locale));	                        validValues.add(property.getAsShortText(locale).toUpperCase(locale));	                        validValues.add(property.getAsText(locale));	                        validValues.add(property.getAsText(locale).toLowerCase(locale));	                        validValues.add(property.getAsText(locale).toUpperCase(locale));	                    }	                    if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) {	                        // hack to support for parsing "BCE" and "CE" if the language is English	                        validValues.add("BCE");	                        validValues.add("bce");	                        validValues.add("CE");	                        validValues.add("ce");	                        maxLength = 3;	                    }	                    array = new Object[] {validValues, new Integer(maxLength)};	                    innerMap.put(iFieldType, array);	                } else {	                    validValues = (Set<String>) array[0];	                    maxLength = ((Integer) array[1]).intValue();	                }	            }	            // match the longest string first using our knowledge of the max length	            int limit = Math.min(text.length(), position + maxLength);	            for (int i = limit; i > position; i--) {	                String match = text.substring(position, i);	                if (validValues.contains(match)) {	                    bucket.saveField(iFieldType, match, locale);	                    return i;	                }	            }	            return ~position;	        }	
protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {	            super();	            iFieldType = fieldType;	            // Limit the precision requirements.	            if (maxDigits > 18) {	                maxDigits = 18;	            }	            iMinDigits = minDigits;	            iMaxDigits = maxDigits;	        }	
public int estimatePrintedLength() {	            return iMaxDigits;	        }	
public void printTo(	                StringBuffer buf, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) {	            try {	                printTo(buf, null, instant, chrono);	            } catch (IOException e) {	                // Not gonna happen.	            }	        }	
public void printTo(	                Writer out, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {	            printTo(null, out, instant, chrono);	        }	
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {	            // removed check whether field is supported, as input field is typically	            // secondOfDay which is unsupported by TimeOfDay	            long millis = partial.getChronology().set(partial, 0L);	            try {	                printTo(buf, null, millis, partial.getChronology());	            } catch (IOException e) {	                // Not gonna happen.	            }	        }	
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {	            // removed check whether field is supported, as input field is typically	            // secondOfDay which is unsupported by TimeOfDay	            long millis = partial.getChronology().set(partial, 0L);	            printTo(null, out, millis, partial.getChronology());	        }	
protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono)	            throws IOException	        {	            DateTimeField field = iFieldType.getField(chrono);	            int minDigits = iMinDigits;		            long fraction;	            try {	                fraction = field.remainder(instant);	            } catch (RuntimeException e) {	                if (buf != null) {	                    appendUnknownString(buf, minDigits);	                } else {	                    printUnknownString(out, minDigits);	                }	                return;	            }		            if (fraction == 0) {	                if (buf != null) {	                    while (--minDigits >= 0) {	                        buf.append('0');	                    }	                } else {	                    while (--minDigits >= 0) {	                        out.write('0');	                    }	                }	                return;	            }		            String str;	            long[] fractionData = getFractionData(fraction, field);	            long scaled = fractionData[0];	            int maxDigits = (int) fractionData[1];	            	            if ((scaled & 0x7fffffff) == scaled) {	                str = Integer.toString((int) scaled);	            } else {	                str = Long.toString(scaled);	            }		            int length = str.length();	            int digits = maxDigits;	            while (length < digits) {	                if (buf != null) {	                    buf.append('0');	                } else {	                    out.write('0');	                }	                minDigits--;	                digits--;	            }		            if (minDigits < digits) {	                // Chop off as many trailing zero digits as necessary.	                while (minDigits < digits) {	                    if (length <= 1 || str.charAt(length - 1) != '0') {	                        break;	                    }	                    digits--;	                    length--;	                }	                if (length < str.length()) {	                    if (buf != null) {	                        for (int i=0; i<length; i++) {	                            buf.append(str.charAt(i));	                        }	                    } else {	                        for (int i=0; i<length; i++) {	                            out.write(str.charAt(i));	                        }	                    }	                    return;	                }	            }		            if (buf != null) {	                buf.append(str);	            } else {	                out.write(str);	            }	        }	
private long[] getFractionData(long fraction, DateTimeField field) {	            long rangeMillis = field.getDurationField().getUnitMillis();	            long scalar;	            int maxDigits = iMaxDigits;	            while (true) {	                switch (maxDigits) {	                default: scalar = 1L; break;	                case 1:  scalar = 10L; break;	                case 2:  scalar = 100L; break;	                case 3:  scalar = 1000L; break;	                case 4:  scalar = 10000L; break;	                case 5:  scalar = 100000L; break;	                case 6:  scalar = 1000000L; break;	                case 7:  scalar = 10000000L; break;	                case 8:  scalar = 100000000L; break;	                case 9:  scalar = 1000000000L; break;	                case 10: scalar = 10000000000L; break;	                case 11: scalar = 100000000000L; break;	                case 12: scalar = 1000000000000L; break;	                case 13: scalar = 10000000000000L; break;	                case 14: scalar = 100000000000000L; break;	                case 15: scalar = 1000000000000000L; break;	                case 16: scalar = 10000000000000000L; break;	                case 17: scalar = 100000000000000000L; break;	                case 18: scalar = 1000000000000000000L; break;	                }	                if (((rangeMillis * scalar) / scalar) == rangeMillis) {	                    break;	                }	                // Overflowed: scale down.	                maxDigits--;	            }	            	            return new long[] {fraction * scalar / rangeMillis, maxDigits};	        }	
public int estimateParsedLength() {	            return iMaxDigits;	        }	
public int parseInto(DateTimeParserBucket bucket, String text, int position) {	            DateTimeField field = iFieldType.getField(bucket.getChronology());	            	            int limit = Math.min(iMaxDigits, text.length() - position);		            long value = 0;	            long n = field.getDurationField().getUnitMillis() * 10;	            int length = 0;	            while (length < limit) {	                char c = text.charAt(position + length);	                if (c < '0' || c > '9') {	                    break;	                }	                length++;	                long nn = n / 10;	                value += (c - '0') * nn;	                n = nn;	            }		            value /= 10;		            if (length == 0) {	                return ~position;	            }		            if (value > Integer.MAX_VALUE) {	                return ~position;	            }		            DateTimeField parseField = new PreciseDateTimeField(	                DateTimeFieldType.millisOfSecond(),	                MillisDurationField.INSTANCE,	                field.getDurationField());		            bucket.saveField(parseField, (int) value);		            return position + length;	        }	
TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,	                                boolean showSeparators,	                                int minFields, int maxFields)	        {	            super();	            iZeroOffsetPrintText = zeroOffsetPrintText;	            iZeroOffsetParseText = zeroOffsetParseText;	            iShowSeparators = showSeparators;	            if (minFields <= 0 || maxFields < minFields) {	                throw new IllegalArgumentException();	            }	            if (minFields > 4) {	                minFields = 4;	                maxFields = 4;	            }	            iMinFields = minFields;	            iMaxFields = maxFields;	        }	
public int estimatePrintedLength() {	            int est = 1 + iMinFields << 1;	            if (iShowSeparators) {	                est += iMinFields - 1;	            }	            if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) {	                est = iZeroOffsetPrintText.length();	            }	            return est;	        }	
public void printTo(	                StringBuffer buf, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) {	            if (displayZone == null) {	                return;  // no zone	            }	            if (displayOffset == 0 && iZeroOffsetPrintText != null) {	                buf.append(iZeroOffsetPrintText);	                return;	            }	            if (displayOffset >= 0) {	                buf.append('+');	            } else {	                buf.append('-');	                displayOffset = -displayOffset;	            }		            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;	            FormatUtils.appendPaddedInteger(buf, hours, 2);	            if (iMaxFields == 1) {	                return;	            }	            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;	            if (displayOffset == 0 && iMinFields <= 1) {	                return;	            }		            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;	            if (iShowSeparators) {	                buf.append(':');	            }	            FormatUtils.appendPaddedInteger(buf, minutes, 2);	            if (iMaxFields == 2) {	                return;	            }	            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;	            if (displayOffset == 0 && iMinFields <= 2) {	                return;	            }		            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;	            if (iShowSeparators) {	                buf.append(':');	            }	            FormatUtils.appendPaddedInteger(buf, seconds, 2);	            if (iMaxFields == 3) {	                return;	            }	            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;	            if (displayOffset == 0 && iMinFields <= 3) {	                return;	            }		            if (iShowSeparators) {	                buf.append('.');	            }	            FormatUtils.appendPaddedInteger(buf, displayOffset, 3);	        }	
public void printTo(	                Writer out, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {	            if (displayZone == null) {	                return;  // no zone	            }	            if (displayOffset == 0 && iZeroOffsetPrintText != null) {	                out.write(iZeroOffsetPrintText);	                return;	            }	            if (displayOffset >= 0) {	                out.write('+');	            } else {	                out.write('-');	                displayOffset = -displayOffset;	            }		            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;	            FormatUtils.writePaddedInteger(out, hours, 2);	            if (iMaxFields == 1) {	                return;	            }	            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;	            if (displayOffset == 0 && iMinFields == 1) {	                return;	            }		            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;	            if (iShowSeparators) {	                out.write(':');	            }	            FormatUtils.writePaddedInteger(out, minutes, 2);	            if (iMaxFields == 2) {	                return;	            }	            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;	            if (displayOffset == 0 && iMinFields == 2) {	                return;	            }		            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;	            if (iShowSeparators) {	                out.write(':');	            }	            FormatUtils.writePaddedInteger(out, seconds, 2);	            if (iMaxFields == 3) {	                return;	            }	            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;	            if (displayOffset == 0 && iMinFields == 3) {	                return;	            }		            if (iShowSeparators) {	                out.write('.');	            }	            FormatUtils.writePaddedInteger(out, displayOffset, 3);	        }	
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {	            // no zone info	        }	
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {	            // no zone info	        }	
public int estimateParsedLength() {	            return estimatePrintedLength();	        }	
public int parseInto(DateTimeParserBucket bucket, String text, int position) {	            int limit = text.length() - position;		            zeroOffset:	            if (iZeroOffsetParseText != null) {	                if (iZeroOffsetParseText.length() == 0) {	                    // Peek ahead, looking for sign character.	                    if (limit > 0) {	                        char c = text.charAt(position);	                        if (c == '-' || c == '+') {	                            break zeroOffset;	                        }	                    }	                    bucket.setOffset(0);	                    return position;	                }	                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {	                    bucket.setOffset(0);	                    return position + iZeroOffsetParseText.length();	                }	            }		            // Format to expect is sign character followed by at least one digit.		            if (limit <= 1) {	                return ~position;	            }		            boolean negative;	            char c = text.charAt(position);	            if (c == '-') {	                negative = true;	            } else if (c == '+') {	                negative = false;	            } else {	                return ~position;	            }		            limit--;	            position++;		            // Format following sign is one of:	            //	            // hh	            // hhmm	            // hhmmss	            // hhmmssSSS	            // hh:mm	            // hh:mm:ss	            // hh:mm:ss.SSS		            // First parse hours.		            if (digitCount(text, position, 2) < 2) {	                // Need two digits for hour.	                return ~position;	            }		            int offset;		            int hours = FormatUtils.parseTwoDigits(text, position);	            if (hours > 23) {	                return ~position;	            }	            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;	            limit -= 2;	            position += 2;		            parse: {	                // Need to decide now if separators are expected or parsing	                // stops at hour field.		                if (limit <= 0) {	                    break parse;	                }		                boolean expectSeparators;	                c = text.charAt(position);	                if (c == ':') {	                    expectSeparators = true;	                    limit--;	                    position++;	                } else if (c >= '0' && c <= '9') {	                    expectSeparators = false;	                } else {	                    break parse;	                }		                // Proceed to parse minutes.		                int count = digitCount(text, position, 2);	                if (count == 0 && !expectSeparators) {	                    break parse;	                } else if (count < 2) {	                    // Need two digits for minute.	                    return ~position;	                }		                int minutes = FormatUtils.parseTwoDigits(text, position);	                if (minutes > 59) {	                    return ~position;	                }	                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;	                limit -= 2;	                position += 2;		                // Proceed to parse seconds.		                if (limit <= 0) {	                    break parse;	                }		                if (expectSeparators) {	                    if (text.charAt(position) != ':') {	                        break parse;	                    }	                    limit--;	                    position++;	                }		                count = digitCount(text, position, 2);	                if (count == 0 && !expectSeparators) {	                    break parse;	                } else if (count < 2) {	                    // Need two digits for second.	                    return ~position;	                }		                int seconds = FormatUtils.parseTwoDigits(text, position);	                if (seconds > 59) {	                    return ~position;	                }	                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;	                limit -= 2;	                position += 2;		                // Proceed to parse fraction of second.		                if (limit <= 0) {	                    break parse;	                }		                if (expectSeparators) {	                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {	                        break parse;	                    }	                    limit--;	                    position++;	                }	                	                count = digitCount(text, position, 3);	                if (count == 0 && !expectSeparators) {	                    break parse;	                } else if (count < 1) {	                    // Need at least one digit for fraction of second.	                    return ~position;	                }		                offset += (text.charAt(position++) - '0') * 100;	                if (count > 1) {	                    offset += (text.charAt(position++) - '0') * 10;	                    if (count > 2) {	                        offset += text.charAt(position++) - '0';	                    }	                }	            }		            bucket.setOffset(negative ? -offset : offset);	            return position;	        }	
/**	         * Returns actual amount of digits to parse, but no more than original	         * 'amount' parameter.	         */	        private int digitCount(String text, int position, int amount) {	            int limit = Math.min(text.length() - position, amount);	            amount = 0;	            for (; limit > 0; limit--) {	                char c = text.charAt(position + amount);	                if (c < '0' || c > '9') {	                    break;	                }	                amount++;	            }	            return amount;	        }	
TimeZoneName(int type) {	            super();	            iType = type;	        }	
public int estimatePrintedLength() {	            return (iType == SHORT_NAME ? 4 : 20);	        }	
public void printTo(	                StringBuffer buf, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) {	            buf.append(print(instant - displayOffset, displayZone, locale));	        }	
public void printTo(	                Writer out, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {	            out.write(print(instant - displayOffset, displayZone, locale));	        }	
private String print(long instant, DateTimeZone displayZone, Locale locale) {	            if (displayZone == null) {	                return "";  // no zone	            }	            switch (iType) {	                case LONG_NAME:	                    return displayZone.getName(instant, locale);	                case SHORT_NAME:	                    return displayZone.getShortName(instant, locale);	                case ID:	                    return displayZone.getID();	            }	            return "";	        }	
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {	            // no zone info	        }	
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {	            // no zone info	        }	
Composite(List<Object> elementPairs) {	            super();		            List<Object> printerList = new ArrayList<Object>();	            List<Object> parserList = new ArrayList<Object>();		            decompose(elementPairs, printerList, parserList);		            if (printerList.size() <= 0) {	                iPrinters = null;	                iPrintedLengthEstimate = 0;	            } else {	                int size = printerList.size();	                iPrinters = new DateTimePrinter[size];	                int printEst = 0;	                for (int i=0; i<size; i++) {	                    DateTimePrinter printer = (DateTimePrinter) printerList.get(i);	                    printEst += printer.estimatePrintedLength();	                    iPrinters[i] = printer;	                }	                iPrintedLengthEstimate = printEst;	            }		            if (parserList.size() <= 0) {	                iParsers = null;	                iParsedLengthEstimate = 0;	            } else {	                int size = parserList.size();	                iParsers = new DateTimeParser[size];	                int parseEst = 0;	                for (int i=0; i<size; i++) {	                    DateTimeParser parser = (DateTimeParser) parserList.get(i);	                    parseEst += parser.estimateParsedLength();	                    iParsers[i] = parser;	                }	                iParsedLengthEstimate = parseEst;	            }	        }	
public int estimatePrintedLength() {	            return iPrintedLengthEstimate;	        }	
public void printTo(	                StringBuffer buf, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) {	            DateTimePrinter[] elements = iPrinters;	            if (elements == null) {	                throw new UnsupportedOperationException();	            }		            if (locale == null) {	                // Guard against default locale changing concurrently.	                locale = Locale.getDefault();	            }		            int len = elements.length;	            for (int i = 0; i < len; i++) {	                elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);	            }	        }	
public void printTo(	                Writer out, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {	            DateTimePrinter[] elements = iPrinters;	            if (elements == null) {	                throw new UnsupportedOperationException();	            }		            if (locale == null) {	                // Guard against default locale changing concurrently.	                locale = Locale.getDefault();	            }		            int len = elements.length;	            for (int i = 0; i < len; i++) {	                elements[i].printTo(out, instant, chrono, displayOffset, displayZone, locale);	            }	        }	
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {	            DateTimePrinter[] elements = iPrinters;	            if (elements == null) {	                throw new UnsupportedOperationException();	            }		            if (locale == null) {	                // Guard against default locale changing concurrently.	                locale = Locale.getDefault();	            }		            int len = elements.length;	            for (int i=0; i<len; i++) {	                elements[i].printTo(buf, partial, locale);	            }	        }	
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {	            DateTimePrinter[] elements = iPrinters;	            if (elements == null) {	                throw new UnsupportedOperationException();	            }		            if (locale == null) {	                // Guard against default locale changing concurrently.	                locale = Locale.getDefault();	            }		            int len = elements.length;	            for (int i=0; i<len; i++) {	                elements[i].printTo(out, partial, locale);	            }	        }	
public int estimateParsedLength() {	            return iParsedLengthEstimate;	        }	
public int parseInto(DateTimeParserBucket bucket, String text, int position) {	            DateTimeParser[] elements = iParsers;	            if (elements == null) {	                throw new UnsupportedOperationException();	            }		            int len = elements.length;	            for (int i=0; i<len && position >= 0; i++) {	                position = elements[i].parseInto(bucket, text, position);	            }	            return position;	        }	
boolean isPrinter() {	            return iPrinters != null;	        }	
boolean isParser() {	            return iParsers != null;	        }	
/**	         * Processes the element pairs, putting results into the given printer	         * and parser lists.	         */	        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {	            int size = elementPairs.size();	            for (int i=0; i<size; i+=2) {	                Object element = elementPairs.get(i);	                if (element instanceof DateTimePrinter) {	                    if (element instanceof Composite) {	                        addArrayToList(printerList, ((Composite)element).iPrinters);	                    } else {	                        printerList.add(element);	                    }	                }		                element = elementPairs.get(i + 1);	                if (element instanceof DateTimeParser) {	                    if (element instanceof Composite) {	                        addArrayToList(parserList, ((Composite)element).iParsers);	                    } else {	                        parserList.add(element);	                    }	                }	            }	        }	
private void addArrayToList(List<Object> list, Object[] array) {	            if (array != null) {	                for (int i=0; i<array.length; i++) {	                    list.add(array[i]);	                }	            }	        }	
MatchingParser(DateTimeParser[] parsers) {	            super();	            iParsers = parsers;	            int est = 0;	            for (int i=parsers.length; --i>=0 ;) {	                DateTimeParser parser = parsers[i];	                if (parser != null) {	                    int len = parser.estimateParsedLength();	                    if (len > est) {	                        est = len;	                    }	                }	            }	            iParsedLengthEstimate = est;	        }	
public int estimateParsedLength() {	            return iParsedLengthEstimate;	        }	
public int parseInto(DateTimeParserBucket bucket, String text, int position) {	            DateTimeParser[] parsers = iParsers;	            int length = parsers.length;		            final Object originalState = bucket.saveState();	            boolean isOptional = false;		            int bestValidPos = position;	            Object bestValidState = null;		            int bestInvalidPos = position;		            for (int i=0; i<length; i++) {	                DateTimeParser parser = parsers[i];	                if (parser == null) {	                    // The empty parser wins only if nothing is better.	                    if (bestValidPos <= position) {	                        return position;	                    }	                    isOptional = true;	                    break;	                }	                int parsePos = parser.parseInto(bucket, text, position);	                if (parsePos >= position) {	                    if (parsePos > bestValidPos) {	                        if (parsePos >= text.length() ||	                            (i + 1) >= length || parsers[i + 1] == null) {		                            // Completely parsed text or no more parsers to	                            // check. Skip the rest.	                            return parsePos;	                        }	                        bestValidPos = parsePos;	                        bestValidState = bucket.saveState();	                    }	                } else {	                    if (parsePos < 0) {	                        parsePos = ~parsePos;	                        if (parsePos > bestInvalidPos) {	                            bestInvalidPos = parsePos;	                        }	                    }	                }	                bucket.restoreState(originalState);	            }		            if (bestValidPos > position || (bestValidPos == position && isOptional)) {	                // Restore the state to the best valid parse.	                if (bestValidState != null) {	                    bucket.restoreState(bestValidState);	                }	                return bestValidPos;	            }		            return ~bestInvalidPos;	        }	
/**	     * Factory to create a formatter from a pattern string.	     * The pattern string is described above in the class level javadoc.	     * It is very similar to SimpleDateFormat patterns.	     * <p>	     * The format may contain locale specific output, and this will change as	     * you change the locale of the formatter.	     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.	     * For example:	     * <pre>	     * DateTimeFormat.forPattern(pattern).withLocale(Locale.FRANCE).print(dt);	     * </pre>	     *	     * @param pattern  pattern specification	     * @return the formatter	     * @throws IllegalArgumentException if the pattern is invalid	     */	    public static DateTimeFormatter forPattern(String pattern) {	        return createFormatterForPattern(pattern);	    }	
/**	     * Factory to create a format from a two character style pattern.	     * <p>	     * The first character is the date style, and the second character is the	     * time style. Specify a character of 'S' for short style, 'M' for medium,	     * 'L' for long, and 'F' for full.	     * A date or time may be ommitted by specifying a style character '-'.	     * <p>	     * The returned formatter will dynamically adjust to the locale that	     * the print/parse takes place in. Thus you just call	     * {@link DateTimeFormatter#withLocale(Locale)} and the Short/Medium/Long/Full	     * style for that locale will be output. For example:	     * <pre>	     * DateTimeFormat.forStyle(style).withLocale(Locale.FRANCE).print(dt);	     * </pre>	     *	     * @param style  two characters from the set {"S", "M", "L", "F", "-"}	     * @return the formatter	     * @throws IllegalArgumentException if the style is invalid	     */	    public static DateTimeFormatter forStyle(String style) {	        return createFormatterForStyle(style);	    }	
/**	     * Returns the pattern used by a particular style and locale.	     * <p>	     * The first character is the date style, and the second character is the	     * time style. Specify a character of 'S' for short style, 'M' for medium,	     * 'L' for long, and 'F' for full.	     * A date or time may be ommitted by specifying a style character '-'.	     *	     * @param style  two characters from the set {"S", "M", "L", "F", "-"}	     * @param locale  locale to use, null means default	     * @return the formatter	     * @throws IllegalArgumentException if the style is invalid	     * @since 1.3	     */	    public static String patternForStyle(String style, Locale locale) {	        DateTimeFormatter formatter = createFormatterForStyle(style);	        if (locale == null) {	            locale = Locale.getDefault();	        }	        // Not pretty, but it works.	        return ((StyleFormatter) formatter.getPrinter()).getPattern(locale);	    }	
/**	     * Creates a format that outputs a short date format.	     * <p>	     * The format will change as you change the locale of the formatter.	     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.	     * 	     * @return the formatter	     */	    public static DateTimeFormatter shortDate() {	        return createFormatterForStyleIndex(SHORT, NONE);	    }	
/**	     * Creates a format that outputs a short time format.	     * <p>	     * The format will change as you change the locale of the formatter.	     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.	     * 	     * @return the formatter	     */	    public static DateTimeFormatter shortTime() {	        return createFormatterForStyleIndex(NONE, SHORT);	    }	
/**	     * Creates a format that outputs a short datetime format.	     * <p>	     * The format will change as you change the locale of the formatter.	     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.	     * 	     * @return the formatter	     */	    public static DateTimeFormatter shortDateTime() {	        return createFormatterForStyleIndex(SHORT, SHORT);	    }	
/**	     * Creates a format that outputs a medium date format.	     * <p>	     * The format will change as you change the locale of the formatter.	     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.	     * 	     * @return the formatter	     */	    public static DateTimeFormatter mediumDate() {	        return createFormatterForStyleIndex(MEDIUM, NONE);	    }	
/**	     * Creates a format that outputs a medium time format.	     * <p>	     * The format will change as you change the locale of the formatter.	     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.	     * 	     * @return the formatter	     */	    public static DateTimeFormatter mediumTime() {	        return createFormatterForStyleIndex(NONE, MEDIUM);	    }	
/**	     * Creates a format that outputs a medium datetime format.	     * <p>	     * The format will change as you change the locale of the formatter.	     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.	     * 	     * @return the formatter	     */	    public static DateTimeFormatter mediumDateTime() {	        return createFormatterForStyleIndex(MEDIUM, MEDIUM);	    }	
/**	     * Creates a format that outputs a long date format.	     * <p>	     * The format will change as you change the locale of the formatter.	     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.	     * 	     * @return the formatter	     */	    public static DateTimeFormatter longDate() {	        return createFormatterForStyleIndex(LONG, NONE);	    }	
/**	     * Creates a format that outputs a long time format.	     * <p>	     * The format will change as you change the locale of the formatter.	     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.	     * 	     * @return the formatter	     */	    public static DateTimeFormatter longTime() {	        return createFormatterForStyleIndex(NONE, LONG);	    }	
/**	     * Creates a format that outputs a long datetime format.	     * <p>	     * The format will change as you change the locale of the formatter.	     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.	     * 	     * @return the formatter	     */	    public static DateTimeFormatter longDateTime() {	        return createFormatterForStyleIndex(LONG, LONG);	    }	
/**	     * Creates a format that outputs a full date format.	     * <p>	     * The format will change as you change the locale of the formatter.	     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.	     * 	     * @return the formatter	     */	    public static DateTimeFormatter fullDate() {	        return createFormatterForStyleIndex(FULL, NONE);	    }	
/**	     * Creates a format that outputs a full time format.	     * <p>	     * The format will change as you change the locale of the formatter.	     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.	     * 	     * @return the formatter	     */	    public static DateTimeFormatter fullTime() {	        return createFormatterForStyleIndex(NONE, FULL);	    }	
/**	     * Creates a format that outputs a full datetime format.	     * <p>	     * The format will change as you change the locale of the formatter.	     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.	     * 	     * @return the formatter	     */	    public static DateTimeFormatter fullDateTime() {	        return createFormatterForStyleIndex(FULL, FULL);	    }	
/**	     * Parses the given pattern and appends the rules to the given	     * DateTimeFormatterBuilder.	     *	     * @param pattern  pattern specification	     * @throws IllegalArgumentException if the pattern is invalid	     */	    static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {	        parsePatternTo(builder, pattern);	    }	
/**	     * Constructor.	     *	     * @since 1.1 (previously private)	     */	    protected DateTimeFormat() {	        super();	    }	
/**	     * Parses the given pattern and appends the rules to the given	     * DateTimeFormatterBuilder.	     *	     * @param pattern  pattern specification	     * @throws IllegalArgumentException if the pattern is invalid	     * @see #forPattern	     */	    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {	        int length = pattern.length();	        int[] indexRef = new int[1];		        for (int i=0; i<length; i++) {	            indexRef[0] = i;	            String token = parseToken(pattern, indexRef);	            i = indexRef[0];		            int tokenLen = token.length();	            if (tokenLen == 0) {	                break;	            }	            char c = token.charAt(0);		            switch (c) {	            case 'G': // era designator (text)	                builder.appendEraText();	                break;	            case 'C': // century of era (number)	                builder.appendCenturyOfEra(tokenLen, tokenLen);	                break;	            case 'x': // weekyear (number)	            case 'y': // year (number)	            case 'Y': // year of era (number)	                if (tokenLen == 2) {	                    boolean lenientParse = true;		                    // Peek ahead to next token.	                    if (i + 1 < length) {	                        indexRef[0]++;	                        if (isNumericToken(parseToken(pattern, indexRef))) {	                            // If next token is a number, cannot support	                            // lenient parse, because it will consume digits	                            // that it should not.	                            lenientParse = false;	                        }	                        indexRef[0]--;	                    }		                    // Use pivots which are compatible with SimpleDateFormat.	                    switch (c) {	                    case 'x':	                        builder.appendTwoDigitWeekyear	                            (new DateTime().getWeekyear() - 30, lenientParse);	                        break;	                    case 'y':	                    case 'Y':	                    default:	                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);	                        break;	                    }	                } else {	                    // Try to support long year values.	                    int maxDigits = 9;		                    // Peek ahead to next token.	                    if (i + 1 < length) {	                        indexRef[0]++;	                        if (isNumericToken(parseToken(pattern, indexRef))) {	                            // If next token is a number, cannot support long years.	                            maxDigits = tokenLen;	                        }	                        indexRef[0]--;	                    }		                    switch (c) {	                    case 'x':	                        builder.appendWeekyear(tokenLen, maxDigits);	                        break;	                    case 'y':	                        builder.appendYear(tokenLen, maxDigits);	                        break;	                    case 'Y':	                        builder.appendYearOfEra(tokenLen, maxDigits);	                        break;	                    }	                }	                break;	            case 'M': // month of year (text and number)	                if (tokenLen >= 3) {	                    if (tokenLen >= 4) {	                        builder.appendMonthOfYearText();	                    } else {	                        builder.appendMonthOfYearShortText();	                    }	                } else {	                    builder.appendMonthOfYear(tokenLen);	                }	                break;	            case 'd': // day of month (number)	                builder.appendDayOfMonth(tokenLen);	                break;	            case 'a': // am/pm marker (text)	                builder.appendHalfdayOfDayText();	                break;	            case 'h': // clockhour of halfday (number, 1..12)	                builder.appendClockhourOfHalfday(tokenLen);	                break;	            case 'H': // hour of day (number, 0..23)	                builder.appendHourOfDay(tokenLen);	                break;	            case 'k': // clockhour of day (1..24)	                builder.appendClockhourOfDay(tokenLen);	                break;	            case 'K': // hour of halfday (0..11)	                builder.appendHourOfHalfday(tokenLen);	                break;	            case 'm': // minute of hour (number)	                builder.appendMinuteOfHour(tokenLen);	                break;	            case 's': // second of minute (number)	                builder.appendSecondOfMinute(tokenLen);	                break;	            case 'S': // fraction of second (number)	                builder.appendFractionOfSecond(tokenLen, tokenLen);	                break;	            case 'e': // day of week (number)	                builder.appendDayOfWeek(tokenLen);	                break;	            case 'E': // dayOfWeek (text)	                if (tokenLen >= 4) {	                    builder.appendDayOfWeekText();	                } else {	                    builder.appendDayOfWeekShortText();	                }	                break;	            case 'D': // day of year (number)	                builder.appendDayOfYear(tokenLen);	                break;	            case 'w': // week of weekyear (number)	                builder.appendWeekOfWeekyear(tokenLen);	                break;	            case 'z': // time zone (text)	                if (tokenLen >= 4) {	                    builder.appendTimeZoneName();	                } else {	                    builder.appendTimeZoneShortName();	                }	                break;	            case 'Z': // time zone offset	                if (tokenLen == 1) {	                    builder.appendTimeZoneOffset(null, "Z", false, 2, 2);	                } else if (tokenLen == 2) {	                    builder.appendTimeZoneOffset(null, "Z", true, 2, 2);	                } else {	                    builder.appendTimeZoneId();	                }	                break;	            case '\'': // literal text	                String sub = token.substring(1);	                if (sub.length() == 1) {	                    builder.appendLiteral(sub.charAt(0));	                } else {	                    // Create copy of sub since otherwise the temporary quoted	                    // string would still be referenced internally.	                    builder.appendLiteral(new String(sub));	                }	                break;	            default:	                throw new IllegalArgumentException	                    ("Illegal pattern component: " + token);	            }	        }	    }	
/**	     * Parses an individual token.	     * 	     * @param pattern  the pattern string	     * @param indexRef  a single element array, where the input is the start	     *  location and the output is the location after parsing the token	     * @return the parsed token	     */	    private static String parseToken(String pattern, int[] indexRef) {	        StringBuffer buf = new StringBuffer();		        int i = indexRef[0];	        int length = pattern.length();		        char c = pattern.charAt(i);	        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {	            // Scan a run of the same character, which indicates a time	            // pattern.	            buf.append(c);		            while (i + 1 < length) {	                char peek = pattern.charAt(i + 1);	                if (peek == c) {	                    buf.append(c);	                    i++;	                } else {	                    break;	                }	            }	        } else {	            // This will identify token as text.	            buf.append('\'');		            boolean inLiteral = false;		            for (; i < length; i++) {	                c = pattern.charAt(i);	                	                if (c == '\'') {	                    if (i + 1 < length && pattern.charAt(i + 1) == '\'') {	                        // '' is treated as escaped '	                        i++;	                        buf.append(c);	                    } else {	                        inLiteral = !inLiteral;	                    }	                } else if (!inLiteral &&	                           (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {	                    i--;	                    break;	                } else {	                    buf.append(c);	                }	            }	        }		        indexRef[0] = i;	        return buf.toString();	    }	
/**	     * Returns true if token should be parsed as a numeric field.	     * 	     * @param token  the token to parse	     * @return true if numeric field	     */	    private static boolean isNumericToken(String token) {	        int tokenLen = token.length();	        if (tokenLen > 0) {	            char c = token.charAt(0);	            switch (c) {	            case 'c': // century (number)	            case 'C': // century of era (number)	            case 'x': // weekyear (number)	            case 'y': // year (number)	            case 'Y': // year of era (number)	            case 'd': // day of month (number)	            case 'h': // hour of day (number, 1..12)	            case 'H': // hour of day (number, 0..23)	            case 'm': // minute of hour (number)	            case 's': // second of minute (number)	            case 'S': // fraction of second (number)	            case 'e': // day of week (number)	            case 'D': // day of year (number)	            case 'F': // day of week in month (number)	            case 'w': // week of year (number)	            case 'W': // week of month (number)	            case 'k': // hour of day (1..24)	            case 'K': // hour of day (0..11)	                return true;	            case 'M': // month of year (text and number)	                if (tokenLen <= 2) {	                    return true;	                }	            }	        }	            	        return false;	    }	
/**	     * Select a format from a custom pattern.	     *	     * @param pattern  pattern specification	     * @throws IllegalArgumentException if the pattern is invalid	     * @see #appendPatternTo	     */	    private static DateTimeFormatter createFormatterForPattern(String pattern) {	        if (pattern == null || pattern.length() == 0) {	            throw new IllegalArgumentException("Invalid pattern specification");	        }	        DateTimeFormatter formatter = null;	        synchronized (cPatternedCache) {	            formatter = cPatternedCache.get(pattern);	            if (formatter == null) {	                DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();	                parsePatternTo(builder, pattern);	                formatter = builder.toFormatter();		                cPatternedCache.put(pattern, formatter);	            }	        }	        return formatter;	    }	
/**	     * Select a format from a two character style pattern. The first character	     * is the date style, and the second character is the time style. Specify a	     * character of 'S' for short style, 'M' for medium, 'L' for long, and 'F'	     * for full. A date or time may be ommitted by specifying a style character '-'.	     *	     * @param style  two characters from the set {"S", "M", "L", "F", "-"}	     * @throws IllegalArgumentException if the style is invalid	     */	    private static DateTimeFormatter createFormatterForStyle(String style) {	        if (style == null || style.length() != 2) {	            throw new IllegalArgumentException("Invalid style specification: " + style);	        }	        int dateStyle = selectStyle(style.charAt(0));	        int timeStyle = selectStyle(style.charAt(1));	        if (dateStyle == NONE && timeStyle == NONE) {	            throw new IllegalArgumentException("Style '--' is invalid");	        }	        return createFormatterForStyleIndex(dateStyle, timeStyle);	    }	
/**	     * Gets the formatter for the specified style.	     * 	     * @param dateStyle  the date style	     * @param timeStyle  the time style	     * @return the formatter	     */	    private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle) {	        int index = ((dateStyle << 2) + dateStyle) + timeStyle;	        DateTimeFormatter f = null;	        synchronized (cStyleCache) {	            f = cStyleCache[index];	            if (f == null) {	                int type = DATETIME;	                if (dateStyle == NONE) {	                    type = TIME;	                } else if (timeStyle == NONE) {	                    type = DATE;	                }	                StyleFormatter llf = new StyleFormatter(	                        dateStyle, timeStyle, type);	                f = new DateTimeFormatter(llf, llf);	                cStyleCache[index] = f;	            }	        }	        return f;	    }	
/**	     * Gets the JDK style code from the Joda code.	     * 	     * @param ch  the Joda style code	     * @return the JDK style code	     */	    private static int selectStyle(char ch) {	        switch (ch) {	        case 'S':	            return SHORT;	        case 'M':	            return MEDIUM;	        case 'L':	            return LONG;	        case 'F':	            return FULL;	        case '-':	            return NONE;	        default:	            throw new IllegalArgumentException("Invalid style character: " + ch);	        }	    }	
StyleFormatter(int dateStyle, int timeStyle, int type) {	            super();	            iDateStyle = dateStyle;	            iTimeStyle = timeStyle;	            iType = type;	        }	
public int estimatePrintedLength() {	            return 40;  // guess	        }	
public void printTo(	                StringBuffer buf, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) {	            DateTimePrinter p = getFormatter(locale).getPrinter();	            p.printTo(buf, instant, chrono, displayOffset, displayZone, locale);	        }	
public void printTo(	                Writer out, long instant, Chronology chrono,	                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {	            DateTimePrinter p = getFormatter(locale).getPrinter();	            p.printTo(out, instant, chrono, displayOffset, displayZone, locale);	        }	
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {	            DateTimePrinter p = getFormatter(locale).getPrinter();	            p.printTo(buf, partial, locale);	        }	
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {	            DateTimePrinter p = getFormatter(locale).getPrinter();	            p.printTo(out, partial, locale);	        }	
public int estimateParsedLength() {	            return 40;  // guess	        }	
public int parseInto(DateTimeParserBucket bucket, String text, int position) {	            DateTimeParser p = getFormatter(bucket.getLocale()).getParser();	            return p.parseInto(bucket, text, position);	        }	
private DateTimeFormatter getFormatter(Locale locale) {	            locale = (locale == null ? Locale.getDefault() : locale);	            String key = Integer.toString(iType + (iDateStyle << 4) + (iTimeStyle << 8)) + locale.toString();	            DateTimeFormatter f = null;	            synchronized (cCache) {	                f = cCache.get(key);	                if (f == null) {	                    String pattern = getPattern(locale);	                    f = DateTimeFormat.forPattern(pattern);	                    cCache.put(key, f);	                }	            }	            return f;	        }	
String getPattern(Locale locale) {	            DateFormat f = null;	            switch (iType) {	                case DATE:	                    f = DateFormat.getDateInstance(iDateStyle, locale);	                    break;	                case TIME:	                    f = DateFormat.getTimeInstance(iTimeStyle, locale);	                    break;	                case DATETIME:	                    f = DateFormat.getDateTimeInstance(iDateStyle, iTimeStyle, locale);	                    break;	            }	            if (f instanceof SimpleDateFormat == false) {	                throw new IllegalArgumentException("No datetime pattern for locale: " + locale);	            }	            return ((SimpleDateFormat) f).toPattern();	        }	
/**	     * Constructor.	     *	     * @since 1.1 (previously private)	     */	    protected ISODateTimeFormat() {	        super();	    }	
/**	     * Returns a formatter that outputs only those fields specified.	     * <p>	     * This method examines the fields provided and returns an ISO-style	     * formatter that best fits. This can be useful for outputting	     * less-common ISO styles, such as YearMonth (YYYY-MM) or MonthDay (--MM-DD).	     * <p>	     * The list provided may have overlapping fields, such as dayOfWeek and	     * dayOfMonth. In this case, the style is chosen based on the following	     * list, thus in the example, the calendar style is chosen as dayOfMonth	     * is higher in priority than dayOfWeek:	     * <ul>	     * <li>monthOfYear - calendar date style	     * <li>dayOfYear - ordinal date style	     * <li>weekOfWeekYear - week date style	     * <li>dayOfMonth - calendar date style	     * <li>dayOfWeek - week date style	     * <li>year	     * <li>weekyear	     * </ul>	     * The supported formats are:	     * <pre>	     * Extended      Basic       Fields	     * 2005-03-25    20050325    year/monthOfYear/dayOfMonth	     * 2005-03       2005-03     year/monthOfYear	     * 2005--25      2005--25    year/dayOfMonth *	     * 2005          2005        year	     * --03-25       --0325      monthOfYear/dayOfMonth	     * --03          --03        monthOfYear	     * ---03         ---03       dayOfMonth	     * 2005-084      2005084     year/dayOfYear	     * -084          -084        dayOfYear	     * 2005-W12-5    2005W125    weekyear/weekOfWeekyear/dayOfWeek	     * 2005-W-5      2005W-5     weekyear/dayOfWeek *	     * 2005-W12      2005W12     weekyear/weekOfWeekyear	     * -W12-5        -W125       weekOfWeekyear/dayOfWeek	     * -W12          -W12        weekOfWeekyear	     * -W-5          -W-5        dayOfWeek	     * 10:20:30.040  102030.040  hour/minute/second/milli	     * 10:20:30      102030      hour/minute/second	     * 10:20         1020        hour/minute	     * 10            10          hour	     * -20:30.040    -2030.040   minute/second/milli	     * -20:30        -2030       minute/second	     * -20           -20         minute	     * --30.040      --30.040    second/milli	     * --30          --30        second	     * ---.040       ---.040     milli *	     * 10-30.040     10-30.040   hour/second/milli *	     * 10:20-.040    1020-.040   hour/minute/milli *	     * 10-30         10-30       hour/second *	     * 10--.040      10--.040    hour/milli *	     * -20-.040      -20-.040    minute/milli *	     *   plus datetime formats like {date}T{time}	     * </pre>	     * * indiates that this is not an official ISO format and can be excluded	     * by passing in <code>strictISO</code> as <code>true</code>.	     * <p>	     * This method can side effect the input collection of fields.	     * If the input collection is modifiable, then each field that was added to	     * the formatter will be removed from the collection, including any duplicates.	     * If the input collection is unmodifiable then no side effect occurs.	     * <p>	     * This side effect processing is useful if you need to know whether all	     * the fields were converted into the formatter or not. To achieve this,	     * pass in a modifiable list, and check that it is empty on exit.	     *	     * @param fields  the fields to get a formatter for, not null,	     *  updated by the method call unless unmodifiable,	     *  removing those fields built in the formatter	     * @param extended  true to use the extended format (with separators)	     * @param strictISO  true to stick exactly to ISO8601, false to include additional formats	     * @return a suitable formatter	     * @throws IllegalArgumentException if there is no format for the fields	     * @since 1.1	     */	    public static DateTimeFormatter forFields(	        Collection<DateTimeFieldType> fields,	        boolean extended,	        boolean strictISO) {	        	        if (fields == null || fields.size() == 0) {	            throw new IllegalArgumentException("The fields must not be null or empty");	        }	        Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields);	        int inputSize = workingFields.size();	        boolean reducedPrec = false;	        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();	        // date	        if (workingFields.contains(DateTimeFieldType.monthOfYear())) {	            reducedPrec = dateByMonth(bld, workingFields, extended, strictISO);	        } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) {	            reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO);	        } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) {	            reducedPrec = dateByWeek(bld, workingFields, extended, strictISO);	        } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) {	            reducedPrec = dateByMonth(bld, workingFields, extended, strictISO);	        } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) {	            reducedPrec = dateByWeek(bld, workingFields, extended, strictISO);	        } else if (workingFields.remove(DateTimeFieldType.year())) {	            bld.append(yearElement());	            reducedPrec = true;	        } else if (workingFields.remove(DateTimeFieldType.weekyear())) {	            bld.append(weekyearElement());	            reducedPrec = true;	        }	        boolean datePresent = (workingFields.size() < inputSize);	        	        // time	        time(bld, workingFields, extended, strictISO, reducedPrec, datePresent);	        	        // result	        if (bld.canBuildFormatter() == false) {	            throw new IllegalArgumentException("No valid format for fields: " + fields);	        }	        	        // side effect the input collection to indicate the processed fields	        // handling unmodifiable collections with no side effect	        try {	            fields.retainAll(workingFields);	        } catch (UnsupportedOperationException ex) {	            // ignore, so we can handle unmodifiable collections	        }	        return bld.toFormatter();	    }	
/**	     * Creates a date using the calendar date format.	     * Specification reference: 5.2.1.	     *	     * @param bld  the builder	     * @param fields  the fields	     * @param extended  true to use extended format	     * @param strictISO  true to only allow ISO formats	     * @return true if reduced precision	     * @since 1.1	     */	    private static boolean dateByMonth(	        DateTimeFormatterBuilder bld,	        Collection<DateTimeFieldType> fields,	        boolean extended,	        boolean strictISO) {	        	        boolean reducedPrec = false;	        if (fields.remove(DateTimeFieldType.year())) {	            bld.append(yearElement());	            if (fields.remove(DateTimeFieldType.monthOfYear())) {	                if (fields.remove(DateTimeFieldType.dayOfMonth())) {	                    // YYYY-MM-DD/YYYYMMDD	                    appendSeparator(bld, extended);	                    bld.appendMonthOfYear(2);	                    appendSeparator(bld, extended);	                    bld.appendDayOfMonth(2);	                } else {	                    // YYYY-MM/YYYY-MM	                    bld.appendLiteral('-');	                    bld.appendMonthOfYear(2);	                    reducedPrec = true;	                }	            } else {	                if (fields.remove(DateTimeFieldType.dayOfMonth())) {	                    // YYYY--DD/YYYY--DD (non-iso)	                    checkNotStrictISO(fields, strictISO);	                    bld.appendLiteral('-');	                    bld.appendLiteral('-');	                    bld.appendDayOfMonth(2);	                } else {	                    // YYYY/YYYY	                    reducedPrec = true;	                }	            }	            	        } else if (fields.remove(DateTimeFieldType.monthOfYear())) {	            bld.appendLiteral('-');	            bld.appendLiteral('-');	            bld.appendMonthOfYear(2);	            if (fields.remove(DateTimeFieldType.dayOfMonth())) {	                // --MM-DD/--MMDD	                appendSeparator(bld, extended);	                bld.appendDayOfMonth(2);	            } else {	                // --MM/--MM	                reducedPrec = true;	            }	        } else if (fields.remove(DateTimeFieldType.dayOfMonth())) {	            // ---DD/---DD	            bld.appendLiteral('-');	            bld.appendLiteral('-');	            bld.appendLiteral('-');	            bld.appendDayOfMonth(2);	        }	        return reducedPrec;	    }	
/**	     * Creates a date using the ordinal date format.	     * Specification reference: 5.2.2.	     *	     * @param bld  the builder	     * @param fields  the fields	     * @param extended  true to use extended format	     * @param strictISO  true to only allow ISO formats	     * @since 1.1	     */	    private static boolean dateByOrdinal(	        DateTimeFormatterBuilder bld,	        Collection<DateTimeFieldType> fields,	        boolean extended,	        boolean strictISO) {	        	        boolean reducedPrec = false;	        if (fields.remove(DateTimeFieldType.year())) {	            bld.append(yearElement());	            if (fields.remove(DateTimeFieldType.dayOfYear())) {	                // YYYY-DDD/YYYYDDD	                appendSeparator(bld, extended);	                bld.appendDayOfYear(3);	            } else {	                // YYYY/YYYY	                reducedPrec = true;	            }	            	        } else if (fields.remove(DateTimeFieldType.dayOfYear())) {	            // -DDD/-DDD	            bld.appendLiteral('-');	            bld.appendDayOfYear(3);	        }	        return reducedPrec;	    }	
/**	     * Creates a date using the calendar date format.	     * Specification reference: 5.2.3.	     *	     * @param bld  the builder	     * @param fields  the fields	     * @param extended  true to use extended format	     * @param strictISO  true to only allow ISO formats	     * @since 1.1	     */	    private static boolean dateByWeek(	        DateTimeFormatterBuilder bld,	        Collection<DateTimeFieldType> fields,	        boolean extended,	        boolean strictISO) {	        	        boolean reducedPrec = false;	        if (fields.remove(DateTimeFieldType.weekyear())) {	            bld.append(weekyearElement());	            if (fields.remove(DateTimeFieldType.weekOfWeekyear())) {	                appendSeparator(bld, extended);	                bld.appendLiteral('W');	                bld.appendWeekOfWeekyear(2);	                if (fields.remove(DateTimeFieldType.dayOfWeek())) {	                    // YYYY-WWW-D/YYYYWWWD	                    appendSeparator(bld, extended);	                    bld.appendDayOfWeek(1);	                } else {	                    // YYYY-WWW/YYYY-WWW	                    reducedPrec = true;	                }	            } else {	                if (fields.remove(DateTimeFieldType.dayOfWeek())) {	                    // YYYY-W-D/YYYYW-D (non-iso)	                    checkNotStrictISO(fields, strictISO);	                    appendSeparator(bld, extended);	                    bld.appendLiteral('W');	                    bld.appendLiteral('-');	                    bld.appendDayOfWeek(1);	                } else {	                    // YYYY/YYYY	                    reducedPrec = true;	                }	            }	            	        } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) {	            bld.appendLiteral('-');	            bld.appendLiteral('W');	            bld.appendWeekOfWeekyear(2);	            if (fields.remove(DateTimeFieldType.dayOfWeek())) {	                // -WWW-D/-WWWD	                appendSeparator(bld, extended);	                bld.appendDayOfWeek(1);	            } else {	                // -WWW/-WWW	                reducedPrec = true;	            }	        } else if (fields.remove(DateTimeFieldType.dayOfWeek())) {	            // -W-D/-W-D	            bld.appendLiteral('-');	            bld.appendLiteral('W');	            bld.appendLiteral('-');	            bld.appendDayOfWeek(1);	        }	        return reducedPrec;	    }	
/**	     * Adds the time fields to the builder.	     * Specification reference: 5.3.1.	     * 	     * @param bld  the builder	     * @param fields  the fields	     * @param extended  whether to use the extended format	     * @param strictISO  whether to be strict	     * @param reducedPrec  whether the date was reduced precision	     * @param datePresent  whether there was a date	     * @since 1.1	     */	    private static void time(	        DateTimeFormatterBuilder bld,	        Collection<DateTimeFieldType> fields,	        boolean extended,	        boolean strictISO,	        boolean reducedPrec,	        boolean datePresent) {	        	        boolean hour = fields.remove(DateTimeFieldType.hourOfDay());	        boolean minute = fields.remove(DateTimeFieldType.minuteOfHour());	        boolean second = fields.remove(DateTimeFieldType.secondOfMinute());	        boolean milli = fields.remove(DateTimeFieldType.millisOfSecond());	        if (!hour && !minute && !second && !milli) {	            return;	        }	        if (hour || minute || second || milli) {	            if (strictISO && reducedPrec) {	                throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields);	            }	            if (datePresent) {	                bld.appendLiteral('T');	            }	        }	        if (hour && minute && second || (hour && !second && !milli)) {	            // OK - HMSm/HMS/HM/H - valid in combination with date	        } else {	            if (strictISO && datePresent) {	                throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields);	            }	            if (!hour && (minute && second || (minute && !milli) || second)) {	                // OK - MSm/MS/M/Sm/S - valid ISO formats	            } else {	                if (strictISO) {	                    throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields);	                }	            }	        }	        if (hour) {	            bld.appendHourOfDay(2);	        } else if (minute || second || milli) {	            bld.appendLiteral('-');	        }	        if (extended && hour && minute) {	            bld.appendLiteral(':');	        }	        if (minute) {	            bld.appendMinuteOfHour(2);	        } else if (second || milli) {	            bld.appendLiteral('-');	        }	        if (extended && minute && second) {	            bld.appendLiteral(':');	        }	        if (second) {	            bld.appendSecondOfMinute(2);	        } else if (milli) {	            bld.appendLiteral('-');	        }	        if (milli) {	            bld.appendLiteral('.');	            bld.appendMillisOfSecond(3);	        }	    }	
/**	     * Checks that the iso only flag is not set, throwing an exception if it is.	     * 	     * @param fields  the fields	     * @param strictISO  true if only ISO formats allowed	     * @since 1.1	     */	    private static void checkNotStrictISO(Collection<DateTimeFieldType> fields, boolean strictISO) {	        if (strictISO) {	            throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields);	        }	    }	
/**	     * Appends the separator if necessary.	     *	     * @param bld  the builder	     * @param extended  whether to append the separator	     * @param sep  the separator	     * @since 1.1	     */	    private static void appendSeparator(DateTimeFormatterBuilder bld, boolean extended) {	        if (extended) {	            bld.appendLiteral('-');	        }	    }	
/**	     * Returns a generic ISO date parser for parsing dates with a possible zone.	     * It accepts formats described by the following syntax:	     * <pre>	     * date              = date-element ['T' offset]	     * date-element      = std-date-element | ord-date-element | week-date-element	     * std-date-element  = yyyy ['-' MM ['-' dd]]	     * ord-date-element  = yyyy ['-' DDD]	     * week-date-element = xxxx '-W' ww ['-' e]	     * offset            = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])	     * </pre>	     */	    public static DateTimeFormatter dateParser() {	        if (dp == null) {	            DateTimeParser tOffset = new DateTimeFormatterBuilder()	                .appendLiteral('T')	                .append(offsetElement()).toParser();	            dp = new DateTimeFormatterBuilder()	                .append(dateElementParser())	                .appendOptional(tOffset)	                .toFormatter();	        }	        return dp;	    }	
/**	     * Returns a generic ISO date parser for parsing local dates.	     * This parser is initialised with the local (UTC) time zone.	     * <p>	     * It accepts formats described by the following syntax:	     * <pre>	     * date-element      = std-date-element | ord-date-element | week-date-element	     * std-date-element  = yyyy ['-' MM ['-' dd]]	     * ord-date-element  = yyyy ['-' DDD]	     * week-date-element = xxxx '-W' ww ['-' e]	     * </pre>	     * @since 1.3	     */	    public static DateTimeFormatter localDateParser() {	        if (ldp == null) {	            ldp = dateElementParser().withZoneUTC();	        }	        return ldp;	    }	
/**	     * Returns a generic ISO date parser for parsing dates.	     * It accepts formats described by the following syntax:	     * <pre>	     * date-element      = std-date-element | ord-date-element | week-date-element	     * std-date-element  = yyyy ['-' MM ['-' dd]]	     * ord-date-element  = yyyy ['-' DDD]	     * week-date-element = xxxx '-W' ww ['-' e]	     * </pre>	     */	    public static DateTimeFormatter dateElementParser() {	        if (dpe == null) {	            dpe = new DateTimeFormatterBuilder()	                .append(null, new DateTimeParser[] {	                    new DateTimeFormatterBuilder()	                    .append(yearElement())	                    .appendOptional	                    (new DateTimeFormatterBuilder()	                     .append(monthElement())	                     .appendOptional(dayOfMonthElement().getParser())	                     .toParser())	                    .toParser(),	                    new DateTimeFormatterBuilder()	                    .append(weekyearElement())	                    .append(weekElement())	                    .appendOptional(dayOfWeekElement().getParser())	                    .toParser(),	                    new DateTimeFormatterBuilder()	                    .append(yearElement())	                    .append(dayOfYearElement())	                    .toParser()	                })	                .toFormatter();	        }	        return dpe;	    }	
/**	     * Returns a generic ISO time parser for parsing times with a possible zone.	     * It accepts formats described by the following syntax:	     * <pre>	     * time           = ['T'] time-element [offset]	     * time-element   = HH [minute-element] | [fraction]	     * minute-element = ':' mm [second-element] | [fraction]	     * second-element = ':' ss [fraction]	     * fraction       = ('.' | ',') digit+	     * offset         = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])	     * </pre>	     */	    public static DateTimeFormatter timeParser() {	        if (tp == null) {	            tp = new DateTimeFormatterBuilder()	                .appendOptional(literalTElement().getParser())	                .append(timeElementParser())	                .appendOptional(offsetElement().getParser())	                .toFormatter();	        }	        return tp;	    }	
/**	     * Returns a generic ISO time parser for parsing local times.	     * This parser is initialised with the local (UTC) time zone.	     * <p>	     * It accepts formats described by the following syntax:	     * <pre>	     * time           = ['T'] time-element	     * time-element   = HH [minute-element] | [fraction]	     * minute-element = ':' mm [second-element] | [fraction]	     * second-element = ':' ss [fraction]	     * fraction       = ('.' | ',') digit+	     * </pre>	     * @since 1.3	     */	    public static DateTimeFormatter localTimeParser() {	        if (ltp == null) {	            ltp = new DateTimeFormatterBuilder()	                .appendOptional(literalTElement().getParser())	                .append(timeElementParser())	                .toFormatter().withZoneUTC();	        }	        return ltp;	    }	
/**	     * Returns a generic ISO time parser. It accepts formats described by	     * the following syntax:	     * <pre>	     * time-element   = HH [minute-element] | [fraction]	     * minute-element = ':' mm [second-element] | [fraction]	     * second-element = ':' ss [fraction]	     * fraction       = ('.' | ',') digit+	     * </pre>	     */	    public static DateTimeFormatter timeElementParser() {	        if (tpe == null) {	            // Decimal point can be either '.' or ','	            DateTimeParser decimalPoint = new DateTimeFormatterBuilder()	                .append(null, new DateTimeParser[] {	                    new DateTimeFormatterBuilder()	                    .appendLiteral('.')	                    .toParser(),	                    new DateTimeFormatterBuilder()	                    .appendLiteral(',')	                    .toParser()	                })	                .toParser();		            tpe = new DateTimeFormatterBuilder()	                // time-element	                .append(hourElement())	                .append	                (null, new DateTimeParser[] {	                    new DateTimeFormatterBuilder()	                    // minute-element	                    .append(minuteElement())	                    .append	                    (null, new DateTimeParser[] {	                        new DateTimeFormatterBuilder()	                        // second-element	                        .append(secondElement())	                        // second fraction	                        .appendOptional(new DateTimeFormatterBuilder()	                                        .append(decimalPoint)	                                        .appendFractionOfSecond(1, 9)	                                        .toParser())	                        .toParser(),	                        // minute fraction	                        new DateTimeFormatterBuilder()	                        .append(decimalPoint)	                        .appendFractionOfMinute(1, 9)	                        .toParser(),	                        null	                    })	                    .toParser(),	                    // hour fraction	                    new DateTimeFormatterBuilder()	                    .append(decimalPoint)	                    .appendFractionOfHour(1, 9)	                    .toParser(),	                    null	                })	                .toFormatter();	        }	        return tpe;	    }	
/**	     * Returns a generic ISO datetime parser which parses either a date or	     * a time or both. It accepts formats described by the following syntax:	     * <pre>	     * datetime          = time | date-opt-time	     * time              = 'T' time-element [offset]	     * date-opt-time     = date-element ['T' [time-element] [offset]]	     * date-element      = std-date-element | ord-date-element | week-date-element	     * std-date-element  = yyyy ['-' MM ['-' dd]]	     * ord-date-element  = yyyy ['-' DDD]	     * week-date-element = xxxx '-W' ww ['-' e]	     * time-element      = HH [minute-element] | [fraction]	     * minute-element    = ':' mm [second-element] | [fraction]	     * second-element    = ':' ss [fraction]	     * fraction          = ('.' | ',') digit+	     * offset            = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])	     * </pre>	     */	    public static DateTimeFormatter dateTimeParser() {	        if (dtp == null) {	            // This is different from the general time parser in that the 'T'	            // is required.	            DateTimeParser time = new DateTimeFormatterBuilder()	                .appendLiteral('T')	                .append(timeElementParser())	                .appendOptional(offsetElement().getParser())	                .toParser();	            dtp = new DateTimeFormatterBuilder()	                .append(null, new DateTimeParser[] {time, dateOptionalTimeParser().getParser()})	                .toFormatter();	        }	        return dtp;	    }	
/**	     * Returns a generic ISO datetime parser where the date is mandatory and	     * the time is optional. This parser can parse zoned datetimes.	     * It accepts formats described by the following syntax:	     * <pre>	     * date-opt-time     = date-element ['T' [time-element] [offset]]	     * date-element      = std-date-element | ord-date-element | week-date-element	     * std-date-element  = yyyy ['-' MM ['-' dd]]	     * ord-date-element  = yyyy ['-' DDD]	     * week-date-element = xxxx '-W' ww ['-' e]	     * time-element      = HH [minute-element] | [fraction]	     * minute-element    = ':' mm [second-element] | [fraction]	     * second-element    = ':' ss [fraction]	     * fraction          = ('.' | ',') digit+	     * </pre>	     * @since 1.3	     */	    public static DateTimeFormatter dateOptionalTimeParser() {	        if (dotp == null) {	            DateTimeParser timeOrOffset = new DateTimeFormatterBuilder()	                .appendLiteral('T')	                .appendOptional(timeElementParser().getParser())	                .appendOptional(offsetElement().getParser())	                .toParser();	            dotp = new DateTimeFormatterBuilder()	                .append(dateElementParser())	                .appendOptional(timeOrOffset)	                .toFormatter();	        }	        return dotp;	    }	
/**	     * Returns a generic ISO datetime parser where the date is mandatory and	     * the time is optional. This parser only parses local datetimes.	     * This parser is initialised with the local (UTC) time zone.	     * <p>	     * It accepts formats described by the following syntax:	     * <pre>	     * datetime          = date-element ['T' time-element]	     * date-element      = std-date-element | ord-date-element | week-date-element	     * std-date-element  = yyyy ['-' MM ['-' dd]]	     * ord-date-element  = yyyy ['-' DDD]	     * week-date-element = xxxx '-W' ww ['-' e]	     * time-element      = HH [minute-element] | [fraction]	     * minute-element    = ':' mm [second-element] | [fraction]	     * second-element    = ':' ss [fraction]	     * fraction          = ('.' | ',') digit+	     * </pre>	     * @since 1.3	     */	    public static DateTimeFormatter localDateOptionalTimeParser() {	        if (ldotp == null) {	            DateTimeParser time = new DateTimeFormatterBuilder()	                .appendLiteral('T')	                .append(timeElementParser())	                .toParser();	            ldotp = new DateTimeFormatterBuilder()	                .append(dateElementParser())	                .appendOptional(time)	                .toFormatter().withZoneUTC();	        }	        return ldotp;	    }	
/**	     * Returns a formatter for a full date as four digit year, two digit month	     * of year, and two digit day of month (yyyy-MM-dd).	     * 	     * @return a formatter for yyyy-MM-dd	     */	    public static DateTimeFormatter date() {	        return yearMonthDay();	    }	
/**	     * Returns a formatter for a two digit hour of day, two digit minute of	     * hour, two digit second of minute, three digit fraction of second, and	     * time zone offset (HH:mm:ss.SSSZZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.	     * 	     * @return a formatter for HH:mm:ss.SSSZZ	     */	    public static DateTimeFormatter time() {	        if (t == null) {	            t = new DateTimeFormatterBuilder()	                .append(hourMinuteSecondFraction())	                .append(offsetElement())	                .toFormatter();	        }	        return t;	    }	
/**	     * Returns a formatter for a two digit hour of day, two digit minute of	     * hour, two digit second of minute, and time zone offset (HH:mm:ssZZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.	     * 	     * @return a formatter for HH:mm:ssZZ	     */	    public static DateTimeFormatter timeNoMillis() {	        if (tx == null) {	            tx = new DateTimeFormatterBuilder()	                .append(hourMinuteSecond())	                .append(offsetElement())	                .toFormatter();	        }	        return tx;	    }	
/**	     * Returns a formatter for a two digit hour of day, two digit minute of	     * hour, two digit second of minute, three digit fraction of second, and	     * time zone offset prefixed by 'T' ('T'HH:mm:ss.SSSZZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.	     * 	     * @return a formatter for 'T'HH:mm:ss.SSSZZ	     */	    public static DateTimeFormatter tTime() {	        if (tt == null) {	            tt = new DateTimeFormatterBuilder()	                .append(literalTElement())	                .append(time())	                .toFormatter();	        }	        return tt;	    }	
/**	     * Returns a formatter for a two digit hour of day, two digit minute of	     * hour, two digit second of minute, and time zone offset prefixed	     * by 'T' ('T'HH:mm:ssZZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.	     * 	     * @return a formatter for 'T'HH:mm:ssZZ	     */	    public static DateTimeFormatter tTimeNoMillis() {	        if (ttx == null) {	            ttx = new DateTimeFormatterBuilder()	                .append(literalTElement())	                .append(timeNoMillis())	                .toFormatter();	        }	        return ttx;	    }	
/**	     * Returns a formatter that combines a full date and time, separated by a 'T'	     * (yyyy-MM-dd'T'HH:mm:ss.SSSZZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.	     * 	     * @return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSSZZ	     */	    public static DateTimeFormatter dateTime() {	        if (dt == null) {	            dt = new DateTimeFormatterBuilder()	                .append(date())	                .append(tTime())	                .toFormatter();	        }	        return dt;	    }	
/**	     * Returns a formatter that combines a full date and time without millis,	     * separated by a 'T' (yyyy-MM-dd'T'HH:mm:ssZZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.	     * 	     * @return a formatter for yyyy-MM-dd'T'HH:mm:ssZZ	     */	    public static DateTimeFormatter dateTimeNoMillis() {	        if (dtx == null) {	            dtx = new DateTimeFormatterBuilder()	                .append(date())	                .append(tTimeNoMillis())	                .toFormatter();	        }	        return dtx;	    }	
/**	     * Returns a formatter for a full ordinal date, using a four	     * digit year and three digit dayOfYear (yyyy-DDD).	     * 	     * @return a formatter for yyyy-DDD	     * @since 1.1	     */	    public static DateTimeFormatter ordinalDate() {	        if (od == null) {	            od = new DateTimeFormatterBuilder()	                .append(yearElement())	                .append(dayOfYearElement())	                .toFormatter();	        }	        return od;	    }	
/**	     * Returns a formatter for a full ordinal date and time, using a four	     * digit year and three digit dayOfYear (yyyy-DDD'T'HH:mm:ss.SSSZZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.	     * 	     * @return a formatter for yyyy-DDD'T'HH:mm:ss.SSSZZ	     * @since 1.1	     */	    public static DateTimeFormatter ordinalDateTime() {	        if (odt == null) {	            odt = new DateTimeFormatterBuilder()	                .append(ordinalDate())	                .append(tTime())	                .toFormatter();	        }	        return odt;	    }	
/**	     * Returns a formatter for a full ordinal date and time without millis,	     * using a four digit year and three digit dayOfYear (yyyy-DDD'T'HH:mm:ssZZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.	     * 	     * @return a formatter for yyyy-DDD'T'HH:mm:ssZZ	     * @since 1.1	     */	    public static DateTimeFormatter ordinalDateTimeNoMillis() {	        if (odtx == null) {	            odtx = new DateTimeFormatterBuilder()	                .append(ordinalDate())	                .append(tTimeNoMillis())	                .toFormatter();	        }	        return odtx;	    }	
/**	     * Returns a formatter for a full date as four digit weekyear, two digit	     * week of weekyear, and one digit day of week (xxxx-'W'ww-e).	     * 	     * @return a formatter for xxxx-'W'ww-e	     */	    public static DateTimeFormatter weekDate() {	        return weekyearWeekDay();	    }	
/**	     * Returns a formatter that combines a full weekyear date and time,	     * separated by a 'T' (xxxx-'W'ww-e'T'HH:mm:ss.SSSZZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.	     * 	     * @return a formatter for xxxx-'W'ww-e'T'HH:mm:ss.SSSZZ	     */	    public static DateTimeFormatter weekDateTime() {	        if (wdt == null) {	            wdt = new DateTimeFormatterBuilder()	                .append(weekDate())	                .append(tTime())	                .toFormatter();	        }	        return wdt;	    }	
/**	     * Returns a formatter that combines a full weekyear date and time without millis,	     * separated by a 'T' (xxxx-'W'ww-e'T'HH:mm:ssZZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.	     * 	     * @return a formatter for xxxx-'W'ww-e'T'HH:mm:ssZZ	     */	    public static DateTimeFormatter weekDateTimeNoMillis() {	        if (wdtx == null) {	            wdtx = new DateTimeFormatterBuilder()	                .append(weekDate())	                .append(tTimeNoMillis())	                .toFormatter();	        }	        return wdtx;	    }	
/**	     * Returns a basic formatter for a full date as four digit year, two digit	     * month of year, and two digit day of month (yyyyMMdd).	     * 	     * @return a formatter for yyyyMMdd	     */	    public static DateTimeFormatter basicDate() {	        if (bd == null) {	            bd = new DateTimeFormatterBuilder()	                .appendYear(4, 4)	                .appendFixedDecimal(DateTimeFieldType.monthOfYear(), 2)	                .appendFixedDecimal(DateTimeFieldType.dayOfMonth(), 2)	                .toFormatter();	        }	        return bd;	    }	
/**	     * Returns a basic formatter for a two digit hour of day, two digit minute	     * of hour, two digit second of minute, three digit millis, and time zone	     * offset (HHmmss.SSSZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.	     * 	     * @return a formatter for HHmmss.SSSZ	     */	    public static DateTimeFormatter basicTime() {	        if (bt == null) {	            bt = new DateTimeFormatterBuilder()	                .appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2)	                .appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2)	                .appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2)	                .appendLiteral('.')	                .appendFractionOfSecond(3, 9)	                .appendTimeZoneOffset("Z", false, 2, 2)	                .toFormatter();	        }	        return bt;	    }	
/**	     * Returns a basic formatter for a two digit hour of day, two digit minute	     * of hour, two digit second of minute, and time zone offset (HHmmssZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.	     * 	     * @return a formatter for HHmmssZ	     */	    public static DateTimeFormatter basicTimeNoMillis() {	        if (btx == null) {	            btx = new DateTimeFormatterBuilder()	                .appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2)	                .appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2)	                .appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2)	                .appendTimeZoneOffset("Z", false, 2, 2)	                .toFormatter();	        }	        return btx;	    }	
/**	     * Returns a basic formatter for a two digit hour of day, two digit minute	     * of hour, two digit second of minute, three digit millis, and time zone	     * offset prefixed by 'T' ('T'HHmmss.SSSZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.	     * 	     * @return a formatter for 'T'HHmmss.SSSZ	     */	    public static DateTimeFormatter basicTTime() {	        if (btt == null) {	            btt = new DateTimeFormatterBuilder()	                .append(literalTElement())	                .append(basicTime())	                .toFormatter();	        }	        return btt;	    }	
/**	     * Returns a basic formatter for a two digit hour of day, two digit minute	     * of hour, two digit second of minute, and time zone offset prefixed by 'T'	     * ('T'HHmmssZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.	     * 	     * @return a formatter for 'T'HHmmssZ	     */	    public static DateTimeFormatter basicTTimeNoMillis() {	        if (bttx == null) {	            bttx = new DateTimeFormatterBuilder()	                .append(literalTElement())	                .append(basicTimeNoMillis())	                .toFormatter();	        }	        return bttx;	    }	
/**	     * Returns a basic formatter that combines a basic date and time, separated	     * by a 'T' (yyyyMMdd'T'HHmmss.SSSZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.	     * 	     * @return a formatter for yyyyMMdd'T'HHmmss.SSSZ	     */	    public static DateTimeFormatter basicDateTime() {	        if (bdt == null) {	            bdt = new DateTimeFormatterBuilder()	                .append(basicDate())	                .append(basicTTime())	                .toFormatter();	        }	        return bdt;	    }	
/**	     * Returns a basic formatter that combines a basic date and time without millis,	     * separated by a 'T' (yyyyMMdd'T'HHmmssZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.	     * 	     * @return a formatter for yyyyMMdd'T'HHmmssZ	     */	    public static DateTimeFormatter basicDateTimeNoMillis() {	        if (bdtx == null) {	            bdtx = new DateTimeFormatterBuilder()	                .append(basicDate())	                .append(basicTTimeNoMillis())	                .toFormatter();	        }	        return bdtx;	    }	
/**	     * Returns a formatter for a full ordinal date, using a four	     * digit year and three digit dayOfYear (yyyyDDD).	     * 	     * @return a formatter for yyyyDDD	     * @since 1.1	     */	    public static DateTimeFormatter basicOrdinalDate() {	        if (bod == null) {	            bod = new DateTimeFormatterBuilder()	                .appendYear(4, 4)	                .appendFixedDecimal(DateTimeFieldType.dayOfYear(), 3)	                .toFormatter();	        }	        return bod;	    }	
/**	     * Returns a formatter for a full ordinal date and time, using a four	     * digit year and three digit dayOfYear (yyyyDDD'T'HHmmss.SSSZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.	     * 	     * @return a formatter for yyyyDDD'T'HHmmss.SSSZ	     * @since 1.1	     */	    public static DateTimeFormatter basicOrdinalDateTime() {	        if (bodt == null) {	            bodt = new DateTimeFormatterBuilder()	                .append(basicOrdinalDate())	                .append(basicTTime())	                .toFormatter();	        }	        return bodt;	    }	
/**	     * Returns a formatter for a full ordinal date and time without millis,	     * using a four digit year and three digit dayOfYear (yyyyDDD'T'HHmmssZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.	     * 	     * @return a formatter for yyyyDDD'T'HHmmssZ	     * @since 1.1	     */	    public static DateTimeFormatter basicOrdinalDateTimeNoMillis() {	        if (bodtx == null) {	            bodtx = new DateTimeFormatterBuilder()	                .append(basicOrdinalDate())	                .append(basicTTimeNoMillis())	                .toFormatter();	        }	        return bodtx;	    }	
/**	     * Returns a basic formatter for a full date as four digit weekyear, two	     * digit week of weekyear, and one digit day of week (xxxx'W'wwe).	     * 	     * @return a formatter for xxxx'W'wwe	     */	    public static DateTimeFormatter basicWeekDate() {	        if (bwd == null) {	            bwd = new DateTimeFormatterBuilder()	                .appendWeekyear(4, 4)	                .appendLiteral('W')	                .appendFixedDecimal(DateTimeFieldType.weekOfWeekyear(), 2)	                .appendFixedDecimal(DateTimeFieldType.dayOfWeek(), 1)	                .toFormatter();	        }	        return bwd;	    }	
/**	     * Returns a basic formatter that combines a basic weekyear date and time,	     * separated by a 'T' (xxxx'W'wwe'T'HHmmss.SSSZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.	     * 	     * @return a formatter for xxxx'W'wwe'T'HHmmss.SSSZ	     */	    public static DateTimeFormatter basicWeekDateTime() {	        if (bwdt == null) {	            bwdt = new DateTimeFormatterBuilder()	                .append(basicWeekDate())	                .append(basicTTime())	                .toFormatter();	        }	        return bwdt;	    }	
/**	     * Returns a basic formatter that combines a basic weekyear date and time	     * without millis, separated by a 'T' (xxxx'W'wwe'T'HHmmssZ).	     * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.	     * 	     * @return a formatter for xxxx'W'wwe'T'HHmmssZ	     */	    public static DateTimeFormatter basicWeekDateTimeNoMillis() {	        if (bwdtx == null) {	            bwdtx = new DateTimeFormatterBuilder()	                .append(basicWeekDate())	                .append(basicTTimeNoMillis())	                .toFormatter();	        }	        return bwdtx;	    }	
/**	     * Returns a formatter for a four digit year. (yyyy)	     * 	     * @return a formatter for yyyy	     */	    public static DateTimeFormatter year() {	        return yearElement();	    }	
/**	     * Returns a formatter for a four digit year and two digit month of	     * year. (yyyy-MM)	     * 	     * @return a formatter for yyyy-MM	     */	    public static DateTimeFormatter yearMonth() {	        if (ym == null) {	            ym = new DateTimeFormatterBuilder()	                .append(yearElement())	                .append(monthElement())	                .toFormatter();	        }	        return ym;	    }	
/**	     * Returns a formatter for a four digit year, two digit month of year, and	     * two digit day of month. (yyyy-MM-dd)	     * 	     * @return a formatter for yyyy-MM-dd	     */	    public static DateTimeFormatter yearMonthDay() {	        if (ymd == null) {	            ymd = new DateTimeFormatterBuilder()	                .append(yearElement())	                .append(monthElement())	                .append(dayOfMonthElement())	                .toFormatter();	        }	        return ymd;	    }	
/**	     * Returns a formatter for a four digit weekyear. (xxxx)	     * 	     * @return a formatter for xxxx	     */	    public static DateTimeFormatter weekyear() {	        return weekyearElement();	    }	
/**	     * Returns a formatter for a four digit weekyear and two digit week of	     * weekyear. (xxxx-'W'ww)	     * 	     * @return a formatter for xxxx-'W'ww	     */	    public static DateTimeFormatter weekyearWeek() {	        if (ww == null) {	            ww = new DateTimeFormatterBuilder()	                .append(weekyearElement())	                .append(weekElement())	                .toFormatter();	        }	        return ww;	    }	
/**	     * Returns a formatter for a four digit weekyear, two digit week of	     * weekyear, and one digit day of week. (xxxx-'W'ww-e)	     * 	     * @return a formatter for xxxx-'W'ww-e	     */	    public static DateTimeFormatter weekyearWeekDay() {	        if (wwd == null) {	            wwd = new DateTimeFormatterBuilder()	                .append(weekyearElement())	                .append(weekElement())	                .append(dayOfWeekElement())	                .toFormatter();	        }	        return wwd;	    }	
/**	     * Returns a formatter for a two digit hour of day. (HH)	     * 	     * @return a formatter for HH	     */	    public static DateTimeFormatter hour() {	        return hourElement();	    }	
/**	     * Returns a formatter for a two digit hour of day and two digit minute of	     * hour. (HH:mm)	     * 	     * @return a formatter for HH:mm	     */	    public static DateTimeFormatter hourMinute() {	        if (hm == null) {	            hm = new DateTimeFormatterBuilder()	                .append(hourElement())	                .append(minuteElement())	                .toFormatter();	        }	        return hm;	    }	
/**	     * Returns a formatter for a two digit hour of day, two digit minute of	     * hour, and two digit second of minute. (HH:mm:ss)	     * 	     * @return a formatter for HH:mm:ss	     */	    public static DateTimeFormatter hourMinuteSecond() {	        if (hms == null) {	            hms = new DateTimeFormatterBuilder()	                .append(hourElement())	                .append(minuteElement())	                .append(secondElement())	                .toFormatter();	        }	        return hms;	    }	
/**	     * Returns a formatter for a two digit hour of day, two digit minute of	     * hour, two digit second of minute, and three digit fraction of	     * second (HH:mm:ss.SSS). Parsing will parse up to 3 fractional second	     * digits.	     * 	     * @return a formatter for HH:mm:ss.SSS	     */	    public static DateTimeFormatter hourMinuteSecondMillis() {	        if (hmsl == null) {	            hmsl = new DateTimeFormatterBuilder()	                .append(hourElement())	                .append(minuteElement())	                .append(secondElement())	                .appendLiteral('.')	                .appendFractionOfSecond(3, 3)	                .toFormatter();	        }	        return hmsl;	    }	
/**	     * Returns a formatter for a two digit hour of day, two digit minute of	     * hour, two digit second of minute, and three digit fraction of	     * second (HH:mm:ss.SSS). Parsing will parse up to 9 fractional second	     * digits, throwing away all except the first three.	     * 	     * @return a formatter for HH:mm:ss.SSS	     */	    public static DateTimeFormatter hourMinuteSecondFraction() {	        if (hmsf == null) {	            hmsf = new DateTimeFormatterBuilder()	                .append(hourElement())	                .append(minuteElement())	                .append(secondElement())	                .append(fractionElement())	                .toFormatter();	        }	        return hmsf;	    }	
/**	     * Returns a formatter that combines a full date and two digit hour of	     * day. (yyyy-MM-dd'T'HH)	     * 	     * @return a formatter for yyyy-MM-dd'T'HH	     */	    public static DateTimeFormatter dateHour() {	        if (dh == null) {	            dh = new DateTimeFormatterBuilder()	                .append(date())	                .append(literalTElement())	                .append(hour())	                .toFormatter();	        }	        return dh;	    }	
/**	     * Returns a formatter that combines a full date, two digit hour of day,	     * and two digit minute of hour. (yyyy-MM-dd'T'HH:mm)	     * 	     * @return a formatter for yyyy-MM-dd'T'HH:mm	     */	    public static DateTimeFormatter dateHourMinute() {	        if (dhm == null) {	            dhm = new DateTimeFormatterBuilder()	                .append(date())	                .append(literalTElement())	                .append(hourMinute())	                .toFormatter();	        }	        return dhm;	    }	
/**	     * Returns a formatter that combines a full date, two digit hour of day,	     * two digit minute of hour, and two digit second of	     * minute. (yyyy-MM-dd'T'HH:mm:ss)	     * 	     * @return a formatter for yyyy-MM-dd'T'HH:mm:ss	     */	    public static DateTimeFormatter dateHourMinuteSecond() {	        if (dhms == null) {	            dhms = new DateTimeFormatterBuilder()	                .append(date())	                .append(literalTElement())	                .append(hourMinuteSecond())	                .toFormatter();	        }	        return dhms;	    }	
/**	     * Returns a formatter that combines a full date, two digit hour of day,	     * two digit minute of hour, two digit second of minute, and three digit	     * fraction of second (yyyy-MM-dd'T'HH:mm:ss.SSS). Parsing will parse up	     * to 3 fractional second digits.	     * 	     * @return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSS	     */	    public static DateTimeFormatter dateHourMinuteSecondMillis() {	        if (dhmsl == null) {	            dhmsl = new DateTimeFormatterBuilder()	                .append(date())	                .append(literalTElement())	                .append(hourMinuteSecondMillis())	                .toFormatter();	        }	        return dhmsl;	    }	
/**	     * Returns a formatter that combines a full date, two digit hour of day,	     * two digit minute of hour, two digit second of minute, and three digit	     * fraction of second (yyyy-MM-dd'T'HH:mm:ss.SSS). Parsing will parse up	     * to 9 fractional second digits, throwing away all except the first three.	     * 	     * @return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSS	     */	    public static DateTimeFormatter dateHourMinuteSecondFraction() {	        if (dhmsf == null) {	            dhmsf = new DateTimeFormatterBuilder()	                .append(date())	                .append(literalTElement())	                .append(hourMinuteSecondFraction())	                .toFormatter();	        }	        return dhmsf;	    }	
private static DateTimeFormatter yearElement() {	        if (ye == null) {	            ye = new DateTimeFormatterBuilder()	                .appendYear(4, 9)	                .toFormatter();	        }	        return ye;	    }	
private static DateTimeFormatter monthElement() {	        if (mye == null) {	            mye = new DateTimeFormatterBuilder()	                .appendLiteral('-')	                .appendMonthOfYear(2)	                .toFormatter();	        }	        return mye;	    }	
private static DateTimeFormatter dayOfMonthElement() {	        if (dme == null) {	            dme = new DateTimeFormatterBuilder()	                .appendLiteral('-')	                .appendDayOfMonth(2)	                .toFormatter();	        }	        return dme;	    }	
private static DateTimeFormatter weekyearElement() {	        if (we == null) {	            we = new DateTimeFormatterBuilder()	                .appendWeekyear(4, 9)	                .toFormatter();	        }	        return we;	    }	
private static DateTimeFormatter weekElement() {	        if (wwe == null) {	            wwe = new DateTimeFormatterBuilder()	                .appendLiteral("-W")	                .appendWeekOfWeekyear(2)	                .toFormatter();	        }	        return wwe;	    }	
private static DateTimeFormatter dayOfWeekElement() {	        if (dwe == null) {	            dwe = new DateTimeFormatterBuilder()	                .appendLiteral('-')	                .appendDayOfWeek(1)	                .toFormatter();	        }	        return dwe;	    }	
private static DateTimeFormatter dayOfYearElement() {	        if (dye == null) {	            dye = new DateTimeFormatterBuilder()	                .appendLiteral('-')	                .appendDayOfYear(3)	                .toFormatter();	        }	        return dye;	    }	
private static DateTimeFormatter literalTElement() {	        if (lte == null) {	            lte = new DateTimeFormatterBuilder()	                .appendLiteral('T')	                .toFormatter();	        }	        return lte;	    }	
private static DateTimeFormatter hourElement() {	        if (hde == null) {	            hde = new DateTimeFormatterBuilder()	                .appendHourOfDay(2)	                .toFormatter();	        }	        return hde;	    }	
private static DateTimeFormatter minuteElement() {	        if (mhe == null) {	            mhe = new DateTimeFormatterBuilder()	                .appendLiteral(':')	                .appendMinuteOfHour(2)	                .toFormatter();	        }	        return mhe;	    }	
private static DateTimeFormatter secondElement() {	        if (sme == null) {	            sme = new DateTimeFormatterBuilder()	                .appendLiteral(':')	                .appendSecondOfMinute(2)	                .toFormatter();	        }	        return sme;	    }	
private static DateTimeFormatter fractionElement() {	        if (fse == null) {	            fse = new DateTimeFormatterBuilder()	                .appendLiteral('.')	                // Support parsing up to nanosecond precision even though	                // those extra digits will be dropped.	                .appendFractionOfSecond(3, 9)	                .toFormatter();	        }	        return fse;	    }	
private static DateTimeFormatter offsetElement() {	        if (ze == null) {	            ze = new DateTimeFormatterBuilder()	                .appendTimeZoneOffset("Z", true, 2, 4)	                .toFormatter();	        }	        return ze;	    }	
/**	     * Constructs a bucket.	     * 	     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time	     * @param chrono  the chronology to use	     * @param locale  the locale to use	     * @deprecated Use longer constructor	     */	    @Deprecated	    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale) {	        this(instantLocal, chrono, locale, null, 2000);	    }	
/**	     * Constructs a bucket, with the option of specifying the pivot year for	     * two-digit year parsing.	     *	     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time	     * @param chrono  the chronology to use	     * @param locale  the locale to use	     * @param pivotYear  the pivot year to use when parsing two-digit years	     * @since 1.1	     * @deprecated Use longer constructor	     */	    @Deprecated	    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear) {	        this(instantLocal, chrono, locale, pivotYear, 2000);	    }	
/**	     * Constructs a bucket, with the option of specifying the pivot year for	     * two-digit year parsing.	     *	     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time	     * @param chrono  the chronology to use	     * @param locale  the locale to use	     * @param pivotYear  the pivot year to use when parsing two-digit years	     * @since 2.0	     */	    public DateTimeParserBucket(long instantLocal, Chronology chrono,	            Locale locale, Integer pivotYear, int defaultYear) {	        super();	        chrono = DateTimeUtils.getChronology(chrono);	        iMillis = instantLocal;	        iChrono = chrono.withUTC();	        iLocale = (locale == null ? Locale.getDefault() : locale);	        setZone(chrono.getZone());	        iPivotYear = pivotYear;	        iDefaultYear = defaultYear;	    }	
/**	     * Gets the chronology of the bucket, which will be a local (UTC) chronology.	     */	    public Chronology getChronology() {	        return iChrono;	    }	
/**	     * Returns the locale to be used during parsing.	     * 	     * @return the locale to use	     */	    public Locale getLocale() {	        return iLocale;	    }	
/**	     * Returns the time zone used by computeMillis, or null if an offset is	     * used instead.	     */	    public DateTimeZone getZone() {	        return iZone;	    }	
/**	     * Set a time zone to be used when computeMillis is called, which	     * overrides any set time zone offset.	     *	     * @param zone the date time zone to operate in, or null if UTC	     */	    public void setZone(DateTimeZone zone) {	        iSavedState = null;	        iZone = zone == DateTimeZone.UTC ? null : zone;	        iOffset = 0;	    }	
/**	     * Returns the time zone offset in milliseconds used by computeMillis,	     * unless getZone doesn't return null.	     */	    public int getOffset() {	        return iOffset;	    }	
/**	     * Set a time zone offset to be used when computeMillis is called, which	     * overrides the time zone.	     */	    public void setOffset(int offset) {	        iSavedState = null;	        iOffset = offset;	        iZone = null;	    }	
/**	     * Returns the default year used when information is incomplete.	     * <p>	     * This is used for two-digit years and when the largest parsed field is	     * months or days.	     * <p>	     * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.	     * A null value for month/day only parsing will cause the default of 2000 to be used.	     *	     * @return Integer value of the pivot year, null if not set	     * @since 1.1	     */	    public Integer getPivotYear() {	        return iPivotYear;	    }	
/**	     * Sets the pivot year to use when parsing two digit years.	     * <p>	     * If the value is set to null, this will indicate that default	     * behaviour should be used.	     *	     * @param pivotYear  the pivot year to use	     * @since 1.1	     */	    public void setPivotYear(Integer pivotYear) {	        iPivotYear = pivotYear;	    }	
/**	     * Saves a datetime field value.	     * 	     * @param field  the field, whose chronology must match that of this bucket	     * @param value  the value	     */	    public void saveField(DateTimeField field, int value) {	        saveField(new SavedField(field, value));	    }	
/**	     * Saves a datetime field value.	     * 	     * @param fieldType  the field type	     * @param value  the value	     */	    public void saveField(DateTimeFieldType fieldType, int value) {	        saveField(new SavedField(fieldType.getField(iChrono), value));	    }	
/**	     * Saves a datetime field text value.	     * 	     * @param fieldType  the field type	     * @param text  the text value	     * @param locale  the locale to use	     */	    public void saveField(DateTimeFieldType fieldType, String text, Locale locale) {	        saveField(new SavedField(fieldType.getField(iChrono), text, locale));	    }	
private void saveField(SavedField field) {	        SavedField[] savedFields = iSavedFields;	        int savedFieldsCount = iSavedFieldsCount;	        	        if (savedFieldsCount == savedFields.length || iSavedFieldsShared) {	            // Expand capacity or merely copy if saved fields are shared.	            SavedField[] newArray = new SavedField	                [savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];	            System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);	            iSavedFields = savedFields = newArray;	            iSavedFieldsShared = false;	        }	        	        iSavedState = null;	        savedFields[savedFieldsCount] = field;	        iSavedFieldsCount = savedFieldsCount + 1;	    }	
/**	     * Saves the state of this bucket, returning it in an opaque object. Call	     * restoreState to undo any changes that were made since the state was	     * saved. Calls to saveState may be nested.	     *	     * @return opaque saved state, which may be passed to restoreState	     */	    public Object saveState() {	        if (iSavedState == null) {	            iSavedState = new SavedState();	        }	        return iSavedState;	    }	
/**	     * Restores the state of this bucket from a previously saved state. The	     * state object passed into this method is not consumed, and it can be used	     * later to restore to that state again.	     *	     * @param savedState opaque saved state, returned from saveState	     * @return true state object is valid and state restored	     */	    public boolean restoreState(Object savedState) {	        if (savedState instanceof SavedState) {	            if (((SavedState) savedState).restoreState(this)) {	                iSavedState = savedState;	                return true;	            }	        }	        return false;	    }	
/**	     * Computes the parsed datetime by setting the saved fields.	     * This method is idempotent, but it is not thread-safe.	     *	     * @return milliseconds since 1970-01-01T00:00:00Z	     * @throws IllegalArgumentException if any field is out of range	     */	    public long computeMillis() {	        return computeMillis(false, null);	    }	
/**	     * Computes the parsed datetime by setting the saved fields.	     * This method is idempotent, but it is not thread-safe.	     *	     * @param resetFields false by default, but when true, unsaved field values are cleared	     * @return milliseconds since 1970-01-01T00:00:00Z	     * @throws IllegalArgumentException if any field is out of range	     */	    public long computeMillis(boolean resetFields) {	        return computeMillis(resetFields, null);	    }	
/**	     * Computes the parsed datetime by setting the saved fields.	     * This method is idempotent, but it is not thread-safe.	     *	     * @param resetFields false by default, but when true, unsaved field values are cleared	     * @param text optional text being parsed, to be included in any error message	     * @return milliseconds since 1970-01-01T00:00:00Z	     * @throws IllegalArgumentException if any field is out of range	     * @since 1.3	     */	    public long computeMillis(boolean resetFields, String text) {	        SavedField[] savedFields = iSavedFields;	        int count = iSavedFieldsCount;	        if (iSavedFieldsShared) {	            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();	            iSavedFieldsShared = false;	        }	        sort(savedFields, count);	        if (count > 0) {	            // alter base year for parsing if first field is month or day	            DurationField months = DurationFieldType.months().getField(iChrono);	            DurationField days = DurationFieldType.days().getField(iChrono);	            DurationField first = savedFields[0].iField.getDurationField();	            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {	                saveField(DateTimeFieldType.year(), iDefaultYear);	                return computeMillis(resetFields, text);	            }	        }		        long millis = iMillis;	        try {	            for (int i=0; i<count; i++) {	                millis = savedFields[i].set(millis, resetFields);	            }	        } catch (IllegalFieldValueException e) {	            if (text != null) {	                e.prependMessage("Cannot parse \"" + text + '"');	            }	            throw e;	        }	        	        if (iZone == null) {	            millis -= iOffset;	        } else {	            int offset = iZone.getOffsetFromLocal(millis);	            millis -= offset;	            if (offset != iZone.getOffset(millis)) {	                String message =	                    "Illegal instant due to time zone offset transition (" + iZone + ')';	                if (text != null) {	                    message = "Cannot parse \"" + text + "\": " + message;	                }	                throw new IllegalArgumentException(message);	            }	        }	        	        return millis;	    }	
/**	     * Sorts elements [0,high). Calling java.util.Arrays isn't always the right	     * choice since it always creates an internal copy of the array, even if it	     * doesn't need to. If the array slice is small enough, an insertion sort	     * is chosen instead, but it doesn't need a copy!	     * <p>	     * This method has a modified version of that insertion sort, except it	     * doesn't create an unnecessary array copy. If high is over 10, then	     * java.util.Arrays is called, which will perform a merge sort, which is	     * faster than insertion sort on large lists.	     * <p>	     * The end result is much greater performance when computeMillis is called.	     * Since the amount of saved fields is small, the insertion sort is a	     * better choice. Additional performance is gained since there is no extra	     * array allocation and copying. Also, the insertion sort here does not	     * perform any casting operations. The version in java.util.Arrays performs	     * casts within the insertion sort loop.	     */	    private static void sort(SavedField[] array, int high) {	        if (high > 10) {	            Arrays.sort(array, 0, high);	        } else {	            for (int i=0; i<high; i++) {	                for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {	                    SavedField t = array[j];	                    array[j] = array[j-1];	                    array[j-1] = t;	                }	            }	        }	    }	
SavedState() {	            this.iZone = DateTimeParserBucket.this.iZone;	            this.iOffset = DateTimeParserBucket.this.iOffset;	            this.iSavedFields = DateTimeParserBucket.this.iSavedFields;	            this.iSavedFieldsCount = DateTimeParserBucket.this.iSavedFieldsCount;	        }	
boolean restoreState(DateTimeParserBucket enclosing) {	            if (enclosing != DateTimeParserBucket.this) {	                return false;	            }	            enclosing.iZone = this.iZone;	            enclosing.iOffset = this.iOffset;	            enclosing.iSavedFields = this.iSavedFields;	            if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) {	                // Since count is being restored to a lower count, the	                // potential exists for new saved fields to destroy data being	                // shared by another state. Set this flag such that the array	                // of saved fields is cloned prior to modification.	                enclosing.iSavedFieldsShared = true;	            }	            enclosing.iSavedFieldsCount = this.iSavedFieldsCount;	            return true;	        }	
SavedField(DateTimeField field, int value) {	            iField = field;	            iValue = value;	            iText = null;	            iLocale = null;	        }	
SavedField(DateTimeField field, String text, Locale locale) {	            iField = field;	            iValue = 0;	            iText = text;	            iLocale = locale;	        }	
long set(long millis, boolean reset) {	            if (iText == null) {	                millis = iField.set(millis, iValue);	            } else {	                millis = iField.set(millis, iText, iLocale);	            }	            if (reset) {	                millis = iField.roundFloor(millis);	            }	            return millis;	        }	
/**	         * The field with the longer range duration is ordered first, where	         * null is considered infinite. If the ranges match, then the field	         * with the longer duration is ordered first.	         */	        public int compareTo(SavedField obj) {	            DateTimeField other = obj.iField;	            int result = compareReverse	                (iField.getRangeDurationField(), other.getRangeDurationField());	            if (result != 0) {	                return result;	            }	            return compareReverse	                (iField.getDurationField(), other.getDurationField());	        }	
static int compareReverse(DurationField a, DurationField b) {	        if (a == null || !a.isSupported()) {	            if (b == null || !b.isSupported()) {	                return 0;	            }	            return -1;	        }	        if (b == null || !b.isSupported()) {	            return 1;	        }	        return -a.compareTo(b);	    }	
/**	     * Creates a new formatter, however you will normally use the factory	     * or the builder.	     * 	     * @param printer  the internal printer, null if cannot print	     * @param parser  the internal parser, null if cannot parse	     */	    public DateTimeFormatter(	            DateTimePrinter printer, DateTimeParser parser) {	        super();	        iPrinter = printer;	        iParser = parser;	        iLocale = null;	        iOffsetParsed = false;	        iChrono = null;	        iZone = null;	        iPivotYear = null;	        iDefaultYear = 2000;	    }	
/**	     * Constructor.	     */	    private DateTimeFormatter(	            DateTimePrinter printer, DateTimeParser parser,	            Locale locale, boolean offsetParsed,	            Chronology chrono, DateTimeZone zone,	            Integer pivotYear, int defaultYear) {	        super();	        iPrinter = printer;	        iParser = parser;	        iLocale = locale;	        iOffsetParsed = offsetParsed;	        iChrono = chrono;	        iZone = zone;	        iPivotYear = pivotYear;	        iDefaultYear = defaultYear;	    }	
/**	     * Is this formatter capable of printing.	     * 	     * @return true if this is a printer	     */	    public boolean isPrinter() {	        return (iPrinter != null);	    }	
/**	     * Gets the internal printer object that performs the real printing work.	     * 	     * @return the internal printer; is null if printing not supported	     */	    public DateTimePrinter getPrinter() {	        return iPrinter;	    }	
/**	     * Is this formatter capable of parsing.	     * 	     * @return true if this is a parser	     */	    public boolean isParser() {	        return (iParser != null);	    }	
/**	     * Gets the internal parser object that performs the real parsing work.	     * 	     * @return the internal parser; is null if parsing not supported	     */	    public DateTimeParser getParser() {	        return iParser;	    }	
/**	     * Returns a new formatter with a different locale that will be used	     * for printing and parsing.	     * <p>	     * A DateTimeFormatter is immutable, so a new instance is returned,	     * and the original is unaltered and still usable.	     * 	     * @param locale the locale to use; if null, formatter uses default locale	     * at invocation time	     * @return the new formatter	     */	    public DateTimeFormatter withLocale(Locale locale) {	        if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {	            return this;	        }	        return new DateTimeFormatter(iPrinter, iParser, locale,	                iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);	    }	
/**	     * Gets the locale that will be used for printing and parsing.	     * 	     * @return the locale to use; if null, formatter uses default locale at	     * invocation time	     */	    public Locale getLocale() {	        return iLocale;	    }	
/**	     * Returns a new formatter that will create a datetime with a time zone	     * equal to that of the offset of the parsed string.	     * <p>	     * After calling this method, a string '2004-06-09T10:20:30-08:00' will	     * create a datetime with a zone of -08:00 (a fixed zone, with no daylight	     * savings rules). If the parsed string represents a local time (no zone	     * offset) the parsed datetime will be in the default zone.	     * <p>	     * Calling this method sets the override zone to null.	     * Calling the override zone method sets this flag off.	     * 	     * @return the new formatter	     */	    public DateTimeFormatter withOffsetParsed() {	        if (iOffsetParsed == true) {	            return this;	        }	        return new DateTimeFormatter(iPrinter, iParser, iLocale,	                true, iChrono, null, iPivotYear, iDefaultYear);	    }	
/**	     * Checks whether the offset from the string is used as the zone of	     * the parsed datetime.	     * 	     * @return true if the offset from the string is used as the zone	     */	    public boolean isOffsetParsed() {	        return iOffsetParsed;	    }	
/**	     * Returns a new formatter that will use the specified chronology in	     * preference to that of the printed object, or ISO on a parse.	     * <p>	     * When printing, this chronolgy will be used in preference to the chronology	     * from the datetime that would otherwise be used.	     * <p>	     * When parsing, this chronology will be set on the parsed datetime.	     * <p>	     * A null chronology means no-override.	     * If both an override chronology and an override zone are set, the	     * override zone will take precedence over the zone in the chronology.	     * 	     * @param chrono  the chronology to use as an override	     * @return the new formatter	     */	    public DateTimeFormatter withChronology(Chronology chrono) {	        if (iChrono == chrono) {	            return this;	        }	        return new DateTimeFormatter(iPrinter, iParser, iLocale,	                iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);	    }	
/**	     * Gets the chronology to use as an override.	     * 	     * @return the chronology to use as an override	     */	    public Chronology getChronology() {	        return iChrono;	    }	
/**	     * Gets the chronology to use as an override.	     * 	     * @return the chronology to use as an override	     * @deprecated Use the method with the correct spelling	     */	    public Chronology getChronolgy() {	        return iChrono;	    }	
/**	     * Returns a new formatter that will use the UTC zone in preference	     * to the zone of the printed object, or default zone on a parse.	     * <p>	     * When printing, UTC will be used in preference to the zone	     * from the datetime that would otherwise be used.	     * <p>	     * When parsing, UTC will be set on the parsed datetime.	     * <p>	     * If both an override chronology and an override zone are set, the	     * override zone will take precedence over the zone in the chronology.	     * 	     * @return the new formatter, never null	     * @since 2.0	     */	    public DateTimeFormatter withZoneUTC() {	        return withZone(DateTimeZone.UTC);	    }	
/**	     * Returns a new formatter that will use the specified zone in preference	     * to the zone of the printed object, or default zone on a parse.	     * <p>	     * When printing, this zone will be used in preference to the zone	     * from the datetime that would otherwise be used.	     * <p>	     * When parsing, this zone will be set on the parsed datetime.	     * <p>	     * A null zone means of no-override.	     * If both an override chronology and an override zone are set, the	     * override zone will take precedence over the zone in the chronology.	     * 	     * @param zone  the zone to use as an override	     * @return the new formatter	     */	    public DateTimeFormatter withZone(DateTimeZone zone) {	        if (iZone == zone) {	            return this;	        }	        return new DateTimeFormatter(iPrinter, iParser, iLocale,	                false, iChrono, zone, iPivotYear, iDefaultYear);	    }	
/**	     * Gets the zone to use as an override.	     * 	     * @return the zone to use as an override	     */	    public DateTimeZone getZone() {	        return iZone;	    }	
/**	     * Returns a new formatter that will use the specified pivot year for two	     * digit year parsing in preference to that stored in the parser.	     * <p>	     * This setting is useful for changing the pivot year of formats built	     * using a pattern - {@link DateTimeFormat#forPattern(String)}.	     * <p>	     * When parsing, this pivot year is used. Null means no-override.	     * There is no effect when printing.	     * <p>	     * The pivot year enables a two digit year to be converted to a four	     * digit year. The pivot represents the year in the middle of the	     * supported range of years. Thus the full range of years that will	     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.	     *	     * <pre>	     * pivot   supported range   00 is   20 is   40 is   60 is   80 is	     * ---------------------------------------------------------------	     * 1950      1900..1999      1900    1920    1940    1960    1980	     * 1975      1925..2024      2000    2020    1940    1960    1980	     * 2000      1950..2049      2000    2020    2040    1960    1980	     * 2025      1975..2074      2000    2020    2040    2060    1980	     * 2050      2000..2099      2000    2020    2040    2060    2080	     * </pre>	     *	     * @param pivotYear  the pivot year to use as an override when parsing	     * @return the new formatter	     * @since 1.1	     */	    public DateTimeFormatter withPivotYear(Integer pivotYear) {	        if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {	            return this;	        }	        return new DateTimeFormatter(iPrinter, iParser, iLocale,	                iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);	    }	
/**	     * Returns a new formatter that will use the specified pivot year for two	     * digit year parsing in preference to that stored in the parser.	     * <p>	     * This setting is useful for changing the pivot year of formats built	     * using a pattern - {@link DateTimeFormat#forPattern(String)}.	     * <p>	     * When parsing, this pivot year is used.	     * There is no effect when printing.	     * <p>	     * The pivot year enables a two digit year to be converted to a four	     * digit year. The pivot represents the year in the middle of the	     * supported range of years. Thus the full range of years that will	     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.	     *	     * <pre>	     * pivot   supported range   00 is   20 is   40 is   60 is   80 is	     * ---------------------------------------------------------------	     * 1950      1900..1999      1900    1920    1940    1960    1980	     * 1975      1925..2024      2000    2020    1940    1960    1980	     * 2000      1950..2049      2000    2020    2040    1960    1980	     * 2025      1975..2074      2000    2020    2040    2060    1980	     * 2050      2000..2099      2000    2020    2040    2060    2080	     * </pre>	     *	     * @param pivotYear  the pivot year to use as an override when parsing	     * @return the new formatter	     * @since 1.1	     */	    public DateTimeFormatter withPivotYear(int pivotYear) {	        return withPivotYear(new Integer(pivotYear));	    }	
/**	     * Gets the pivot year to use as an override.	     *	     * @return the pivot year to use as an override	     * @since 1.1	     */	    public Integer getPivotYear() {	      return iPivotYear;	    }	
/**	     * Returns a new formatter that will use the specified default year.	     * <p>	     * The default year is used when parsing in the case where there is a	     * month or a day but not a year. Specifically, it is used if there is	     * a field parsed with a duration between the length of a month and the	     * length of a day inclusive.	     * <p>	     * This value is typically used to move the year from 1970 to a leap year	     * to enable February 29th to be parsed.	     * Unless customised, the year 2000 is used.	     * <p>	     * This setting has no effect when printing.	     *	     * @param defaultYear  the default year to use	     * @return the new formatter, not null	     * @since 2.0	     */	    public DateTimeFormatter withDefaultYear(int defaultYear) {	        return new DateTimeFormatter(iPrinter, iParser, iLocale,	                iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);	    }	
/**	     * Gets the default year for parsing months and days.	     *	     * @return the default year for parsing months and days	     * @since 2.0	     */	    public int getDefaultYear() {	      return iDefaultYear;	    }	
/**	     * Prints a ReadableInstant, using the chronology supplied by the instant.	     *	     * @param buf  the destination to format to, not null	     * @param instant  instant to format, null means now	     */	    public void printTo(StringBuffer buf, ReadableInstant instant) {	        long millis = DateTimeUtils.getInstantMillis(instant);	        Chronology chrono = DateTimeUtils.getInstantChronology(instant);	        printTo(buf, millis, chrono);	    }	
/**	     * Prints a ReadableInstant, using the chronology supplied by the instant.	     *	     * @param out  the destination to format to, not null	     * @param instant  instant to format, null means now	     */	    public void printTo(Writer out, ReadableInstant instant) throws IOException {	        long millis = DateTimeUtils.getInstantMillis(instant);	        Chronology chrono = DateTimeUtils.getInstantChronology(instant);	        printTo(out, millis, chrono);	    }	
/**	     * Prints a ReadableInstant, using the chronology supplied by the instant.	     *	     * @param appendable  the destination to format to, not null	     * @param instant  instant to format, null means now	     * @since 2.0	     */	    public void printTo(Appendable appendable, ReadableInstant instant) throws IOException {	        appendable.append(print(instant));	    }	
/**	     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,	     * using ISO chronology in the default DateTimeZone.	     *	     * @param buf  the destination to format to, not null	     * @param instant  millis since 1970-01-01T00:00:00Z	     */	    public void printTo(StringBuffer buf, long instant) {	        printTo(buf, instant, null);	    }	
/**	     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,	     * using ISO chronology in the default DateTimeZone.	     *	     * @param out  the destination to format to, not null	     * @param instant  millis since 1970-01-01T00:00:00Z	     */	    public void printTo(Writer out, long instant) throws IOException {	        printTo(out, instant, null);	    }	
/**	     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,	     * using ISO chronology in the default DateTimeZone.	     *	     * @param appendable  the destination to format to, not null	     * @param instant  millis since 1970-01-01T00:00:00Z	     * @since 2.0	     */	    public void printTo(Appendable appendable, long instant) throws IOException {	        appendable.append(print(instant));	    }	
/**	     * Prints a ReadablePartial.	     * <p>	     * Neither the override chronology nor the override zone are used	     * by this method.	     *	     * @param buf  the destination to format to, not null	     * @param partial  partial to format	     */	    public void printTo(StringBuffer buf, ReadablePartial partial) {	        DateTimePrinter printer = requirePrinter();	        if (partial == null) {	            throw new IllegalArgumentException("The partial must not be null");	        }	        printer.printTo(buf, partial, iLocale);	    }	
/**	     * Prints a ReadablePartial.	     * <p>	     * Neither the override chronology nor the override zone are used	     * by this method.	     *	     * @param out  the destination to format to, not null	     * @param partial  partial to format	     */	    public void printTo(Writer out, ReadablePartial partial) throws IOException {	        DateTimePrinter printer = requirePrinter();	        if (partial == null) {	            throw new IllegalArgumentException("The partial must not be null");	        }	        printer.printTo(out, partial, iLocale);	    }	
/**	     * Prints a ReadablePartial.	     * <p>	     * Neither the override chronology nor the override zone are used	     * by this method.	     *	     * @param appendable  the destination to format to, not null	     * @param partial  partial to format	     * @since 2.0	     */	    public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {	        appendable.append(print(partial));	    }	
/**	     * Prints a ReadableInstant to a String.	     * <p>	     * This method will use the override zone and the override chronololgy if	     * they are set. Otherwise it will use the chronology and zone of the instant.	     *	     * @param instant  instant to format, null means now	     * @return the printed result	     */	    public String print(ReadableInstant instant) {	        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());	        printTo(buf, instant);	        return buf.toString();	    }	
/**	     * Prints a millisecond instant to a String.	     * <p>	     * This method will use the override zone and the override chronololgy if	     * they are set. Otherwise it will use the ISO chronology and default zone.	     *	     * @param instant  millis since 1970-01-01T00:00:00Z	     * @return the printed result	     */	    public String print(long instant) {	        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());	        printTo(buf, instant);	        return buf.toString();	    }	
/**	     * Prints a ReadablePartial to a new String.	     * <p>	     * Neither the override chronology nor the override zone are used	     * by this method.	     *	     * @param partial  partial to format	     * @return the printed result	     */	    public String print(ReadablePartial partial) {	        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());	        printTo(buf, partial);	        return buf.toString();	    }	
private void printTo(StringBuffer buf, long instant, Chronology chrono) {	        DateTimePrinter printer = requirePrinter();	        chrono = selectChronology(chrono);	        // Shift instant into local time (UTC) to avoid excessive offset	        // calculations when printing multiple fields in a composite printer.	        DateTimeZone zone = chrono.getZone();	        int offset = zone.getOffset(instant);	        long adjustedInstant = instant + offset;	        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {	            // Time zone offset overflow, so revert to UTC.	            zone = DateTimeZone.UTC;	            offset = 0;	            adjustedInstant = instant;	        }	        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);	    }	
private void printTo(Writer buf, long instant, Chronology chrono) throws IOException {	        DateTimePrinter printer = requirePrinter();	        chrono = selectChronology(chrono);	        // Shift instant into local time (UTC) to avoid excessive offset	        // calculations when printing multiple fields in a composite printer.	        DateTimeZone zone = chrono.getZone();	        int offset = zone.getOffset(instant);	        long adjustedInstant = instant + offset;	        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {	            // Time zone offset overflow, so revert to UTC.	            zone = DateTimeZone.UTC;	            offset = 0;	            adjustedInstant = instant;	        }	        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);	    }	
/**	     * Checks whether printing is supported.	     * 	     * @throws UnsupportedOperationException if printing is not supported	     */	    private DateTimePrinter requirePrinter() {	        DateTimePrinter printer = iPrinter;	        if (printer == null) {	            throw new UnsupportedOperationException("Printing not supported");	        }	        return printer;	    }	
/**	     * Parses a datetime from the given text, at the given position, saving the	     * result into the fields of the given ReadWritableInstant. If the parse	     * succeeds, the return value is the new text position. Note that the parse	     * may succeed without fully reading the text and in this case those fields	     * that were read will be set.	     * <p>	     * Only those fields present in the string will be changed in the specified	     * instant. All other fields will remain unaltered. Thus if the string only	     * contains a year and a month, then the day and time will be retained from	     * the input instant. If this is not the behaviour you want, then reset the	     * fields before calling this method, or use {@link #parseDateTime(String)}	     * or {@link #parseMutableDateTime(String)}.	     * <p>	     * If it fails, the return value is negative, but the instant may still be	     * modified. To determine the position where the parse failed, apply the	     * one's complement operator (~) on the return value.	     * <p>	     * The parse will use the chronology of the instant.	     *	     * @param instant  an instant that will be modified, not null	     * @param text  the text to parse	     * @param position  position to start parsing from	     * @return new position, negative value means parse failed -	     *  apply complement operator (~) to get position of failure	     * @throws UnsupportedOperationException if parsing is not supported	     * @throws IllegalArgumentException if the instant is null	     * @throws IllegalArgumentException if any field is out of range	     */	    public int parseInto(ReadWritableInstant instant, String text, int position) {	        DateTimeParser parser = requireParser();	        if (instant == null) {	            throw new IllegalArgumentException("Instant must not be null");	        }	        	        long instantMillis = instant.getMillis();	        Chronology chrono = instant.getChronology();	        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);	        chrono = selectChronology(chrono);	        	        DateTimeParserBucket bucket = new DateTimeParserBucket(	            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);	        int newPos = parser.parseInto(bucket, text, position);	        instant.setMillis(bucket.computeMillis(false, text));	        if (iOffsetParsed && bucket.getZone() == null) {	            int parsedOffset = bucket.getOffset();	            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);	            chrono = chrono.withZone(parsedZone);	        }	        instant.setChronology(chrono);	        return newPos;	    }	
/**	     * Parses a datetime from the given text, returning the number of	     * milliseconds since the epoch, 1970-01-01T00:00:00Z.	     * <p>	     * The parse will use the ISO chronology, and the default time zone.	     * If the text contains a time zone string then that will be taken into account.	     *	     * @param text  text to parse	     * @return parsed value expressed in milliseconds since the epoch	     * @throws UnsupportedOperationException if parsing is not supported	     * @throws IllegalArgumentException if the text to parse is invalid	     */	    public long parseMillis(String text) {	        DateTimeParser parser = requireParser();	        	        Chronology chrono = selectChronology(iChrono);	        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);	        int newPos = parser.parseInto(bucket, text, 0);	        if (newPos >= 0) {	            if (newPos >= text.length()) {	                return bucket.computeMillis(true, text);	            }	        } else {	            newPos = ~newPos;	        }	        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));	    }	
/**	     * Parses only the local date from the given text, returning a new LocalDate.	     * <p>	     * This will parse the text fully according to the formatter, using the UTC zone.	     * Once parsed, only the local date will be used.	     * This means that any parsed time, time-zone or offset field is completely ignored.	     * It also means that the zone and offset-parsed settings are ignored.	     *	     * @param text  the text to parse, not null	     * @return the parsed date, never null	     * @throws UnsupportedOperationException if parsing is not supported	     * @throws IllegalArgumentException if the text to parse is invalid	     * @since 2.0	     */	    public LocalDate parseLocalDate(String text) {	        return parseLocalDateTime(text).toLocalDate();	    }	
/**	     * Parses only the local time from the given text, returning a new LocalDate.	     * <p>	     * This will parse the text fully according to the formatter, using the UTC zone.	     * Once parsed, only the local time will be used.	     * This means that any parsed date, time-zone or offset field is completely ignored.	     * It also means that the zone and offset-parsed settings are ignored.	     *	     * @param text  the text to parse, not null	     * @return the parsed time, never null	     * @throws UnsupportedOperationException if parsing is not supported	     * @throws IllegalArgumentException if the text to parse is invalid	     * @since 2.0	     */	    public LocalTime parseLocalTime(String text) {	        return parseLocalDateTime(text).toLocalTime();	    }	
/**	     * Parses only the local date-time from the given text, returning a new LocalDate.	     * <p>	     * This will parse the text fully according to the formatter, using the UTC zone.	     * Once parsed, only the local date-time will be used.	     * This means that any parsed time-zone or offset field is completely ignored.	     * It also means that the zone and offset-parsed settings are ignored.	     *	     * @param text  the text to parse, not null	     * @return the parsed date-time, never null	     * @throws UnsupportedOperationException if parsing is not supported	     * @throws IllegalArgumentException if the text to parse is invalid	     * @since 2.0	     */	    public LocalDateTime parseLocalDateTime(String text) {	        DateTimeParser parser = requireParser();	        	        Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps	        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);	        int newPos = parser.parseInto(bucket, text, 0);	        if (newPos >= 0) {	            if (newPos >= text.length()) {	                long millis = bucket.computeMillis(true, text);	                if (bucket.getZone() == null) {  // treat withOffsetParsed() as being true	                    int parsedOffset = bucket.getOffset();	                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);	                    chrono = chrono.withZone(parsedZone);	                }	                return new LocalDateTime(millis, chrono);	            }	        } else {	            newPos = ~newPos;	        }	        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));	    }	
/**	     * Parses a date-time from the given text, returning a new DateTime.	     * <p>	     * The parse will use the zone and chronology specified on this formatter.	     * <p>	     * If the text contains a time zone string then that will be taken into	     * account in adjusting the time of day as follows.	     * If the {@link #withOffsetParsed()} has been called, then the resulting	     * DateTime will have a fixed offset based on the parsed time zone.	     * Otherwise the resulting DateTime will have the zone of this formatter,	     * but the parsed zone may have caused the time to be adjusted.	     *	     * @param text  the text to parse, not null	     * @return the parsed date-time, never null	     * @throws UnsupportedOperationException if parsing is not supported	     * @throws IllegalArgumentException if the text to parse is invalid	     */	    public DateTime parseDateTime(String text) {	        DateTimeParser parser = requireParser();	        	        Chronology chrono = selectChronology(null);	        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);	        int newPos = parser.parseInto(bucket, text, 0);	        if (newPos >= 0) {	            if (newPos >= text.length()) {	                long millis = bucket.computeMillis(true, text);	                if (iOffsetParsed && bucket.getZone() == null) {	                    int parsedOffset = bucket.getOffset();	                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);	                    chrono = chrono.withZone(parsedZone);	                }	                return new DateTime(millis, chrono);	            }	        } else {	            newPos = ~newPos;	        }	        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));	    }	
/**	     * Parses a date-time from the given text, returning a new MutableDateTime.	     * <p>	     * The parse will use the zone and chronology specified on this formatter.	     * <p>	     * If the text contains a time zone string then that will be taken into	     * account in adjusting the time of day as follows.	     * If the {@link #withOffsetParsed()} has been called, then the resulting	     * DateTime will have a fixed offset based on the parsed time zone.	     * Otherwise the resulting DateTime will have the zone of this formatter,	     * but the parsed zone may have caused the time to be adjusted.	     *	     * @param text  the text to parse, not null	     * @return the parsed date-time, never null	     * @throws UnsupportedOperationException if parsing is not supported	     * @throws IllegalArgumentException if the text to parse is invalid	     */	    public MutableDateTime parseMutableDateTime(String text) {	        DateTimeParser parser = requireParser();	        	        Chronology chrono = selectChronology(null);	        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);	        int newPos = parser.parseInto(bucket, text, 0);	        if (newPos >= 0) {	            if (newPos >= text.length()) {	                long millis = bucket.computeMillis(true, text);	                if (iOffsetParsed && bucket.getZone() == null) {	                    int parsedOffset = bucket.getOffset();	                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);	                    chrono = chrono.withZone(parsedZone);	                }	                return new MutableDateTime(millis, chrono);	            }	        } else {	            newPos = ~newPos;	        }	        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));	    }	
/**	     * Checks whether parsing is supported.	     * 	     * @throws UnsupportedOperationException if parsing is not supported	     */	    private DateTimeParser requireParser() {	        DateTimeParser parser = iParser;	        if (parser == null) {	            throw new UnsupportedOperationException("Parsing not supported");	        }	        return parser;	    }	
/**	     * Determines the correct chronology to use.	     *	     * @param chrono  the proposed chronology	     * @return the actual chronology	     */	    private Chronology selectChronology(Chronology chrono) {	        chrono = DateTimeUtils.getChronology(chrono);	        if (iChrono != null) {	            chrono = iChrono;	        }	        if (iZone != null) {	            chrono = chrono.withZone(iZone);	        }	        return chrono;	    }	
/**	     * Constructor.	     *	     * @since 1.1 (previously private)	     */	    protected ISOPeriodFormat() {	        super();	    }	
/**	     * The standard ISO format - PyYmMwWdDThHmMsS.	     * Milliseconds are not output.	     * Note that the ISO8601 standard actually indicates weeks should not	     * be shown if any other field is present and vice versa.	     * 	     * @return the formatter	     */	    public static PeriodFormatter standard() {	        if (cStandard == null) {	            cStandard = new PeriodFormatterBuilder()	                .appendLiteral("P")	                .appendYears()	                .appendSuffix("Y")	                .appendMonths()	                .appendSuffix("M")	                .appendWeeks()	                .appendSuffix("W")	                .appendDays()	                .appendSuffix("D")	                .appendSeparatorIfFieldsAfter("T")	                .appendHours()	                .appendSuffix("H")	                .appendMinutes()	                .appendSuffix("M")	                .appendSecondsWithOptionalMillis()	                .appendSuffix("S")	                .toFormatter();	        }	        return cStandard;	    }	
/**	     * The alternate ISO format, PyyyymmddThhmmss, which excludes weeks.	     * <p>	     * Even if weeks are present in the period, they are not output.	     * Fractional seconds (milliseconds) will appear if required.	     * 	     * @return the formatter	     */	    public static PeriodFormatter alternate() {	        if (cAlternate == null) {	            cAlternate = new PeriodFormatterBuilder()	                .appendLiteral("P")	                .printZeroAlways()	                .minimumPrintedDigits(4)	                .appendYears()	                .minimumPrintedDigits(2)	                .appendMonths()	                .appendDays()	                .appendSeparatorIfFieldsAfter("T")	                .appendHours()	                .appendMinutes()	                .appendSecondsWithOptionalMillis()	                .toFormatter();	        }	        return cAlternate;	    }	
/**	     * The alternate ISO format, Pyyyy-mm-ddThh:mm:ss, which excludes weeks.	     * <p>	     * Even if weeks are present in the period, they are not output.	     * Fractional seconds (milliseconds) will appear if required.	     * 	     * @return the formatter	     */	    public static PeriodFormatter alternateExtended() {	        if (cAlternateExtended == null) {	            cAlternateExtended = new PeriodFormatterBuilder()	                .appendLiteral("P")	                .printZeroAlways()	                .minimumPrintedDigits(4)	                .appendYears()	                .appendSeparator("-")	                .minimumPrintedDigits(2)	                .appendMonths()	                .appendSeparator("-")	                .appendDays()	                .appendSeparatorIfFieldsAfter("T")	                .appendHours()	                .appendSeparator(":")	                .appendMinutes()	                .appendSeparator(":")	                .appendSecondsWithOptionalMillis()	                .toFormatter();	        }	        return cAlternateExtended;	    }	
/**	     * The alternate ISO format, PyyyyWwwddThhmmss, which excludes months.	     * <p>	     * Even if months are present in the period, they are not output.	     * Fractional seconds (milliseconds) will appear if required.	     * 	     * @return the formatter	     */	    public static PeriodFormatter alternateWithWeeks() {	        if (cAlternateWithWeeks == null) {	            cAlternateWithWeeks = new PeriodFormatterBuilder()	                .appendLiteral("P")	                .printZeroAlways()	                .minimumPrintedDigits(4)	                .appendYears()	                .minimumPrintedDigits(2)	                .appendPrefix("W")	                .appendWeeks()	                .appendDays()	                .appendSeparatorIfFieldsAfter("T")	                .appendHours()	                .appendMinutes()	                .appendSecondsWithOptionalMillis()	                .toFormatter();	        }	        return cAlternateWithWeeks;	    }	
/**	     * The alternate ISO format, Pyyyy-Www-ddThh:mm:ss, which excludes months.	     * <p>	     * Even if months are present in the period, they are not output.	     * Fractional seconds (milliseconds) will appear if required.	     * 	     * @return the formatter	     */	    public static PeriodFormatter alternateExtendedWithWeeks() {	        if (cAlternateExtendedWihWeeks == null) {	            cAlternateExtendedWihWeeks = new PeriodFormatterBuilder()	                .appendLiteral("P")	                .printZeroAlways()	                .minimumPrintedDigits(4)	                .appendYears()	                .appendSeparator("-")	                .minimumPrintedDigits(2)	                .appendPrefix("W")	                .appendWeeks()	                .appendSeparator("-")	                .appendDays()	                .appendSeparatorIfFieldsAfter("T")	                .appendHours()	                .appendSeparator(":")	                .appendMinutes()	                .appendSeparator(":")	                .appendSecondsWithOptionalMillis()	                .toFormatter();	        }	        return cAlternateExtendedWihWeeks;	    }	
/**	     * Restricted constructor.	     */	    private FormatUtils() {	    }	
/**	     * Converts an integer to a string, prepended with a variable amount of '0'	     * pad characters, and appends it to the given buffer.	     *	     * <p>This method is optimized for converting small values to strings.	     *	     * @param buf receives integer converted to a string	     * @param value value to convert to a string	     * @param size minumum amount of digits to append	     */	    public static void appendPaddedInteger(StringBuffer buf, int value, int size) {	        if (value < 0) {	            buf.append('-');	            if (value != Integer.MIN_VALUE) {	                value = -value;	            } else {	                for (; size > 10; size--) {	                    buf.append('0');	                }	                buf.append("" + -(long)Integer.MIN_VALUE);	                return;	            }	        }	        if (value < 10) {	            for (; size > 1; size--) {	                buf.append('0');	            }	            buf.append((char)(value + '0'));	        } else if (value < 100) {	            for (; size > 2; size--) {	                buf.append('0');	            }	            // Calculate value div/mod by 10 without using two expensive	            // division operations. (2 ^ 27) / 10 = 13421772. Add one to	            // value to correct rounding error.	            int d = ((value + 1) * 13421772) >> 27;	            buf.append((char) (d + '0'));	            // Append remainder by calculating (value - d * 10).	            buf.append((char) (value - (d << 3) - (d << 1) + '0'));	        } else {	            int digits;	            if (value < 1000) {	                digits = 3;	            } else if (value < 10000) {	                digits = 4;	            } else {	                digits = (int)(Math.log(value) / LOG_10) + 1;	            }	            for (; size > digits; size--) {	                buf.append('0');	            }	            buf.append(Integer.toString(value));	        }	    }	
/**	     * Converts an integer to a string, prepended with a variable amount of '0'	     * pad characters, and appends it to the given buffer.	     *	     * <p>This method is optimized for converting small values to strings.	     *	     * @param buf receives integer converted to a string	     * @param value value to convert to a string	     * @param size minumum amount of digits to append	     */	    public static void appendPaddedInteger(StringBuffer buf, long value, int size) {	        int intValue = (int)value;	        if (intValue == value) {	            appendPaddedInteger(buf, intValue, size);	        } else if (size <= 19) {	            buf.append(Long.toString(value));	        } else {	            if (value < 0) {	                buf.append('-');	                if (value != Long.MIN_VALUE) {	                    value = -value;	                } else {	                    for (; size > 19; size--) {	                        buf.append('0');	                    }	                    buf.append("9223372036854775808");	                    return;	                }	            }	            int digits = (int)(Math.log(value) / LOG_10) + 1;	            for (; size > digits; size--) {	                buf.append('0');	            }	            buf.append(Long.toString(value));	        }	    }	
/**	     * Converts an integer to a string, prepended with a variable amount of '0'	     * pad characters, and writes it to the given writer.	     *	     * <p>This method is optimized for converting small values to strings.	     *	     * @param out receives integer converted to a string	     * @param value value to convert to a string	     * @param size minumum amount of digits to append	     */	    public static void writePaddedInteger(Writer out, int value, int size)	        throws IOException	    {	        if (value < 0) {	            out.write('-');	            if (value != Integer.MIN_VALUE) {	                value = -value;	            } else {	                for (; size > 10; size--) {	                    out.write('0');	                }	                out.write("" + -(long)Integer.MIN_VALUE);	                return;	            }	        }	        if (value < 10) {	            for (; size > 1; size--) {	                out.write('0');	            }	            out.write(value + '0');	        } else if (value < 100) {	            for (; size > 2; size--) {	                out.write('0');	            }	            // Calculate value div/mod by 10 without using two expensive	            // division operations. (2 ^ 27) / 10 = 13421772. Add one to	            // value to correct rounding error.	            int d = ((value + 1) * 13421772) >> 27;	            out.write(d + '0');	            // Append remainder by calculating (value - d * 10).	            out.write(value - (d << 3) - (d << 1) + '0');	        } else {	            int digits;	            if (value < 1000) {	                digits = 3;	            } else if (value < 10000) {	                digits = 4;	            } else {	                digits = (int)(Math.log(value) / LOG_10) + 1;	            }	            for (; size > digits; size--) {	                out.write('0');	            }	            out.write(Integer.toString(value));	        }	    }	
/**	     * Converts an integer to a string, prepended with a variable amount of '0'	     * pad characters, and writes it to the given writer.	     *	     * <p>This method is optimized for converting small values to strings.	     *	     * @param out receives integer converted to a string	     * @param value value to convert to a string	     * @param size minumum amount of digits to append	     */	    public static void writePaddedInteger(Writer out, long value, int size)	        throws IOException	    {	        int intValue = (int)value;	        if (intValue == value) {	            writePaddedInteger(out, intValue, size);	        } else if (size <= 19) {	            out.write(Long.toString(value));	        } else {	            if (value < 0) {	                out.write('-');	                if (value != Long.MIN_VALUE) {	                    value = -value;	                } else {	                    for (; size > 19; size--) {	                        out.write('0');	                    }	                    out.write("9223372036854775808");	                    return;	                }	            }	            int digits = (int)(Math.log(value) / LOG_10) + 1;	            for (; size > digits; size--) {	                out.write('0');	            }	            out.write(Long.toString(value));	        }	    }	
/**	     * Converts an integer to a string, and appends it to the given buffer.	     *	     * <p>This method is optimized for converting small values to strings.	     *	     * @param buf receives integer converted to a string	     * @param value value to convert to a string	     */	    public static void appendUnpaddedInteger(StringBuffer buf, int value) {	        if (value < 0) {	            buf.append('-');	            if (value != Integer.MIN_VALUE) {	                value = -value;	            } else {	                buf.append("" + -(long)Integer.MIN_VALUE);	                return;	            }	        }	        if (value < 10) {	            buf.append((char)(value + '0'));	        } else if (value < 100) {	            // Calculate value div/mod by 10 without using two expensive	            // division operations. (2 ^ 27) / 10 = 13421772. Add one to	            // value to correct rounding error.	            int d = ((value + 1) * 13421772) >> 27;	            buf.append((char) (d + '0'));	            // Append remainder by calculating (value - d * 10).	            buf.append((char) (value - (d << 3) - (d << 1) + '0'));	        } else {	            buf.append(Integer.toString(value));	        }	    }	
/**	     * Converts an integer to a string, and appends it to the given buffer.	     *	     * <p>This method is optimized for converting small values to strings.	     *	     * @param buf receives integer converted to a string	     * @param value value to convert to a string	     */	    public static void appendUnpaddedInteger(StringBuffer buf, long value) {	        int intValue = (int)value;	        if (intValue == value) {	            appendUnpaddedInteger(buf, intValue);	        } else {	            buf.append(Long.toString(value));	        }	    }	
/**	     * Converts an integer to a string, and writes it to the given writer.	     *	     * <p>This method is optimized for converting small values to strings.	     *	     * @param out receives integer converted to a string	     * @param value value to convert to a string	     */	    public static void writeUnpaddedInteger(Writer out, int value)	        throws IOException	    {	        if (value < 0) {	            out.write('-');	            if (value != Integer.MIN_VALUE) {	                value = -value;	            } else {	                out.write("" + -(long)Integer.MIN_VALUE);	                return;	            }	        }	        if (value < 10) {	            out.write(value + '0');	        } else if (value < 100) {	            // Calculate value div/mod by 10 without using two expensive	            // division operations. (2 ^ 27) / 10 = 13421772. Add one to	            // value to correct rounding error.	            int d = ((value + 1) * 13421772) >> 27;	            out.write(d + '0');	            // Append remainder by calculating (value - d * 10).	            out.write(value - (d << 3) - (d << 1) + '0');	        } else {	            out.write(Integer.toString(value));	        }	    }	
/**	     * Converts an integer to a string, and writes it to the given writer.	     *	     * <p>This method is optimized for converting small values to strings.	     *	     * @param out receives integer converted to a string	     * @param value value to convert to a string	     */	    public static void writeUnpaddedInteger(Writer out, long value)	        throws IOException	    {	        int intValue = (int)value;	        if (intValue == value) {	            writeUnpaddedInteger(out, intValue);	        } else {	            out.write(Long.toString(value));	        }	    }	
/**	     * Calculates the number of decimal digits for the given value,	     * including the sign.	     */	    public static int calculateDigitCount(long value) {	        if (value < 0) {	            if (value != Long.MIN_VALUE) {	                return calculateDigitCount(-value) + 1;	            } else {	                return 20;	            }	        }	        return 	            (value < 10 ? 1 :	             (value < 100 ? 2 :	              (value < 1000 ? 3 :	               (value < 10000 ? 4 :	                ((int)(Math.log(value) / LOG_10) + 1)))));	    }	
static int parseTwoDigits(String text, int position) {	        int value = text.charAt(position) - '0';	        return ((value << 3) + (value << 1)) + text.charAt(position + 1) - '0';	    }	
static String createErrorMessage(final String text, final int errorPos) {	        int sampleLen = errorPos + 32;	        String sampleText;	        if (text.length() <= sampleLen + 3) {	            sampleText = text;	        } else {	            sampleText = text.substring(0, sampleLen).concat("...");	        }	        	        if (errorPos <= 0) {	            return "Invalid format: \"" + sampleText + '"';	        }	        	        if (errorPos >= text.length()) {	            return "Invalid format: \"" + sampleText + "\" is too short";	        }	        	        return "Invalid format: \"" + sampleText + "\" is malformed at \"" +	            sampleText.substring(errorPos) + '"';	    }	
public PeriodFormatterBuilder() {	        clear();	    }	
/**	     * Constructs a PeriodFormatter using all the appended elements.	     * <p>	     * This is the main method used by applications at the end of the build	     * process to create a usable formatter.	     * <p>	     * Subsequent changes to this builder do not affect the returned formatter.	     * <p>	     * The returned formatter may not support both printing and parsing.	     * The methods {@link PeriodFormatter#isPrinter()} and	     * {@link PeriodFormatter#isParser()} will help you determine the state	     * of the formatter.	     * 	     * @return the newly created formatter	     * @throws IllegalStateException if the builder can produce neither a printer nor a parser	     */	    public PeriodFormatter toFormatter() {	        PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);	        iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();	        return formatter;	    }	
/**	     * Internal method to create a PeriodPrinter instance using all the	     * appended elements.	     * <p>	     * Most applications will not use this method.	     * If you want a printer in an application, call {@link #toFormatter()}	     * and just use the printing API.	     * <p>	     * Subsequent changes to this builder do not affect the returned printer.	     * 	     * @return the newly created printer, null if builder cannot create a printer	     */	    public PeriodPrinter toPrinter() {	        if (iNotPrinter) {	            return null;	        }	        return toFormatter().getPrinter();	    }	
/**	     * Internal method to create a PeriodParser instance using all the	     * appended elements.	     * <p>	     * Most applications will not use this method.	     * If you want a printer in an application, call {@link #toFormatter()}	     * and just use the printing API.	     * <p>	     * Subsequent changes to this builder do not affect the returned parser.	     * 	     * @return the newly created parser, null if builder cannot create a parser	     */	    public PeriodParser toParser() {	        if (iNotParser) {	            return null;	        }	        return toFormatter().getParser();	    }	
/**	     * Clears out all the appended elements, allowing this builder to be reused.	     */	    public void clear() {	        iMinPrintedDigits = 1;	        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;	        iMaxParsedDigits = 10;	        iRejectSignedValues = false;	        iPrefix = null;	        if (iElementPairs == null) {	            iElementPairs = new ArrayList<Object>();	        } else {	            iElementPairs.clear();	        }	        iNotPrinter = false;	        iNotParser = false;	        iFieldFormatters = new FieldFormatter[10];	    }	
/**	     * Appends another formatter.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder append(PeriodFormatter formatter) {	        if (formatter == null) {	            throw new IllegalArgumentException("No formatter supplied");	        }	        clearPrefix();	        append0(formatter.getPrinter(), formatter.getParser());	        return this;	    }	
/**	     * Appends a printer parser pair.	     * <p>	     * Either the printer or the parser may be null, in which case the builder will	     * be unable to produce a parser or printer repectively.	     *	     * @param printer  appends a printer to the builder, null if printing is not supported	     * @param parser  appends a parser to the builder, null if parsing is not supported	     * @return this PeriodFormatterBuilder	     * @throws IllegalArgumentException if both the printer and parser are null	     */	    public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {	        if (printer == null && parser == null) {	            throw new IllegalArgumentException("No printer or parser supplied");	        }	        clearPrefix();	        append0(printer, parser);	        return this;	    }	
/**	     * Instructs the printer to emit specific text, and the parser to expect it.	     * The parser is case-insensitive.	     *	     * @return this PeriodFormatterBuilder	     * @throws IllegalArgumentException if text is null	     */	    public PeriodFormatterBuilder appendLiteral(String text) {	        if (text == null) {	            throw new IllegalArgumentException("Literal must not be null");	        }	        clearPrefix();	        Literal literal = new Literal(text);	        append0(literal, literal);	        return this;	    }	
/**	     * Set the minimum digits printed for the next and following appended	     * fields. By default, the minimum digits printed is one. If the field value	     * is zero, it is not printed unless a printZero rule is applied.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) {	        iMinPrintedDigits = minDigits;	        return this;	    }	
/**	     * Set the maximum digits parsed for the next and following appended	     * fields. By default, the maximum digits parsed is ten.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) {	        iMaxParsedDigits = maxDigits;	        return this;	    }	
/**	     * Reject signed values when parsing the next and following appended fields.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder rejectSignedValues(boolean v) {	        iRejectSignedValues = v;	        return this;	    }	
/**	     * Never print zero values for the next and following appended fields,	     * unless no fields would be printed. If no fields are printed, the printer	     * forces the last "printZeroRarely" field to print a zero.	     * <p>	     * This field setting is the default.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder printZeroRarelyLast() {	        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;	        return this;	    }	
/**	     * Never print zero values for the next and following appended fields,	     * unless no fields would be printed. If no fields are printed, the printer	     * forces the first "printZeroRarely" field to print a zero.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder printZeroRarelyFirst() {	        iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST;	        return this;	    }	
/**	     * Print zero values for the next and following appened fields only if the	     * period supports it.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder printZeroIfSupported() {	        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;	        return this;	    }	
/**	     * Always print zero values for the next and following appended fields,	     * even if the period doesn't support it. The parser requires values for	     * fields that always print zero.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder printZeroAlways() {	        iPrintZeroSetting = PRINT_ZERO_ALWAYS;	        return this;	    }	
/**	     * Never print zero values for the next and following appended fields,	     * unless no fields would be printed. If no fields are printed, the printer	     * forces the last "printZeroRarely" field to print a zero.	     * <p>	     * This field setting is the default.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder printZeroNever() {	        iPrintZeroSetting = PRINT_ZERO_NEVER;	        return this;	    }	
/**	     * Append a field prefix which applies only to the next appended field. If	     * the field is not printed, neither is the prefix.	     *	     * @param text text to print before field only if field is printed	     * @return this PeriodFormatterBuilder	     * @see #appendSuffix	     */	    public PeriodFormatterBuilder appendPrefix(String text) {	        if (text == null) {	            throw new IllegalArgumentException();	        }	        return appendPrefix(new SimpleAffix(text));	    }	
/**	     * Append a field prefix which applies only to the next appended field. If	     * the field is not printed, neither is the prefix.	     * <p>	     * During parsing, the singular and plural versions are accepted whether	     * or not the actual value matches plurality.	     *	     * @param singularText text to print if field value is one	     * @param pluralText text to print if field value is not one	     * @return this PeriodFormatterBuilder	     * @see #appendSuffix	     */	    public PeriodFormatterBuilder appendPrefix(String singularText,	                                                 String pluralText) {	        if (singularText == null || pluralText == null) {	            throw new IllegalArgumentException();	        }	        return appendPrefix(new PluralAffix(singularText, pluralText));	    }	
/**	     * Append a field prefix which applies only to the next appended field. If	     * the field is not printed, neither is the prefix.	     *	     * @param prefix custom prefix	     * @return this PeriodFormatterBuilder	     * @see #appendSuffix	     */	    private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) {	        if (prefix == null) {	            throw new IllegalArgumentException();	        }	        if (iPrefix != null) {	            prefix = new CompositeAffix(iPrefix, prefix);	        }	        iPrefix = prefix;	        return this;	    }	
/**	     * Instruct the printer to emit an integer years field, if supported.	     * <p>	     * The number of printed and parsed digits can be controlled using	     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder appendYears() {	        appendField(YEARS);	        return this;	    }	
/**	     * Instruct the printer to emit an integer months field, if supported.	     * <p>	     * The number of printed and parsed digits can be controlled using	     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder appendMonths() {	        appendField(MONTHS);	        return this;	    }	
/**	     * Instruct the printer to emit an integer weeks field, if supported.	     * <p>	     * The number of printed and parsed digits can be controlled using	     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder appendWeeks() {	        appendField(WEEKS);	        return this;	    }	
/**	     * Instruct the printer to emit an integer days field, if supported.	     * <p>	     * The number of printed and parsed digits can be controlled using	     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder appendDays() {	        appendField(DAYS);	        return this;	    }	
/**	     * Instruct the printer to emit an integer hours field, if supported.	     * <p>	     * The number of printed and parsed digits can be controlled using	     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder appendHours() {	        appendField(HOURS);	        return this;	    }	
/**	     * Instruct the printer to emit an integer minutes field, if supported.	     * <p>	     * The number of printed and parsed digits can be controlled using	     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder appendMinutes() {	        appendField(MINUTES);	        return this;	    }	
/**	     * Instruct the printer to emit an integer seconds field, if supported.	     * <p>	     * The number of printed and parsed digits can be controlled using	     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder appendSeconds() {	        appendField(SECONDS);	        return this;	    }	
/**	     * Instruct the printer to emit a combined seconds and millis field, if supported.	     * The millis will overflow into the seconds if necessary.	     * The millis are always output.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder appendSecondsWithMillis() {	        appendField(SECONDS_MILLIS);	        return this;	    }	
/**	     * Instruct the printer to emit a combined seconds and millis field, if supported.	     * The millis will overflow into the seconds if necessary.	     * The millis are only output if non-zero.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {	        appendField(SECONDS_OPTIONAL_MILLIS);	        return this;	    }	
/**	     * Instruct the printer to emit an integer millis field, if supported.	     * <p>	     * The number of printed and parsed digits can be controlled using	     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder appendMillis() {	        appendField(MILLIS);	        return this;	    }	
/**	     * Instruct the printer to emit an integer millis field, if supported.	     * <p>	     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.	     *	     * @return this PeriodFormatterBuilder	     */	    public PeriodFormatterBuilder appendMillis3Digit() {	        appendField(7, 3);	        return this;	    }	
private void appendField(int type) {	        appendField(type, iMinPrintedDigits);	    }	
private void appendField(int type, int minPrinted) {	        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,	            iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null);	        append0(field, field);	        iFieldFormatters[type] = field;	        iPrefix = null;	    }	
/**	     * Append a field suffix which applies only to the last appended field. If	     * the field is not printed, neither is the suffix.	     *	     * @param text text to print after field only if field is printed	     * @return this PeriodFormatterBuilder	     * @throws IllegalStateException if no field exists to append to	     * @see #appendPrefix	     */	    public PeriodFormatterBuilder appendSuffix(String text) {	        if (text == null) {	            throw new IllegalArgumentException();	        }	        return appendSuffix(new SimpleAffix(text));	    }	
/**	     * Append a field suffix which applies only to the last appended field. If	     * the field is not printed, neither is the suffix.	     * <p>	     * During parsing, the singular and plural versions are accepted whether or	     * not the actual value matches plurality.	     *	     * @param singularText text to print if field value is one	     * @param pluralText text to print if field value is not one	     * @return this PeriodFormatterBuilder	     * @throws IllegalStateException if no field exists to append to	     * @see #appendPrefix	     */	    public PeriodFormatterBuilder appendSuffix(String singularText,	                                               String pluralText) {	        if (singularText == null || pluralText == null) {	            throw new IllegalArgumentException();	        }	        return appendSuffix(new PluralAffix(singularText, pluralText));	    }	
/**	     * Append a field suffix which applies only to the last appended field. If	     * the field is not printed, neither is the suffix.	     *	     * @param suffix custom suffix	     * @return this PeriodFormatterBuilder	     * @throws IllegalStateException if no field exists to append to	     * @see #appendPrefix	     */	    private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {	        final Object originalPrinter;	        final Object originalParser;	        if (iElementPairs.size() > 0) {	            originalPrinter = iElementPairs.get(iElementPairs.size() - 2);	            originalParser = iElementPairs.get(iElementPairs.size() - 1);	        } else {	            originalPrinter = null;	            originalParser = null;	        }		        if (originalPrinter == null || originalParser == null ||	                originalPrinter != originalParser ||	                !(originalPrinter instanceof FieldFormatter)) {	            throw new IllegalStateException("No field to apply suffix to");	        }		        clearPrefix();	        FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);	        iElementPairs.set(iElementPairs.size() - 2, newField);	        iElementPairs.set(iElementPairs.size() - 1, newField);	        iFieldFormatters[newField.getFieldType()] = newField;	        	        return this;	    }	
/**	     * Append a separator, which is output if fields are printed both before	     * and after the separator.	     * <p>	     * For example, <code>builder.appendDays().appendSeparator(",").appendHours()</code>	     * will only output the comma if both the days and hours fields are output.	     * <p>	     * The text will be parsed case-insensitively.	     * <p>	     * Note: appending a separator discontinues any further work on the latest	     * appended field.	     *	     * @param text  the text to use as a separator	     * @return this PeriodFormatterBuilder	     * @throws IllegalStateException if this separator follows a previous one	     */	    public PeriodFormatterBuilder appendSeparator(String text) {	        return appendSeparator(text, text, null, true, true);	    }	
/**	     * Append a separator, which is output only if fields are printed after the separator.	     * <p>	     * For example,	     * <code>builder.appendDays().appendSeparatorIfFieldsAfter(",").appendHours()</code>	     * will only output the comma if the hours fields is output.	     * <p>	     * The text will be parsed case-insensitively.	     * <p>	     * Note: appending a separator discontinues any further work on the latest	     * appended field.	     *	     * @param text  the text to use as a separator	     * @return this PeriodFormatterBuilder	     * @throws IllegalStateException if this separator follows a previous one	     */	    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {	        return appendSeparator(text, text, null, false, true);	    }	
/**	     * Append a separator, which is output only if fields are printed before the separator.	     * <p>	     * For example,	     * <code>builder.appendDays().appendSeparatorIfFieldsBefore(",").appendHours()</code>	     * will only output the comma if the days fields is output.	     * <p>	     * The text will be parsed case-insensitively.	     * <p>	     * Note: appending a separator discontinues any further work on the latest	     * appended field.	     *	     * @param text  the text to use as a separator	     * @return this PeriodFormatterBuilder	     * @throws IllegalStateException if this separator follows a previous one	     */	    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {	        return appendSeparator(text, text, null, true, false);	    }	
/**	     * Append a separator, which is output if fields are printed both before	     * and after the separator.	     * <p>	     * This method changes the separator depending on whether it is the last separator	     * to be output.	     * <p>	     * For example, <code>builder.appendDays().appendSeparator(",", "&").appendHours().appendSeparator(",", "&").appendMinutes()</code>	     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output	     * and '1' if just one field is output.	     * <p>	     * The text will be parsed case-insensitively.	     * <p>	     * Note: appending a separator discontinues any further work on the latest	     * appended field.	     *	     * @param text  the text to use as a separator	     * @param finalText  the text used used if this is the final separator to be printed	     * @return this PeriodFormatterBuilder	     * @throws IllegalStateException if this separator follows a previous one	     */	    public PeriodFormatterBuilder appendSeparator(String text, String finalText) {	        return appendSeparator(text, finalText, null, true, true);	    }	
/**	     * Append a separator, which is output if fields are printed both before	     * and after the separator.	     * <p>	     * This method changes the separator depending on whether it is the last separator	     * to be output.	     * <p>	     * For example, <code>builder.appendDays().appendSeparator(",", "&").appendHours().appendSeparator(",", "&").appendMinutes()</code>	     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output	     * and '1' if just one field is output.	     * <p>	     * The text will be parsed case-insensitively.	     * <p>	     * Note: appending a separator discontinues any further work on the latest	     * appended field.	     *	     * @param text  the text to use as a separator	     * @param finalText  the text used used if this is the final separator to be printed	     * @param variants  set of text values which are also acceptable when parsed	     * @return this PeriodFormatterBuilder	     * @throws IllegalStateException if this separator follows a previous one	     */	    public PeriodFormatterBuilder appendSeparator(String text, String finalText,	                                                  String[] variants) {	        return appendSeparator(text, finalText, variants, true, true);	    }	
private PeriodFormatterBuilder appendSeparator(String text, String finalText,	                                                   String[] variants,	                                                   boolean useBefore, boolean useAfter) {	        if (text == null || finalText == null) {	            throw new IllegalArgumentException();	        }		        clearPrefix();	        	        // optimise zero formatter case	        List<Object> pairs = iElementPairs;	        if (pairs.size() == 0) {	            if (useAfter && useBefore == false) {	                Separator separator = new Separator(	                        text, finalText, variants,	                        Literal.EMPTY, Literal.EMPTY, useBefore, useAfter);	                append0(separator, separator);	            }	            return this;	        }	        	        // find the last separator added	        int i;	        Separator lastSeparator = null;	        for (i=pairs.size(); --i>=0; ) {	            if (pairs.get(i) instanceof Separator) {	                lastSeparator = (Separator) pairs.get(i);	                pairs = pairs.subList(i + 1, pairs.size());	                break;	            }	            i--;  // element pairs	        }	        	        // merge formatters	        if (lastSeparator != null && pairs.size() == 0) {	            throw new IllegalStateException("Cannot have two adjacent separators");	        } else {	            Object[] comp = createComposite(pairs);	            pairs.clear();	            Separator separator = new Separator(	                    text, finalText, variants,	                    (PeriodPrinter) comp[0], (PeriodParser) comp[1],	                    useBefore, useAfter);	            pairs.add(separator);	            pairs.add(separator);	        }	        	        return this;	    }	
private void clearPrefix() throws IllegalStateException {	        if (iPrefix != null) {	            throw new IllegalStateException("Prefix not followed by field");	        }	        iPrefix = null;	    }	
private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {	        iElementPairs.add(printer);	        iElementPairs.add(parser);	        iNotPrinter |= (printer == null);	        iNotParser |= (parser == null);	        return this;	    }	
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {	        if (notPrinter && notParser) {	            throw new IllegalStateException("Builder has created neither a printer nor a parser");	        }	        int size = elementPairs.size();	        if (size >= 2 && elementPairs.get(0) instanceof Separator) {	            Separator sep = (Separator) elementPairs.get(0);	            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {	                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);	                sep = sep.finish(f.getPrinter(), f.getParser());	                return new PeriodFormatter(sep, sep);	            }	        }	        Object[] comp = createComposite(elementPairs);	        if (notPrinter) {	            return new PeriodFormatter(null, (PeriodParser) comp[1]);	        } else if (notParser) {	            return new PeriodFormatter((PeriodPrinter) comp[0], null);	        } else {	            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);	        }	    }	
private static Object[] createComposite(List<Object> elementPairs) {	        switch (elementPairs.size()) {	            case 0:	                return new Object[] {Literal.EMPTY, Literal.EMPTY};	            case 1:	                return new Object[] {elementPairs.get(0), elementPairs.get(1)};	            default:	                Composite comp = new Composite(elementPairs);	                return new Object[] {comp, comp};	        }	    }	
SimpleAffix(String text) {	            iText = text;	        }	
public int calculatePrintedLength(int value) {	            return iText.length();	        }	
public void printTo(StringBuffer buf, int value) {	            buf.append(iText);	        }	
public void printTo(Writer out, int value) throws IOException {	            out.write(iText);	        }	
public int parse(String periodStr, int position) {	            String text = iText;	            int textLength = text.length();	            if (periodStr.regionMatches(true, position, text, 0, textLength)) {	                return position + textLength;	            }	            return ~position;	        }	
public int scan(String periodStr, final int position) {	            String text = iText;	            int textLength = text.length();	            int sourceLength = periodStr.length();	            search:	            for (int pos = position; pos < sourceLength; pos++) {	                if (periodStr.regionMatches(true, pos, text, 0, textLength)) {	                    return pos;	                }	                // Only allow number characters to be skipped in search of suffix.	                switch (periodStr.charAt(pos)) {	                case '0': case '1': case '2': case '3': case '4':	                case '5': case '6': case '7': case '8': case '9':	                case '.': case ',': case '+': case '-':	                    break;	                default:	                    break search;	                }	            }	            return ~position;	        }	
PluralAffix(String singularText, String pluralText) {	            iSingularText = singularText;	            iPluralText = pluralText;	        }	
public int calculatePrintedLength(int value) {	            return (value == 1 ? iSingularText : iPluralText).length();	        }	
public void printTo(StringBuffer buf, int value) {	            buf.append(value == 1 ? iSingularText : iPluralText);	        }	
public void printTo(Writer out, int value) throws IOException {	            out.write(value == 1 ? iSingularText : iPluralText);	        }	
public int parse(String periodStr, int position) {	            String text1 = iPluralText;	            String text2 = iSingularText; 		            if (text1.length() < text2.length()) {	                // Swap in order to match longer one first.	                String temp = text1;	                text1 = text2;	                text2 = temp;	            }		            if (periodStr.regionMatches	                (true, position, text1, 0, text1.length())) {	                return position + text1.length();	            }	            if (periodStr.regionMatches	                (true, position, text2, 0, text2.length())) {	                return position + text2.length();	            }		            return ~position;	        }	
public int scan(String periodStr, final int position) {	            String text1 = iPluralText;	            String text2 = iSingularText; 		            if (text1.length() < text2.length()) {	                // Swap in order to match longer one first.	                String temp = text1;	                text1 = text2;	                text2 = temp;	            }		            int textLength1 = text1.length();	            int textLength2 = text2.length();		            int sourceLength = periodStr.length();	            for (int pos = position; pos < sourceLength; pos++) {	                if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) {	                    return pos;	                }	                if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) {	                    return pos;	                }	            }	            return ~position;	        }	
CompositeAffix(PeriodFieldAffix left, PeriodFieldAffix right) {	            iLeft = left;	            iRight = right;	        }	
public int calculatePrintedLength(int value) {	            return iLeft.calculatePrintedLength(value)	                + iRight.calculatePrintedLength(value);	        }	
public void printTo(StringBuffer buf, int value) {	            iLeft.printTo(buf, value);	            iRight.printTo(buf, value);	        }	
public void printTo(Writer out, int value) throws IOException {	            iLeft.printTo(out, value);	            iRight.printTo(out, value);	        }	
public int parse(String periodStr, int position) {	            position = iLeft.parse(periodStr, position);	            if (position >= 0) {	                position = iRight.parse(periodStr, position);	            }	            return position;	        }	
public int scan(String periodStr, final int position) {	            int pos = iLeft.scan(periodStr, position);	            if (pos >= 0) {	                return iRight.scan(periodStr, pos);	            }	            return ~position;	        }	
FieldFormatter(int minPrintedDigits, int printZeroSetting,	                       int maxParsedDigits, boolean rejectSignedValues,	                       int fieldType, FieldFormatter[] fieldFormatters,	                       PeriodFieldAffix prefix, PeriodFieldAffix suffix) {	            iMinPrintedDigits = minPrintedDigits;	            iPrintZeroSetting = printZeroSetting;	            iMaxParsedDigits = maxParsedDigits;	            iRejectSignedValues = rejectSignedValues;	            iFieldType = fieldType;	            iFieldFormatters = fieldFormatters;	            iPrefix = prefix;	            iSuffix = suffix;	        }	
FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {	            iMinPrintedDigits = field.iMinPrintedDigits;	            iPrintZeroSetting = field.iPrintZeroSetting;	            iMaxParsedDigits = field.iMaxParsedDigits;	            iRejectSignedValues = field.iRejectSignedValues;	            iFieldType = field.iFieldType;	            iFieldFormatters = field.iFieldFormatters;	            iPrefix = field.iPrefix;	            if (field.iSuffix != null) {	                suffix = new CompositeAffix(field.iSuffix, suffix);	            }	            iSuffix = suffix;	        }	
public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {	            if (stopAt <= 0) {	                return 0;	            }	            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) {	                return 1;	            }	            return 0;	        }	
public int calculatePrintedLength(ReadablePeriod period, Locale locale) {	            long valueLong = getFieldValue(period);	            if (valueLong == Long.MAX_VALUE) {	                return 0;	            }		            int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);	            if (iFieldType >= SECONDS_MILLIS) {	                // valueLong contains the seconds and millis fields	                // the minimum output is 0.000, which is 4 digits	                sum = Math.max(sum, 4);	                // plus one for the decimal point	                sum++;	                if (iFieldType == SECONDS_OPTIONAL_MILLIS &&	                        (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {	                    sum -= 4; // remove three digits and decimal point	                }	                // reset valueLong to refer to the seconds part for the prefic/suffix calculation	                valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;	            }	            int value = (int) valueLong;		            if (iPrefix != null) {	                sum += iPrefix.calculatePrintedLength(value);	            }	            if (iSuffix != null) {	                sum += iSuffix.calculatePrintedLength(value);	            }		            return sum;	        }	
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {	            long valueLong = getFieldValue(period);	            if (valueLong == Long.MAX_VALUE) {	                return;	            }	            int value = (int) valueLong;	            if (iFieldType >= SECONDS_MILLIS) {	                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);	            }		            if (iPrefix != null) {	                iPrefix.printTo(buf, value);	            }	            int minDigits = iMinPrintedDigits;	            if (minDigits <= 1) {	                FormatUtils.appendUnpaddedInteger(buf, value);	            } else {	                FormatUtils.appendPaddedInteger(buf, value, minDigits);	            }	            if (iFieldType >= SECONDS_MILLIS) {	                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);	                if (iFieldType == SECONDS_MILLIS || dp > 0) {	                    buf.append('.');	                    FormatUtils.appendPaddedInteger(buf, dp, 3);	                }	            }	            if (iSuffix != null) {	                iSuffix.printTo(buf, value);	            }	        }	
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {	            long valueLong = getFieldValue(period);	            if (valueLong == Long.MAX_VALUE) {	                return;	            }	            int value = (int) valueLong;	            if (iFieldType >= SECONDS_MILLIS) {	                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);	            }		            if (iPrefix != null) {	                iPrefix.printTo(out, value);	            }	            int minDigits = iMinPrintedDigits;	            if (minDigits <= 1) {	                FormatUtils.writeUnpaddedInteger(out, value);	            } else {	                FormatUtils.writePaddedInteger(out, value, minDigits);	            }	            if (iFieldType >= SECONDS_MILLIS) {	                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);	                if (iFieldType == SECONDS_MILLIS || dp > 0) {	                    out.write('.');	                    FormatUtils.writePaddedInteger(out, dp, 3);	                }	            }	            if (iSuffix != null) {	                iSuffix.printTo(out, value);	            }	        }	
public int parseInto(	                ReadWritablePeriod period, String text, 	                int position, Locale locale) {		            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);		            // Shortcut test.	            if (position >= text.length()) {	                return mustParse ? ~position : position;	            }		            if (iPrefix != null) {	                position = iPrefix.parse(text, position);	                if (position >= 0) {	                    // If prefix is found, then the parse must finish.	                    mustParse = true;	                } else {	                    // Prefix not found, so bail.	                    if (!mustParse) {	                        // It's okay because parsing of this field is not	                        // required. Don't return an error. Fields down the	                        // chain can continue on, trying to parse.	                        return ~position;	                    }	                    return position;	                }	            }		            int suffixPos = -1;	            if (iSuffix != null && !mustParse) {	                // Pre-scan the suffix, to help determine if this field must be	                // parsed.	                suffixPos = iSuffix.scan(text, position);	                if (suffixPos >= 0) {	                    // If suffix is found, then parse must finish.	                    mustParse = true;	                } else {	                    // Suffix not found, so bail.	                    if (!mustParse) {	                        // It's okay because parsing of this field is not	                        // required. Don't return an error. Fields down the	                        // chain can continue on, trying to parse.	                        return ~suffixPos;	                    }	                    return suffixPos;	                }	            }		            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {	                // If parsing is not required and the field is not supported,	                // exit gracefully so that another parser can continue on.	                return position;	            }		            int limit;	            if (suffixPos > 0) {	                limit = Math.min(iMaxParsedDigits, suffixPos - position);	            } else {	                limit = Math.min(iMaxParsedDigits, text.length() - position);	            }		            // validate input number	            int length = 0;	            int fractPos = -1;	            boolean hasDigits = false;	            while (length < limit) {	                char c = text.charAt(position + length);	                // leading sign	                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {	                    boolean negative = c == '-';		                    // Next character must be a digit.	                    if (length + 1 >= limit || 	                        (c = text.charAt(position + length + 1)) < '0' || c > '9')	                    {	                        break;	                    }		                    if (negative) {	                        length++;	                    } else {	                        // Skip the '+' for parseInt to succeed.	                        position++;	                    }	                    // Expand the limit to disregard the sign character.	                    limit = Math.min(limit + 1, text.length() - position);	                    continue;	                }	                // main number	                if (c >= '0' && c <= '9') {	                    hasDigits = true;	                } else {	                    if ((c == '.' || c == ',')	                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {	                        if (fractPos >= 0) {	                            // can't have two decimals	                            break;	                        }	                        fractPos = position + length + 1;	                        // Expand the limit to disregard the decimal point.	                        limit = Math.min(limit + 1, text.length() - position);	                    } else {	                        break;	                    }	                }	                length++;	            }		            if (!hasDigits) {	                return ~position;	            }		            if (suffixPos >= 0 && position + length != suffixPos) {	                // If there are additional non-digit characters before the	                // suffix is reached, then assume that the suffix found belongs	                // to a field not yet reached. Return original position so that	                // another parser can continue on.	                return position;	            }		            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {	                // Handle common case.	                setFieldValue(period, iFieldType, parseInt(text, position, length));	            } else if (fractPos < 0) {	                setFieldValue(period, SECONDS, parseInt(text, position, length));	                setFieldValue(period, MILLIS, 0);	            } else {	                int wholeValue = parseInt(text, position, fractPos - position - 1);	                setFieldValue(period, SECONDS, wholeValue);		                int fractLen = position + length - fractPos;	                int fractValue;	                if (fractLen <= 0) {	                    fractValue = 0;	                } else {	                    if (fractLen >= 3) {	                        fractValue = parseInt(text, fractPos, 3);	                    } else {	                        fractValue = parseInt(text, fractPos, fractLen);	                        if (fractLen == 1) {	                            fractValue *= 100;	                        } else {	                            fractValue *= 10;	                        }	                    }	                    if (wholeValue < 0) {	                        fractValue = -fractValue;	                    }	                }		                setFieldValue(period, MILLIS, fractValue);	            }	                	            position += length;		            if (position >= 0 && iSuffix != null) {	                position = iSuffix.parse(text, position);	            }	                	            return position;	        }	
/**	         * @param text text to parse	         * @param position position in text	         * @param length exact count of characters to parse	         * @return parsed int value	         */	        private int parseInt(String text, int position, int length) {	            if (length >= 10) {	                // Since value may exceed max, use stock parser which checks for this.	                return Integer.parseInt(text.substring(position, position + length));	            }	            if (length <= 0) {	                return 0;	            }	            int value = text.charAt(position++);	            length--;	            boolean negative;	            if (value == '-') {	                if (--length < 0) {	                    return 0;	                }	                negative = true;	                value = text.charAt(position++);	            } else {	                negative = false;	            }	            value -= '0';	            while (length-- > 0) {	                value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0';	            }	            return negative ? -value : value;	        }	
/**	         * @return Long.MAX_VALUE if nothing to print, otherwise value	         */	        long getFieldValue(ReadablePeriod period) {	            PeriodType type;	            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {	                type = null; // Don't need to check if supported.	            } else {	                type = period.getPeriodType();	            }	            if (type != null && isSupported(type, iFieldType) == false) {	                return Long.MAX_VALUE;	            }		            long value;		            switch (iFieldType) {	            default:	                return Long.MAX_VALUE;	            case YEARS:	                value = period.get(DurationFieldType.years());	                break;	            case MONTHS:	                value = period.get(DurationFieldType.months());	                break;	            case WEEKS:	                value = period.get(DurationFieldType.weeks());	                break;	            case DAYS:	                value = period.get(DurationFieldType.days());	                break;	            case HOURS:	                value = period.get(DurationFieldType.hours());	                break;	            case MINUTES:	                value = period.get(DurationFieldType.minutes());	                break;	            case SECONDS:	                value = period.get(DurationFieldType.seconds());	                break;	            case MILLIS:	                value = period.get(DurationFieldType.millis());	                break;	            case SECONDS_MILLIS: // drop through	            case SECONDS_OPTIONAL_MILLIS:	                int seconds = period.get(DurationFieldType.seconds());	                int millis = period.get(DurationFieldType.millis());	                value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;	                break;	            }		            // determine if period is zero and this is the last field	            if (value == 0) {	                switch (iPrintZeroSetting) {	                case PRINT_ZERO_NEVER:	                    return Long.MAX_VALUE;	                case PRINT_ZERO_RARELY_LAST:	                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {	                        for (int i = iFieldType + 1; i <= MAX_FIELD; i++) {	                            if (isSupported(type, i) && iFieldFormatters[i] != null) {	                                return Long.MAX_VALUE;	                            }	                        }	                    } else {	                        return Long.MAX_VALUE;	                    }	                    break;	                case PRINT_ZERO_RARELY_FIRST:	                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {	                        int i = Math.min(iFieldType, 8);  // line split out for IBM JDK	                        i--;                              // see bug 1660490	                        for (; i >= 0 && i <= MAX_FIELD; i--) {	                            if (isSupported(type, i) && iFieldFormatters[i] != null) {	                                return Long.MAX_VALUE;	                            }	                        }	                    } else {	                        return Long.MAX_VALUE;	                    }	                    break;	                }	            }		            return value;	        }	
boolean isZero(ReadablePeriod period) {	            for (int i = 0, isize = period.size(); i < isize; i++) {	                if (period.getValue(i) != 0) {	                    return false;	                }	            }	            return true;	        }	
boolean isSupported(PeriodType type, int field) {	            switch (field) {	            default:	                return false;	            case YEARS:	                return type.isSupported(DurationFieldType.years());	            case MONTHS:	                return type.isSupported(DurationFieldType.months());	            case WEEKS:	                return type.isSupported(DurationFieldType.weeks());	            case DAYS:	                return type.isSupported(DurationFieldType.days());	            case HOURS:	                return type.isSupported(DurationFieldType.hours());	            case MINUTES:	                return type.isSupported(DurationFieldType.minutes());	            case SECONDS:	                return type.isSupported(DurationFieldType.seconds());	            case MILLIS:	                return type.isSupported(DurationFieldType.millis());	            case SECONDS_MILLIS: // drop through	            case SECONDS_OPTIONAL_MILLIS:	                return type.isSupported(DurationFieldType.seconds()) ||	                       type.isSupported(DurationFieldType.millis());	            }	        }	
void setFieldValue(ReadWritablePeriod period, int field, int value) {	            switch (field) {	            default:	                break;	            case YEARS:	                period.setYears(value);	                break;	            case MONTHS:	                period.setMonths(value);	                break;	            case WEEKS:	                period.setWeeks(value);	                break;	            case DAYS:	                period.setDays(value);	                break;	            case HOURS:	                period.setHours(value);	                break;	            case MINUTES:	                period.setMinutes(value);	                break;	            case SECONDS:	                period.setSeconds(value);	                break;	            case MILLIS:	                period.setMillis(value);	                break;	            }	        }	
int getFieldType() {	            return iFieldType;	        }	
Literal(String text) {	            iText = text;	        }	
public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {	            return 0;	        }	
public int calculatePrintedLength(ReadablePeriod period, Locale locale) {	            return iText.length();	        }	
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {	            buf.append(iText);	        }	
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {	            out.write(iText);	        }	
public int parseInto(	                ReadWritablePeriod period, String periodStr,	                int position, Locale locale) {	            if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {	                return position + iText.length();	            }	            return ~position;	        }	
Separator(String text, String finalText, String[] variants,	                PeriodPrinter beforePrinter, PeriodParser beforeParser,	                boolean useBefore, boolean useAfter) {	            iText = text;	            iFinalText = finalText;		            if ((finalText == null || text.equals(finalText)) &&	                (variants == null || variants.length == 0)) {		                iParsedForms = new String[] {text};	            } else {	                // Filter and reverse sort the parsed forms.	                TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);	                parsedSet.add(text);	                parsedSet.add(finalText);	                if (variants != null) {	                    for (int i=variants.length; --i>=0; ) {	                        parsedSet.add(variants[i]);	                    }	                }	                ArrayList<String> parsedList = new ArrayList<String>(parsedSet);	                Collections.reverse(parsedList);	                iParsedForms = parsedList.toArray(new String[parsedList.size()]);	            }		            iBeforePrinter = beforePrinter;	            iBeforeParser = beforeParser;	            iUseBefore = useBefore;	            iUseAfter = useAfter;	        }	
public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {	            int sum = iBeforePrinter.countFieldsToPrint(period, stopAt, locale);	            if (sum < stopAt) {	                sum += iAfterPrinter.countFieldsToPrint(period, stopAt, locale);	            }	            return sum;	        }	
public int calculatePrintedLength(ReadablePeriod period, Locale locale) {	            PeriodPrinter before = iBeforePrinter;	            PeriodPrinter after = iAfterPrinter;	            	            int sum = before.calculatePrintedLength(period, locale)	                    + after.calculatePrintedLength(period, locale);	            	            if (iUseBefore) {	                if (before.countFieldsToPrint(period, 1, locale) > 0) {	                    if (iUseAfter) {	                        int afterCount = after.countFieldsToPrint(period, 2, locale);	                        if (afterCount > 0) {	                            sum += (afterCount > 1 ? iText : iFinalText).length();	                        }	                    } else {	                        sum += iText.length();	                    }	                }	            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {	                sum += iText.length();	            }	            	            return sum;	        }	
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {	            PeriodPrinter before = iBeforePrinter;	            PeriodPrinter after = iAfterPrinter;	            	            before.printTo(buf, period, locale);	            if (iUseBefore) {	                if (before.countFieldsToPrint(period, 1, locale) > 0) {	                    if (iUseAfter) {	                        int afterCount = after.countFieldsToPrint(period, 2, locale);	                        if (afterCount > 0) {	                            buf.append(afterCount > 1 ? iText : iFinalText);	                        }	                    } else {	                        buf.append(iText);	                    }	                }	            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {	                buf.append(iText);	            }	            after.printTo(buf, period, locale);	        }	
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {	            PeriodPrinter before = iBeforePrinter;	            PeriodPrinter after = iAfterPrinter;	            	            before.printTo(out, period, locale);	            if (iUseBefore) {	                if (before.countFieldsToPrint(period, 1, locale) > 0) {	                    if (iUseAfter) {	                        int afterCount = after.countFieldsToPrint(period, 2, locale);	                        if (afterCount > 0) {	                            out.write(afterCount > 1 ? iText : iFinalText);	                        }	                    } else {	                        out.write(iText);	                    }	                }	            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {	                out.write(iText);	            }	            after.printTo(out, period, locale);	        }	
public int parseInto(	                ReadWritablePeriod period, String periodStr,	                int position, Locale locale) {	            int oldPos = position;	            position = iBeforeParser.parseInto(period, periodStr, position, locale);		            if (position < 0) {	                return position;	            }		            boolean found = false;	            if (position > oldPos) {	                // Consume this separator.	                String[] parsedForms = iParsedForms;	                int length = parsedForms.length;	                for (int i=0; i < length; i++) {	                    String parsedForm = parsedForms[i];	                    if ((parsedForm == null || parsedForm.length() == 0) ||	                        periodStr.regionMatches	                        (true, position, parsedForm, 0, parsedForm.length())) {	                        	                        position += parsedForm.length();	                        found = true;	                        break;	                    }	                }	            }		            oldPos = position;	            position = iAfterParser.parseInto(period, periodStr, position, locale);		            if (position < 0) {	                return position;	            }		            if (found && position == oldPos) {	                // Separator should not have been supplied.	                return ~oldPos;	            }		            if (position > oldPos && !found && !iUseBefore) {	                // Separator was required.	                return ~oldPos;	            }		            return position;	        }	
Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {	            iAfterPrinter = afterPrinter;	            iAfterParser = afterParser;	            return this;	        }	
Composite(List<Object> elementPairs) {	            List<Object> printerList = new ArrayList<Object>();	            List<Object> parserList = new ArrayList<Object>();		            decompose(elementPairs, printerList, parserList);		            if (printerList.size() <= 0) {	                iPrinters = null;	            } else {	                iPrinters = printerList.toArray(	                        new PeriodPrinter[printerList.size()]);	            }		            if (parserList.size() <= 0) {	                iParsers = null;	            } else {	                iParsers = parserList.toArray(	                        new PeriodParser[parserList.size()]);	            }	        }	
public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {	            int sum = 0;	            PeriodPrinter[] printers = iPrinters;	            for (int i=printers.length; sum < stopAt && --i>=0; ) {	                sum += printers[i].countFieldsToPrint(period, Integer.MAX_VALUE, locale);	            }	            return sum;	        }	
public int calculatePrintedLength(ReadablePeriod period, Locale locale) {	            int sum = 0;	            PeriodPrinter[] printers = iPrinters;	            for (int i=printers.length; --i>=0; ) {	                sum += printers[i].calculatePrintedLength(period, locale);	            }	            return sum;	        }	
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {	            PeriodPrinter[] printers = iPrinters;	            int len = printers.length;	            for (int i=0; i<len; i++) {	                printers[i].printTo(buf, period, locale);	            }	        }	
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {	            PeriodPrinter[] printers = iPrinters;	            int len = printers.length;	            for (int i=0; i<len; i++) {	                printers[i].printTo(out, period, locale);	            }	        }	
public int parseInto(	                ReadWritablePeriod period, String periodStr,	                int position, Locale locale) {	            PeriodParser[] parsers = iParsers;	            if (parsers == null) {	                throw new UnsupportedOperationException();	            }		            int len = parsers.length;	            for (int i=0; i<len && position >= 0; i++) {	                position = parsers[i].parseInto(period, periodStr, position, locale);	            }	            return position;	        }	
private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {	            int size = elementPairs.size();	            for (int i=0; i<size; i+=2) {	                Object element = elementPairs.get(i);	                if (element instanceof PeriodPrinter) {	                    if (element instanceof Composite) {	                        addArrayToList(printerList, ((Composite) element).iPrinters);	                    } else {	                        printerList.add(element);	                    }	                }		                element = elementPairs.get(i + 1);	                if (element instanceof PeriodParser) {	                    if (element instanceof Composite) {	                        addArrayToList(parserList, ((Composite) element).iParsers);	                    } else {	                        parserList.add(element);	                    }	                }	            }	        }	
private void addArrayToList(List<Object> list, Object[] array) {	            if (array != null) {	                for (int i=0; i<array.length; i++) {	                    list.add(array[i]);	                }	            }	        }	
/**	     * Constructor.	     *	     * @since 1.1 (previously private)	     */	    protected PeriodFormat() {	        super();	    }	
/**	     * Gets the default formatter that outputs words in English.	     * <p>	     * This calls {@link #wordBased(Locale)} using a locale of {@code ENGLISH}.	     * 	     * @return the formatter, not null	     */	    public static PeriodFormatter getDefault() {	        return wordBased(Locale.ENGLISH);	    }	
/**	     * Returns a word based formatter for the JDK default locale.	     * <p>	     * This calls {@link #wordBased(Locale)} using the {@link Locale#getDefault() default locale}.	     * 	     * @return the formatter, not null	     * @since 2.0	     */	    public static PeriodFormatter wordBased() {	        return wordBased(Locale.getDefault());	    }	
/**	     * Returns a word based formatter for the specified locale.	     * <p>	     * The words are configured in a resource bundle text file -	     * {@code org.joda.time.format.messages}.	     * This can be added to via the normal classpath resource bundle mechanisms.	     * <p>	     * Available languages are English, German, Dutch, French, Spanish and Portuguese.	     * 	     * @return the formatter, not null	     * @since 2.0	     */	    public static PeriodFormatter wordBased(Locale locale) {	        PeriodFormatter pf = FORMATTERS.get(locale);	        if (pf == null) {	            ResourceBundle b = ResourceBundle.getBundle(BUNDLE_NAME, locale);	            String[] variants = {	                    b.getString("PeriodFormat.space"), b.getString("PeriodFormat.comma"),	                    b.getString("PeriodFormat.commandand"), b.getString("PeriodFormat.commaspaceand")};	            pf = new PeriodFormatterBuilder()	                .appendYears()	                .appendSuffix(b.getString("PeriodFormat.year"), b.getString("PeriodFormat.years"))	                .appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)	                .appendMonths()	                .appendSuffix(b.getString("PeriodFormat.month"), b.getString("PeriodFormat.months"))	                .appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)	                .appendWeeks()	                .appendSuffix(b.getString("PeriodFormat.week"), b.getString("PeriodFormat.weeks"))	                .appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)	                .appendDays()	                .appendSuffix(b.getString("PeriodFormat.day"), b.getString("PeriodFormat.days"))	                .appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)	                .appendHours()	                .appendSuffix(b.getString("PeriodFormat.hour"), b.getString("PeriodFormat.hours"))	                .appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)	                .appendMinutes()	                .appendSuffix(b.getString("PeriodFormat.minute"), b.getString("PeriodFormat.minutes"))	                .appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)	                .appendSeconds()	                .appendSuffix(b.getString("PeriodFormat.second"), b.getString("PeriodFormat.seconds"))	                .appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)	                .appendMillis()	                .appendSuffix(b.getString("PeriodFormat.millisecond"), b.getString("PeriodFormat.milliseconds"))	                .toFormatter();	            FORMATTERS.putIfAbsent(locale, pf);	        }	        return pf;	    }	
/**	     * Creates a new formatter, however you will normally use the factory	     * or the builder.	     * 	     * @param printer  the internal printer, null if cannot print	     * @param parser  the internal parser, null if cannot parse	     */	    public PeriodFormatter(	            PeriodPrinter printer, PeriodParser parser) {	        super();	        iPrinter = printer;	        iParser = parser;	        iLocale = null;	        iParseType = null;	    }	
/**	     * Constructor.	     * 	     * @param printer  the internal printer, null if cannot print	     * @param parser  the internal parser, null if cannot parse	     * @param locale  the locale to use	     * @param type  the parse period type	     */	    private PeriodFormatter(	            PeriodPrinter printer, PeriodParser parser,	            Locale locale, PeriodType type) {	        super();	        iPrinter = printer;	        iParser = parser;	        iLocale = locale;	        iParseType = type;	    }	
/**	     * Is this formatter capable of printing.	     * 	     * @return true if this is a printer	     */	    public boolean isPrinter() {	        return (iPrinter != null);	    }	
/**	     * Gets the internal printer object that performs the real printing work.	     * 	     * @return the internal printer	     */	    public PeriodPrinter getPrinter() {	        return iPrinter;	    }	
/**	     * Is this formatter capable of parsing.	     * 	     * @return true if this is a parser	     */	    public boolean isParser() {	        return (iParser != null);	    }	
/**	     * Gets the internal parser object that performs the real parsing work.	     * 	     * @return the internal parser	     */	    public PeriodParser getParser() {	        return iParser;	    }	
/**	     * Returns a new formatter with a different locale that will be used	     * for printing and parsing.	     * <p>	     * A PeriodFormatter is immutable, so a new instance is returned,	     * and the original is unaltered and still usable.	     * 	     * @param locale  the locale to use	     * @return the new formatter	     */	    public PeriodFormatter withLocale(Locale locale) {	        if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {	            return this;	        }	        return new PeriodFormatter(iPrinter, iParser, locale, iParseType);	    }	
/**	     * Gets the locale that will be used for printing and parsing.	     * 	     * @return the locale to use	     */	    public Locale getLocale() {	        return iLocale;	    }	
/**	     * Returns a new formatter with a different PeriodType for parsing.	     * <p>	     * A PeriodFormatter is immutable, so a new instance is returned,	     * and the original is unaltered and still usable.	     * 	     * @param type  the type to use in parsing	     * @return the new formatter	     */	    public PeriodFormatter withParseType(PeriodType type) {	        if (type == iParseType) {	            return this;	        }	        return new PeriodFormatter(iPrinter, iParser, iLocale, type);	    }	
/**	     * Gets the PeriodType that will be used for parsing.	     * 	     * @return the parse type to use	     */	    public PeriodType getParseType() {	        return iParseType;	    }	
/**	     * Prints a ReadablePeriod to a StringBuffer.	     *	     * @param buf  the formatted period is appended to this buffer	     * @param period  the period to format, not null	     */	    public void printTo(StringBuffer buf, ReadablePeriod period) {	        checkPrinter();	        checkPeriod(period);	        	        getPrinter().printTo(buf, period, iLocale);	    }	
/**	     * Prints a ReadablePeriod to a Writer.	     *	     * @param out  the formatted period is written out	     * @param period  the period to format, not null	     */	    public void printTo(Writer out, ReadablePeriod period) throws IOException {	        checkPrinter();	        checkPeriod(period);	        	        getPrinter().printTo(out, period, iLocale);	    }	
/**	     * Prints a ReadablePeriod to a new String.	     *	     * @param period  the period to format, not null	     * @return the printed result	     */	    public String print(ReadablePeriod period) {	        checkPrinter();	        checkPeriod(period);	        	        PeriodPrinter printer = getPrinter();	        StringBuffer buf = new StringBuffer(printer.calculatePrintedLength(period, iLocale));	        printer.printTo(buf, period, iLocale);	        return buf.toString();	    }	
/**	     * Checks whether printing is supported.	     * 	     * @throws UnsupportedOperationException if printing is not supported	     */	    private void checkPrinter() {	        if (iPrinter == null) {	            throw new UnsupportedOperationException("Printing not supported");	        }	    }	
/**	     * Checks whether the period is non-null.	     * 	     * @throws IllegalArgumentException if the period is null	     */	    private void checkPeriod(ReadablePeriod period) {	        if (period == null) {	            throw new IllegalArgumentException("Period must not be null");	        }	    }	
/**	     * Parses a period from the given text, at the given position, saving the	     * result into the fields of the given ReadWritablePeriod. If the parse	     * succeeds, the return value is the new text position. Note that the parse	     * may succeed without fully reading the text.	     * <p>	     * The parse type of the formatter is not used by this method.	     * <p>	     * If it fails, the return value is negative, but the period may still be	     * modified. To determine the position where the parse failed, apply the	     * one's complement operator (~) on the return value.	     *	     * @param period  a period that will be modified	     * @param text  text to parse	     * @param position position to start parsing from	     * @return new position, if negative, parse failed. Apply complement	     * operator (~) to get position of failure	     * @throws IllegalArgumentException if any field is out of range	     */	    public int parseInto(ReadWritablePeriod period, String text, int position) {	        checkParser();	        checkPeriod(period);	        	        return getParser().parseInto(period, text, position, iLocale);	    }	
/**	     * Parses a period from the given text, returning a new Period.	     *	     * @param text  text to parse	     * @return parsed value in a Period object	     * @throws IllegalArgumentException if any field is out of range	     */	    public Period parsePeriod(String text) {	        checkParser();	        	        return parseMutablePeriod(text).toPeriod();	    }	
/**	     * Parses a period from the given text, returning a new MutablePeriod.	     *	     * @param text  text to parse	     * @return parsed value in a MutablePeriod object	     * @throws IllegalArgumentException if any field is out of range	     */	    public MutablePeriod parseMutablePeriod(String text) {	        checkParser();	        	        MutablePeriod period = new MutablePeriod(0, iParseType);	        int newPos = getParser().parseInto(period, text, 0, iLocale);	        if (newPos >= 0) {	            if (newPos >= text.length()) {	                return period;	            }	        } else {	            newPos = ~newPos;	        }	        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));	    }	
/**	     * Checks whether parsing is supported.	     * 	     * @throws UnsupportedOperationException if parsing is not supported	     */	    private void checkParser() {	        if (iParser == null) {	            throw new UnsupportedOperationException("Parsing not supported");	        }	    }	
/**	     * Constructs an interval from a start and end instant.	     * 	     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.	     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.	     * @param chrono  the chronology to use, null is ISO default	     * @throws IllegalArgumentException if the end is before the start	     */	    protected BaseInterval(long startInstant, long endInstant, Chronology chrono) {	        super();	        iChronology = DateTimeUtils.getChronology(chrono);	        checkInterval(startInstant, endInstant);	        iStartMillis = startInstant;	        iEndMillis = endInstant;	    }	
/**	     * Constructs an interval from a start and end instant.	     * 	     * @param start  start of this interval, null means now	     * @param end  end of this interval, null means now	     * @throws IllegalArgumentException if the end is before the start	     */	    protected BaseInterval(ReadableInstant start, ReadableInstant end) {	        super();	        if (start == null && end == null) {	            iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis();	            iChronology = ISOChronology.getInstance();	        } else {	            iChronology = DateTimeUtils.getInstantChronology(start);	            iStartMillis = DateTimeUtils.getInstantMillis(start);	            iEndMillis = DateTimeUtils.getInstantMillis(end);	            checkInterval(iStartMillis, iEndMillis);	        }	    }	
/**	     * Constructs an interval from a start instant and a duration.	     * 	     * @param start  start of this interval, null means now	     * @param duration  the duration of this interval, null means zero length	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the end instant exceeds the capacity of a long	     */	    protected BaseInterval(ReadableInstant start, ReadableDuration duration) {	        super();	        iChronology = DateTimeUtils.getInstantChronology(start);	        iStartMillis = DateTimeUtils.getInstantMillis(start);	        long durationMillis = DateTimeUtils.getDurationMillis(duration);	        iEndMillis = FieldUtils.safeAdd(iStartMillis, durationMillis);	        checkInterval(iStartMillis, iEndMillis);	    }	
/**	     * Constructs an interval from a millisecond duration and an end instant.	     * 	     * @param duration  the duration of this interval, null means zero length	     * @param end  end of this interval, null means now	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the start instant exceeds the capacity of a long	     */	    protected BaseInterval(ReadableDuration duration, ReadableInstant end) {	        super();	        iChronology = DateTimeUtils.getInstantChronology(end);	        iEndMillis = DateTimeUtils.getInstantMillis(end);	        long durationMillis = DateTimeUtils.getDurationMillis(duration);	        iStartMillis = FieldUtils.safeAdd(iEndMillis, -durationMillis);	        checkInterval(iStartMillis, iEndMillis);	    }	
/**	     * Constructs an interval from a start instant and a time period.	     * <p>	     * When forming the interval, the chronology from the instant is used	     * if present, otherwise the chronology of the period is used.	     * 	     * @param start  start of this interval, null means now	     * @param period  the period of this interval, null means zero length	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the end instant exceeds the capacity of a long	     */	    protected BaseInterval(ReadableInstant start, ReadablePeriod period) {	        super();	        Chronology chrono = DateTimeUtils.getInstantChronology(start);	        iChronology = chrono;	        iStartMillis = DateTimeUtils.getInstantMillis(start);	        if (period == null) {	            iEndMillis = iStartMillis;	        } else {	            iEndMillis = chrono.add(period, iStartMillis, 1);	        }	        checkInterval(iStartMillis, iEndMillis);	    }	
/**	     * Constructs an interval from a time period and an end instant.	     * <p>	     * When forming the interval, the chronology from the instant is used	     * if present, otherwise the chronology of the period is used.	     * 	     * @param period  the period of this interval, null means zero length	     * @param end  end of this interval, null means now	     * @throws IllegalArgumentException if the end is before the start	     * @throws ArithmeticException if the start instant exceeds the capacity of a long	     */	    protected BaseInterval(ReadablePeriod period, ReadableInstant end) {	        super();	        Chronology chrono = DateTimeUtils.getInstantChronology(end);	        iChronology = chrono;	        iEndMillis = DateTimeUtils.getInstantMillis(end);	        if (period == null) {	            iStartMillis = iEndMillis;	        } else {	            iStartMillis = chrono.add(period, iEndMillis, -1);	        }	        checkInterval(iStartMillis, iEndMillis);	    }	
/**	     * Constructs a time interval converting or copying from another object	     * that describes an interval.	     * 	     * @param interval  the time interval to copy	     * @param chrono  the chronology to use, null means let converter decide	     * @throws IllegalArgumentException if the interval is invalid	     */	    protected BaseInterval(Object interval, Chronology chrono) {	        super();	        IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval);	        if (converter.isReadableInterval(interval, chrono)) {	            ReadableInterval input = (ReadableInterval) interval;	            iChronology = (chrono != null ? chrono : input.getChronology());	            iStartMillis = input.getStartMillis();	            iEndMillis = input.getEndMillis();	        } else if (this instanceof ReadWritableInterval) {	            converter.setInto((ReadWritableInterval) this, interval, chrono);	        } else {	            MutableInterval mi = new MutableInterval();	            converter.setInto(mi, interval, chrono);	            iChronology = mi.getChronology();	            iStartMillis = mi.getStartMillis();	            iEndMillis = mi.getEndMillis();	        }	        checkInterval(iStartMillis, iEndMillis);	    }	
/**	     * Gets the chronology of this interval.	     *	     * @return the chronology	     */	    public Chronology getChronology() {	        return iChronology;	    }	
/**	     * Gets the start of this time interval which is inclusive.	     *	     * @return the start of the time interval,	     *  millisecond instant from 1970-01-01T00:00:00Z	     */	    public long getStartMillis() {	        return iStartMillis;	    }	
/**	     * Gets the end of this time interval which is exclusive.	     *	     * @return the end of the time interval,	     *  millisecond instant from 1970-01-01T00:00:00Z	     */	    public long getEndMillis() {	        return iEndMillis;	    }	
/**	     * Sets this interval from two millisecond instants and a chronology.	     *	     * @param startInstant  the start of the time interval	     * @param endInstant  the start of the time interval	     * @param chrono  the chronology, not null	     * @throws IllegalArgumentException if the end is before the start	     */	    protected void setInterval(long startInstant, long endInstant, Chronology chrono) {	        checkInterval(startInstant, endInstant);	        iStartMillis = startInstant;	        iEndMillis = endInstant;	        iChronology = DateTimeUtils.getChronology(chrono);	    }	
/**	     * Constructor.	     */	    protected AbstractInstant() {	        super();	    }	
/**	     * Gets the time zone of the instant from the chronology.	     * 	     * @return the DateTimeZone that the instant is using, never null	     */	    public DateTimeZone getZone() {	        return getChronology().getZone();	    }	
/**	     * Get the value of one of the fields of a datetime using the chronology of the instant.	     * <p>	     * This method uses the chronology of the instant to obtain the value.	     * For example:	     * <pre>	     * DateTime dt = new DateTime();	     * int year = dt.get(DateTimeFieldType.year());	     * </pre>	     *	     * @param type  a field type, usually obtained from DateTimeFieldType, not null	     * @return the value of that field	     * @throws IllegalArgumentException if the field type is null	     */	    public int get(DateTimeFieldType type) {	        if (type == null) {	            throw new IllegalArgumentException("The DateTimeFieldType must not be null");	        }	        return type.getField(getChronology()).get(getMillis());	    }	
/**	     * Checks if the field type specified is supported by this instant and chronology.	     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.	     *	     * @param type  a field type, usually obtained from DateTimeFieldType	     * @return true if the field type is supported	     */	    public boolean isSupported(DateTimeFieldType type) {	        if (type == null) {	            return false;	        }	        return type.getField(getChronology()).isSupported();	    }	
/**	     * Get the value of one of the fields of a datetime.	     * <p>	     * This could be used to get a field using a different Chronology.	     * For example:	     * <pre>	     * Instant dt = new Instant();	     * int gjYear = dt.get(Chronology.getCoptic().year());	     * </pre>	     * 	     * @param field  the DateTimeField to use, not null	     * @return the value	     * @throws IllegalArgumentException if the field is null	     */	    public int get(DateTimeField field) {	        if (field == null) {	            throw new IllegalArgumentException("The DateTimeField must not be null");	        }	        return field.get(getMillis());	    }	
/**	     * Get this object as an Instant.	     * 	     * @return an Instant using the same millis	     */	    public Instant toInstant() {	        return new Instant(getMillis());	    }	
/**	     * Get this object as a DateTime in the same zone.	     *	     * @return a DateTime using the same millis	     */	    public DateTime toDateTime() {	        return new DateTime(getMillis(), getZone());	    }	
/**	     * Get this object as a DateTime using ISOChronology in the same zone.	     *	     * @return a DateTime using the same millis with ISOChronology	     */	    public DateTime toDateTimeISO() {	        return new DateTime(getMillis(), ISOChronology.getInstance(getZone()));	    }	
/**	     * Get this object as a DateTime using the same chronology but a different zone.	     * 	     * @param zone time zone to apply, or default if null	     * @return a DateTime using the same millis	     */	    public DateTime toDateTime(DateTimeZone zone) {	        Chronology chrono = DateTimeUtils.getChronology(getChronology());	        chrono = chrono.withZone(zone);	        return new DateTime(getMillis(), chrono);	    }	
/**	     * Get this object as a DateTime using the given chronology and its zone.	     * 	     * @param chronology chronology to apply, or ISOChronology if null	     * @return a DateTime using the same millis	     */	    public DateTime toDateTime(Chronology chronology) {	        return new DateTime(getMillis(), chronology);	    }	
/**	     * Get this object as a MutableDateTime in the same zone.	     *	     * @return a MutableDateTime using the same millis	     */	    public MutableDateTime toMutableDateTime() {	        return new MutableDateTime(getMillis(), getZone());	    }	
/**	     * Get this object as a MutableDateTime using ISOChronology in the same zone.	     *	     * @return a MutableDateTime using the same millis with ISOChronology	     */	    public MutableDateTime toMutableDateTimeISO() {	        return new MutableDateTime(getMillis(), ISOChronology.getInstance(getZone()));	    }	
/**	     * Get this object as a MutableDateTime using the same chronology but a different zone.	     * 	     * @param zone time zone to apply, or default if null	     * @return a MutableDateTime using the same millis	     */	    public MutableDateTime toMutableDateTime(DateTimeZone zone) {	        Chronology chrono = DateTimeUtils.getChronology(getChronology());	        chrono = chrono.withZone(zone);	        return new MutableDateTime(getMillis(), chrono);	    }	
/**	     * Get this object as a MutableDateTime using the given chronology and its zone.	     * 	     * @param chronology chronology to apply, or ISOChronology if null	     * @return a MutableDateTime using the same millis	     */	    public MutableDateTime toMutableDateTime(Chronology chronology) {	        return new MutableDateTime(getMillis(), chronology);	    }	
/**	     * Get the date time as a <code>java.util.Date</code>.	     * <p>	     * The <code>Date</code> object created has exactly the same millisecond	     * instant as this object.	     *	     * @return a Date initialised with this datetime	     */	    public Date toDate() {	        return new Date(getMillis());	    }	
/**	     * Compares this object with the specified object for equality based	     * on the millisecond instant, chronology and time zone.	     * <p>	     * Two objects which represent the same instant in time, but are in	     * different time zones (based on time zone id), will be considered to	     * be different. Only two objects with the same {@link DateTimeZone},	     * {@link Chronology} and instant are equal.	     * <p>	     * See {@link #isEqual(ReadableInstant)} for an equals method that	     * ignores the Chronology and time zone.	     * <p>	     * All ReadableInstant instances are accepted.	     *	     * @param readableInstant  a readable instant to check against	     * @return true if millisecond and chronology are equal, false if	     *  not or the instant is null or of an incorrect type	     */	    public boolean equals(Object readableInstant) {	        // must be to fulfil ReadableInstant contract	        if (this == readableInstant) {	            return true;	        }	        if (readableInstant instanceof ReadableInstant == false) {	            return false;	        }	        ReadableInstant otherInstant = (ReadableInstant) readableInstant;	        return	            getMillis() == otherInstant.getMillis() &&	            FieldUtils.equals(getChronology(), otherInstant.getChronology());	    }	
/**	     * Gets a hash code for the instant as defined in <code>ReadableInstant</code>.	     *	     * @return a suitable hash code	     */	    public int hashCode() {	        // must be to fulfil ReadableInstant contract	        return	            ((int) (getMillis() ^ (getMillis() >>> 32))) +	            (getChronology().hashCode());	    }	
/**	     * Compares this object with the specified object for ascending	     * millisecond instant order. This ordering is inconsistent with	     * equals, as it ignores the Chronology.	     * <p>	     * All ReadableInstant instances are accepted.	     *	     * @param other  a readable instant to check against	     * @return negative value if this is less, 0 if equal, or positive value if greater	     * @throws NullPointerException if the object is null	     * @throws ClassCastException if the object type is not supported	     */	    public int compareTo(ReadableInstant other) {	        if (this == other) {	            return 0;	        }	        	        long otherMillis = other.getMillis();	        long thisMillis = getMillis();	        	        // cannot do (thisMillis - otherMillis) as can overflow	        if (thisMillis == otherMillis) {	            return 0;	        }	        if (thisMillis < otherMillis) {	            return -1;	        } else {	            return 1;	        }	    }	
/**	     * Is this instant after the millisecond instant passed in	     * comparing solely by millisecond.	     *	     * @param instant  a millisecond instant to check against	     * @return true if this instant is after the instant passed in	     */	    public boolean isAfter(long instant) {	        return (getMillis() > instant);	    }	
/**	     * Is this instant after the current instant	     * comparing solely by millisecond.	     * 	     * @return true if this instant is after the current instant	     */	    public boolean isAfterNow() {	        return isAfter(DateTimeUtils.currentTimeMillis());	    }	
/**	     * Is this instant after the instant passed in	     * comparing solely by millisecond.	     *	     * @param instant  an instant to check against, null means now	     * @return true if the instant is after the instant passed in	     */	    public boolean isAfter(ReadableInstant instant) {	        long instantMillis = DateTimeUtils.getInstantMillis(instant);	        return isAfter(instantMillis);	    }	
/**	     * Is this instant before the millisecond instant passed in	     * comparing solely by millisecond.	     *	     * @param instant  a millisecond instant to check against	     * @return true if this instant is before the instant passed in	     */	    public boolean isBefore(long instant) {	        return (getMillis() < instant);	    }	
/**	     * Is this instant before the current instant	     * comparing solely by millisecond.	     * 	     * @return true if this instant is before the current instant	     */	    public boolean isBeforeNow() {	        return isBefore(DateTimeUtils.currentTimeMillis());	    }	
/**	     * Is this instant before the instant passed in	     * comparing solely by millisecond.	     *	     * @param instant  an instant to check against, null means now	     * @return true if the instant is before the instant passed in	     */	    public boolean isBefore(ReadableInstant instant) {	        long instantMillis = DateTimeUtils.getInstantMillis(instant);	        return isBefore(instantMillis);	    }	
/**	     * Is this instant equal to the millisecond instant passed in	     * comparing solely by millisecond.	     *	     * @param instant  a millisecond instant to check against	     * @return true if this instant is before the instant passed in	     */	    public boolean isEqual(long instant) {	        return (getMillis() == instant);	    }	
/**	     * Is this instant equal to the current instant	     * comparing solely by millisecond.	     * 	     * @return true if this instant is before the current instant	     */	    public boolean isEqualNow() {	        return isEqual(DateTimeUtils.currentTimeMillis());	    }	
/**	     * Is this instant equal to the instant passed in	     * comparing solely by millisecond.	     *	     * @param instant  an instant to check against, null means now	     * @return true if the instant is equal to the instant passed in	     */	    public boolean isEqual(ReadableInstant instant) {	        long instantMillis = DateTimeUtils.getInstantMillis(instant);	        return isEqual(instantMillis);	    }	
/**	     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZZ).	     * 	     * @return ISO8601 time formatted string.	     */	    @ToString	    public String toString() {	        return ISODateTimeFormat.dateTime().print(this);	    }	
/**	     * Uses the specified formatter to convert this partial to a String.	     *	     * @param formatter  the formatter to use, null means use <code>toString()</code>.	     * @return the formatted string	     * @since 1.1	     */	    public String toString(DateTimeFormatter formatter) {	        if (formatter == null) {	            return toString();	        }	        return formatter.print(this);	    }	
/**	     * Creates a duration from the given millisecond duration.	     *	     * @param duration  the duration, in milliseconds	     */	    protected BaseDuration(long duration) {	        super();	        iMillis = duration;	    }	
/**	     * Creates a duration from the given interval endpoints.	     *	     * @param startInstant  interval start, in milliseconds	     * @param endInstant  interval end, in milliseconds	     * @throws ArithmeticException if the duration exceeds a 64 bit long	     */	    protected BaseDuration(long startInstant, long endInstant) {	        super();	        iMillis = FieldUtils.safeAdd(endInstant, -startInstant);	    }	
/**	     * Creates a duration from the given interval endpoints.	     *	     * @param start  interval start, null means now	     * @param end  interval end, null means now	     * @throws ArithmeticException if the duration exceeds a 64 bit long	     */	    protected BaseDuration(ReadableInstant start, ReadableInstant end) {	        super();	        if (start == end) {	            iMillis = 0L;	        } else {	            long startMillis = DateTimeUtils.getInstantMillis(start);	            long endMillis = DateTimeUtils.getInstantMillis(end);	            iMillis = FieldUtils.safeAdd(endMillis, -startMillis);	        }	    }	
/**	     * Creates a duration from the specified object using the	     * {@link org.joda.time.convert.ConverterManager ConverterManager}.	     *	     * @param duration  duration to convert	     * @throws IllegalArgumentException if duration is invalid	     */	    protected BaseDuration(Object duration) {	        super();	        DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);	        iMillis = converter.getDurationMillis(duration);	    }	
/**	     * Gets the length of this duration in milliseconds.	     *	     * @return the length of the duration in milliseconds.	     */	    public long getMillis() {	        return iMillis;	    }	
/**	     * Sets the length of this duration in milliseconds.	     * 	     * @param duration  the new length of the duration	     */	    protected void setMillis(long duration) {	        iMillis = duration;	    }	
/**	     * Converts this duration to a Period instance using the specified period type	     * and the ISO chronology.	     * <p>	     * Only precise fields in the period type will be used.	     * At most these are hours, minutes, seconds and millis - the period	     * type may restrict the selection further.	     * <p>	     * For more control over the conversion process, you must pair the duration with	     * an instant, see {@link #toPeriodFrom(ReadableInstant, PeriodType)}.	     * 	     * @param type  the period type to use, null means standard	     * @return a Period created using the millisecond duration from this instance	     */	    public Period toPeriod(PeriodType type) {	        return new Period(getMillis(), type);	    }	
/**	     * Converts this duration to a Period instance using the standard period type	     * and the specified chronology.	     * <p>	     * Only precise fields in the period type will be used.	     * Exactly which fields are precise depends on the chronology.	     * Only the time fields are precise for ISO chronology with a time zone.	     * However, ISO UTC also has precise days and weeks.	     * <p>	     * For more control over the conversion process, you must pair the duration with	     * an instant, see {@link #toPeriodFrom(ReadableInstant)} and	     * {@link #toPeriodTo(ReadableInstant)}	     * 	     * @param chrono  the chronology to use, null means ISO default	     * @return a Period created using the millisecond duration from this instance	     */	    public Period toPeriod(Chronology chrono) {	        return new Period(getMillis(), chrono);	    }	
/**	     * Converts this duration to a Period instance using the specified period type	     * and chronology.	     * <p>	     * Only precise fields in the period type will be used.	     * Exactly which fields are precise depends on the chronology.	     * Only the time fields are precise for ISO chronology with a time zone.	     * However, ISO UTC also has precise days and weeks.	     * <p>	     * For more control over the conversion process, you must pair the duration with	     * an instant, see {@link #toPeriodFrom(ReadableInstant, PeriodType)} and	     * {@link #toPeriodTo(ReadableInstant, PeriodType)}	     * 	     * @param type  the period type to use, null means standard	     * @param chrono  the chronology to use, null means ISO default	     * @return a Period created using the millisecond duration from this instance	     */	    public Period toPeriod(PeriodType type, Chronology chrono) {	        return new Period(getMillis(), type, chrono);	    }	
/**	     * Converts this duration to a Period instance by adding the duration to a start	     * instant to obtain an interval using the standard period type.	     * <p>	     * This conversion will determine the fields of a period accurately.	     * The results are based on the instant millis, the chronology of the instant,	     * the standard period type and the length of this duration.	     * 	     * @param startInstant  the instant to calculate the period from, null means now	     * @return a Period created using the millisecond duration from this instance	     */	    public Period toPeriodFrom(ReadableInstant startInstant) {	        return new Period(startInstant, this);	    }	
/**	     * Converts this duration to a Period instance by adding the duration to a start	     * instant to obtain an interval.	     * <p>	     * This conversion will determine the fields of a period accurately.	     * The results are based on the instant millis, the chronology of the instant,	     * the period type and the length of this duration.	     * 	     * @param startInstant  the instant to calculate the period from, null means now	     * @param type  the period type determining how to split the duration into fields, null means All type	     * @return a Period created using the millisecond duration from this instance	     */	    public Period toPeriodFrom(ReadableInstant startInstant, PeriodType type) {	        return new Period(startInstant, this, type);	    }	
/**	     * Converts this duration to a Period instance by subtracting the duration	     * from an end instant to obtain an interval using the standard period	     * type.	     * <p>	     * This conversion will determine the fields of a period accurately.	     * The results are based on the instant millis, the chronology of the instant,	     * the standard period type and the length of this duration.	     * 	     * @param endInstant  the instant to calculate the period to, null means now	     * @return a Period created using the millisecond duration from this instance	     */	    public Period toPeriodTo(ReadableInstant endInstant) {	        return new Period(this, endInstant);	    }	
/**	     * Converts this duration to a Period instance by subtracting the duration	     * from an end instant to obtain an interval using the standard period	     * type.	     * <p>	     * This conversion will determine the fields of a period accurately.	     * The results are based on the instant millis, the chronology of the instant,	     * the period type and the length of this duration.	     * 	     * @param endInstant  the instant to calculate the period to, null means now	     * @param type  the period type determining how to split the duration into fields, null means All type	     * @return a Period created using the millisecond duration from this instance	     */	    public Period toPeriodTo(ReadableInstant endInstant, PeriodType type) {	        return new Period(this, endInstant, type);	    }	
/**	     * Converts this duration to an Interval starting at the specified instant.	     * 	     * @param startInstant  the instant to start the interval at, null means now	     * @return an Interval starting at the specified instant	     */	    public Interval toIntervalFrom(ReadableInstant startInstant) {	        return new Interval(startInstant, this);	    }	
/**	     * Converts this duration to an Interval ending at the specified instant.	     * 	     * @param endInstant  the instant to end the interval at, null means now	     * @return an Interval ending at the specified instant	     */	    public Interval toIntervalTo(ReadableInstant endInstant) {	        return new Interval(this, endInstant);	    }	
/**	     * Constructs an instance set to the current system millisecond time	     * using <code>ISOChronology</code> in the default time zone.	     */	    public BaseDateTime() {	        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());	    }	
/**	     * Constructs an instance set to the current system millisecond time	     * using <code>ISOChronology</code> in the specified time zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     *	     * @param zone  the time zone, null means default zone	     */	    public BaseDateTime(DateTimeZone zone) {	        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));	    }	
/**	     * Constructs an instance set to the current system millisecond time	     * using the specified chronology.	     * <p>	     * If the chronology is null, <code>ISOChronology</code>	     * in the default time zone is used.	     *	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public BaseDateTime(Chronology chronology) {	        this(DateTimeUtils.currentTimeMillis(), chronology);	    }	
/**	     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z	     * using <code>ISOChronology</code> in the default time zone.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     */	    public BaseDateTime(long instant) {	        this(instant, ISOChronology.getInstance());	    }	
/**	     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z	     * using <code>ISOChronology</code> in the specified time zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param zone  the time zone, null means default zone	     */	    public BaseDateTime(long instant, DateTimeZone zone) {	        this(instant, ISOChronology.getInstance(zone));	    }	
/**	     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z	     * using the specified chronology.	     * <p>	     * If the chronology is null, <code>ISOChronology</code>	     * in the default time zone is used.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public BaseDateTime(long instant, Chronology chronology) {	        super();	        iChronology = checkChronology(chronology);	        iMillis = checkInstant(instant, iChronology);	    }	
/**	     * Constructs an instance from an Object that represents a datetime,	     * forcing the time zone to that specified.	     * <p>	     * If the object contains no chronology, <code>ISOChronology</code> is used.	     * If the specified time zone is null, the default zone is used.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     *	     * @param instant  the datetime object	     * @param zone  the time zone	     * @throws IllegalArgumentException if the instant is invalid	     */	    public BaseDateTime(Object instant, DateTimeZone zone) {	        super();	        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);	        Chronology chrono = checkChronology(converter.getChronology(instant, zone));	        iChronology = chrono;	        iMillis = checkInstant(converter.getInstantMillis(instant, chrono), chrono);	    }	
/**	     * Constructs an instance from an Object that represents a datetime,	     * using the specified chronology.	     * <p>	     * If the chronology is null, ISO in the default time zone is used.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     *	     * @param instant  the datetime object	     * @param chronology  the chronology	     * @throws IllegalArgumentException if the instant is invalid	     */	    public BaseDateTime(Object instant, Chronology chronology) {	        super();	        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);	        iChronology = checkChronology(converter.getChronology(instant, chronology));	        iMillis = checkInstant(converter.getInstantMillis(instant, chronology), iChronology);	    }	
/**	     * Constructs an instance from datetime field values	     * using <code>ISOChronology</code> in the default time zone.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     */	    public BaseDateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute,	            int millisOfSecond) {	        this(year, monthOfYear, dayOfMonth, hourOfDay,	            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance());	    }	
/**	     * Constructs an instance from datetime field values	     * using <code>ISOChronology</code> in the specified time zone.	     * <p>	     * If the specified time zone is null, the default zone is used.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     * @param zone  the time zone, null means default time zone	     */	    public BaseDateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute,	            int millisOfSecond,	            DateTimeZone zone) {	        this(year, monthOfYear, dayOfMonth, hourOfDay,	            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance(zone));	    }	
/**	     * Constructs an instance from datetime field values	     * using the specified chronology.	     * <p>	     * If the chronology is null, <code>ISOChronology</code>	     * in the default time zone is used.	     *	     * @param year  the year	     * @param monthOfYear  the month of the year	     * @param dayOfMonth  the day of the month	     * @param hourOfDay  the hour of the day	     * @param minuteOfHour  the minute of the hour	     * @param secondOfMinute  the second of the minute	     * @param millisOfSecond  the millisecond of the second	     * @param chronology  the chronology, null means ISOChronology in default zone	     */	    public BaseDateTime(	            int year,	            int monthOfYear,	            int dayOfMonth,	            int hourOfDay,	            int minuteOfHour,	            int secondOfMinute,	            int millisOfSecond,	            Chronology chronology) {	        super();	        iChronology = checkChronology(chronology);	        long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,	            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	        iMillis = checkInstant(instant, iChronology);	    }	
/**	     * Checks the specified chronology before storing it, potentially altering it.	     * This method must not access any instance variables.	     * <p>	     * This implementation converts nulls to ISOChronology in the default zone.	     *	     * @param chronology  the chronology to use, may be null	     * @return the chronology to store in this datetime, not null	     */	    protected Chronology checkChronology(Chronology chronology) {	        return DateTimeUtils.getChronology(chronology);	    }	
/**	     * Checks the specified instant before storing it, potentially altering it.	     * This method must not access any instance variables.	     * <p>	     * This implementation simply returns the instant.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round	     * @param chronology  the chronology to use, not null	     * @return the instant to store in this datetime	     */	    protected long checkInstant(long instant, Chronology chronology) {	        return instant;	    }	
/**	     * Gets the milliseconds of the datetime instant from the Java epoch	     * of 1970-01-01T00:00:00Z.	     * 	     * @return the number of milliseconds since 1970-01-01T00:00:00Z	     */	    public long getMillis() {	        return iMillis;	    }	
/**	     * Gets the chronology of the datetime.	     * 	     * @return the Chronology that the datetime is using	     */	    public Chronology getChronology() {	        return iChronology;	    }	
/**	     * Sets the milliseconds of the datetime.	     * <p>	     * All changes to the millisecond field occurs via this method.	     * Override and block this method to make a subclass immutable.	     *	     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the datetime to	     */	    protected void setMillis(long instant) {	        iMillis = checkInstant(instant, iChronology);	    }	
/**	     * Sets the chronology of the datetime.	     * <p>	     * All changes to the chronology field occurs via this method.	     * Override and block this method to make a subclass immutable.	     *	     * @param chronology  the chronology to set	     */	    protected void setChronology(Chronology chronology) {	        iChronology = checkChronology(chronology);	    }	
/**	     * Constructor.	     */	    protected AbstractDuration() {	        super();	    }	
/**	     * Get this duration as an immutable <code>Duration</code> object.	     * 	     * @return a Duration created using the millisecond duration from this instance	     */	    public Duration toDuration() {	        return new Duration(getMillis());	    }	
/**	     * Converts this duration to a Period instance using the standard period type	     * and the ISO chronology.	     * <p>	     * Only precise fields in the period type will be used. Thus, only the hour,	     * minute, second and millisecond fields on the period will be used.	     * The year, month, week and day fields will not be populated.	     * <p>	     * If the duration is small, less than one day, then this method will perform	     * as you might expect and split the fields evenly.	     * If the duration is larger than one day then all the remaining duration will	     * be stored in the largest available field, hours in this case.	     * <p>	     * For example, a duration effectively equal to (365 + 60 + 5) days will be	     * converted to ((365 + 60 + 5) * 24) hours by this constructor.	     * <p>	     * For more control over the conversion process, you must pair the duration with	     * an instant, see {@link Period#Period(ReadableInstant,ReadableDuration)}.	     * 	     * @return a Period created using the millisecond duration from this instance	     */	    public Period toPeriod() {	        return new Period(getMillis());	    }	
/**	     * Compares this duration with the specified duration based on length.	     *	     * @param other  a duration to check against	     * @return negative value if this is less, 0 if equal, or positive value if greater	     * @throws NullPointerException if the object is null	     * @throws ClassCastException if the given object is not supported	     */	    public int compareTo(ReadableDuration other) {	        long thisMillis = this.getMillis();	        long otherMillis = other.getMillis();	        	        // cannot do (thisMillis - otherMillis) as it can overflow	        if (thisMillis < otherMillis) {	            return -1;	        }	        if (thisMillis > otherMillis) {	            return 1;	        }	        return 0;	    }	
/**	     * Is the length of this duration equal to the duration passed in.	     *	     * @param duration  another duration to compare to, null means zero milliseconds	     * @return true if this duration is equal to than the duration passed in	     */	    public boolean isEqual(ReadableDuration duration) {	        if (duration == null) {	            duration = Duration.ZERO;	        }	        return compareTo(duration) == 0;	    }	
/**	     * Is the length of this duration longer than the duration passed in.	     *	     * @param duration  another duration to compare to, null means zero milliseconds	     * @return true if this duration is equal to than the duration passed in	     */	    public boolean isLongerThan(ReadableDuration duration) {	        if (duration == null) {	            duration = Duration.ZERO;	        }	        return compareTo(duration) > 0;	    }	
/**	     * Is the length of this duration shorter than the duration passed in.	     *	     * @param duration  another duration to compare to, null means zero milliseconds	     * @return true if this duration is equal to than the duration passed in	     */	    public boolean isShorterThan(ReadableDuration duration) {	        if (duration == null) {	            duration = Duration.ZERO;	        }	        return compareTo(duration) < 0;	    }	
/**	     * Compares this object with the specified object for equality based	     * on the millisecond length. All ReadableDuration instances are accepted.	     *	     * @param duration  a readable duration to check against	     * @return true if the length of the duration is equal	     */	    public boolean equals(Object duration) {	        if (this == duration) {	            return true;	        }	        if (duration instanceof ReadableDuration == false) {	            return false;	        }	        ReadableDuration other = (ReadableDuration) duration;	        return (getMillis() == other.getMillis());	    }	
/**	     * Gets a hash code for the duration that is compatible with the 	     * equals method.	     *	     * @return a hash code	     */	    public int hashCode() {	        long len = getMillis();	        return (int) (len ^ (len >>> 32));	    }	
/**	     * Gets the value as a String in the ISO8601 duration format including	     * only seconds and milliseconds.	     * <p>	     * For example, "PT72.345S" represents 1 minute, 12 seconds and 345 milliseconds.	     * <p>	     * For more control over the output, see	     * {@link org.joda.time.format.PeriodFormatterBuilder PeriodFormatterBuilder}.	     *	     * @return the value as an ISO8601 string	     */	    @ToString	    public String toString() {	        long millis = getMillis();	        StringBuffer buf = new StringBuffer();	        buf.append("PT");	        boolean negative = (millis < 0);	        FormatUtils.appendUnpaddedInteger(buf, millis);	        while (buf.length() < (negative ? 7 : 6)) {	            buf.insert(negative ? 3 : 2, "0");	        }	        if ((millis / 1000) * 1000 == millis) {	            buf.setLength(buf.length() - 3);	        } else {	            buf.insert(buf.length() - 3, ".");	        }	        buf.append('S');	        return buf.toString();	    }	
/**	     * Constructor.	     */	    protected AbstractDateTime() {	        super();	    }	
/**	     * Get the value of one of the fields of a datetime.	     * <p>	     * This method uses the chronology of the datetime to obtain the value.	     * It is essentially a generic way of calling one of the get methods.	     *	     * @param type  a field type, usually obtained from DateTimeFieldType	     * @return the value of that field	     * @throws IllegalArgumentException if the field type is null	     */	    public int get(DateTimeFieldType type) {	        if (type == null) {	            throw new IllegalArgumentException("The DateTimeFieldType must not be null");	        }	        return type.getField(getChronology()).get(getMillis());	    }	
/**	     * Get the era field value.	     * 	     * @return the era	     */	    public int getEra() {	        return getChronology().era().get(getMillis());	    }	
/**	     * Get the year of era field value.	     * 	     * @return the year of era	     */	    public int getCenturyOfEra() {	        return getChronology().centuryOfEra().get(getMillis());	    }	
/**	     * Get the year of era field value.	     * 	     * @return the year of era	     */	    public int getYearOfEra() {	        return getChronology().yearOfEra().get(getMillis());	    }	
/**	     * Get the year of century field value.	     * 	     * @return the year of century	     */	    public int getYearOfCentury() {	        return getChronology().yearOfCentury().get(getMillis());	    }	
/**	     * Get the year field value.	     * 	     * @return the year	     */	    public int getYear() {	        return getChronology().year().get(getMillis());	    }	
/**	     * Get the weekyear field value.	     * 	     * @return the year of a week based year	     */	    public int getWeekyear() {	        return getChronology().weekyear().get(getMillis());	    }	
/**	     * Get the month of year field value.	     * 	     * @return the month of year	     */	    public int getMonthOfYear() {	        return getChronology().monthOfYear().get(getMillis());	    }	
/**	     * Get the week of weekyear field value.	     * 	     * @return the week of a week based year	     */	    public int getWeekOfWeekyear() {	        return getChronology().weekOfWeekyear().get(getMillis());	    }	
/**	     * Get the day of year field value.	     * 	     * @return the day of year	     */	    public int getDayOfYear() {	        return getChronology().dayOfYear().get(getMillis());	    }	
/**	     * Get the day of month field value.	     * <p>	     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.	     * 	     * @return the day of month	     */	    public int getDayOfMonth() {	        return getChronology().dayOfMonth().get(getMillis());	    }	
/**	     * Get the day of week field value.	     * <p>	     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.	     * 	     * @return the day of week	     */	    public int getDayOfWeek() {	        return getChronology().dayOfWeek().get(getMillis());	    }	
/**	     * Get the hour of day field value.	     *	     * @return the hour of day	     */	    public int getHourOfDay() {	        return getChronology().hourOfDay().get(getMillis());	    }	
/**	     * Get the minute of day field value.	     *	     * @return the minute of day	     */	    public int getMinuteOfDay() {	        return getChronology().minuteOfDay().get(getMillis());	    }	
/**	     * Get the minute of hour field value.	     *	     * @return the minute of hour	     */	    public int getMinuteOfHour() {	        return getChronology().minuteOfHour().get(getMillis());	    }	
/**	     * Get the second of day field value.	     *	     * @return the second of day	     */	    public int getSecondOfDay() {	        return getChronology().secondOfDay().get(getMillis());	    }	
/**	     * Get the second of minute field value.	     *	     * @return the second of minute	     */	    public int getSecondOfMinute() {	        return getChronology().secondOfMinute().get(getMillis());	    }	
/**	     * Get the millis of day field value.	     *	     * @return the millis of day	     */	    public int getMillisOfDay() {	        return getChronology().millisOfDay().get(getMillis());	    }	
/**	     * Get the millis of second field value.	     *	     * @return the millis of second	     */	    public int getMillisOfSecond() {	        return getChronology().millisOfSecond().get(getMillis());	    }	
/**	     * Get the date time as a <code>java.util.Calendar</code>, assigning	     * exactly the same millisecond instant.	     * The locale is passed in, enabling Calendar to select the correct	     * localized subclass.	     * <p>	     * The JDK and Joda-Time both have time zone implementations and these	     * differ in accuracy. Joda-Time's implementation is generally more up to	     * date and thus more accurate - for example JDK1.3 has no historical data.	     * The effect of this is that the field values of the <code>Calendar</code>	     * may differ from those of this object, even though the milliseond value	     * is the same. Most of the time this just means that the JDK field values	     * are wrong, as our time zone information is more up to date.	     *	     * @param locale  the locale to get the Calendar for, or default if null	     * @return a localized Calendar initialised with this datetime	     */	    public Calendar toCalendar(Locale locale) {	        if (locale == null) {	            locale = Locale.getDefault();	        }	        DateTimeZone zone = getZone();	        Calendar cal = Calendar.getInstance(zone.toTimeZone(), locale);	        cal.setTime(toDate());	        return cal;	    }	
/**	     * Get the date time as a <code>java.util.GregorianCalendar</code>,	     * assigning exactly the same millisecond instant.	     * <p>	     * The JDK and Joda-Time both have time zone implementations and these	     * differ in accuracy. Joda-Time's implementation is generally more up to	     * date and thus more accurate - for example JDK1.3 has no historical data.	     * The effect of this is that the field values of the <code>Calendar</code>	     * may differ from those of this object, even though the milliseond value	     * is the same. Most of the time this just means that the JDK field values	     * are wrong, as our time zone information is more up to date.	     *	     * @return a GregorianCalendar initialised with this datetime	     */	    public GregorianCalendar toGregorianCalendar() {	        DateTimeZone zone = getZone();	        GregorianCalendar cal = new GregorianCalendar(zone.toTimeZone());	        cal.setTime(toDate());	        return cal;	    }	
/**	     * Output the instant using the specified format pattern.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @see  org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern) {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).print(this);	    }	
/**	     * Output the instant using the specified format pattern.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @param locale  Locale to use, null means default	     * @see  org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern, Locale locale) throws IllegalArgumentException {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);	    }	
/**	     * Calculates the number of whole units between the two specified datetimes.	     *	     * @param start  the start instant, validated to not be null	     * @param end  the end instant, validated to not be null	     * @param field  the field type to use, must not be null	     * @return the period	     * @throws IllegalArgumentException if the instants are null or invalid	     */	    protected static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) {	        if (start == null || end == null) {	            throw new IllegalArgumentException("ReadableInstant objects must not be null");	        }	        Chronology chrono = DateTimeUtils.getInstantChronology(start);	        int amount = field.getField(chrono).getDifference(end.getMillis(), start.getMillis());	        return amount;	    }	
/**	     * Calculates the number of whole units between the two specified partial datetimes.	     * <p>	     * The two partials must contain the same fields, for example you can specify	     * two <code>LocalDate</code> objects.	     *	     * @param start  the start partial date, validated to not be null	     * @param end  the end partial date, validated to not be null	     * @param zeroInstance  the zero instance constant, must not be null	     * @return the period	     * @throws IllegalArgumentException if the partials are null or invalid	     */	    protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {	        if (start == null || end == null) {	            throw new IllegalArgumentException("ReadablePartial objects must not be null");	        }	        if (start.size() != end.size()) {	            throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields");	        }	        for (int i = 0, isize = start.size(); i < isize; i++) {	            if (start.getFieldType(i) != end.getFieldType(i)) {	                throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields");	            }	        }	        if (DateTimeUtils.isContiguous(start) == false) {	            throw new IllegalArgumentException("ReadablePartial objects must be contiguous");	        }	        Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();	        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));	        return values[0];	    }	
/**	     * Creates a new instance representing the number of complete standard length units	     * in the specified period.	     * <p>	     * This factory method converts all fields from the period to hours using standardised	     * durations for each field. Only those fields which have a precise duration in	     * the ISO UTC chronology can be converted.	     * <ul>	     * <li>One week consists of 7 days.	     * <li>One day consists of 24 hours.	     * <li>One hour consists of 60 minutes.	     * <li>One minute consists of 60 seconds.	     * <li>One second consists of 1000 milliseconds.	     * </ul>	     * Months and Years are imprecise and periods containing these values cannot be converted.	     *	     * @param period  the period to get the number of hours from, must not be null	     * @param millisPerUnit  the number of milliseconds in one standard unit of this period	     * @throws IllegalArgumentException if the period contains imprecise duration values	     */	    protected static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) {	        if (period == null) {	            return 0;	        }	        Chronology iso = ISOChronology.getInstanceUTC();	        long duration = 0L;	        for (int i = 0; i < period.size(); i++) {	            int value = period.getValue(i);	            if (value != 0) {	                DurationField field = period.getFieldType(i).getField(iso);	                if (field.isPrecise() == false) {	                    throw new IllegalArgumentException(	                            "Cannot convert period to duration as " + field.getName() +	                            " is not precise in the period " + period);	                }	                duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value));	            }	        }	        return FieldUtils.safeToInt(duration / millisPerUnit);	    }	
/**	     * Creates a new instance representing the specified period.	     *	     * @param period  the period to represent	     */	    protected BaseSingleFieldPeriod(int period) {	        super();	        iPeriod = period;	    }	
/**	     * Gets the amount of this period.	     *	     * @return the period value	     */	    protected int getValue() {	        return iPeriod;	    }	
/**	     * Sets the amount of this period.	     * To make a subclass immutable you must declare it final, or block this method.	     *	     * @param value  the period value	     */	    protected void setValue(int value) {	        iPeriod = value;	    }	
/**	     * Gets the number of fields that this period supports, which is one.	     *	     * @return the number of fields supported, which is one	     */	    public int size() {	        return 1;	    }	
/**	     * Gets the field type at the specified index.	     * <p>	     * The only index supported by this period is zero which returns the	     * field type of this class.	     *	     * @param index  the index to retrieve, which must be zero	     * @return the field at the specified index	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public DurationFieldType getFieldType(int index) {	        if (index != 0) {	            throw new IndexOutOfBoundsException(String.valueOf(index));	        }	        return getFieldType();	    }	
/**	     * Gets the value at the specified index.	     * <p>	     * The only index supported by this period is zero.	     *	     * @param index  the index to retrieve, which must be zero	     * @return the value of the field at the specified index	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public int getValue(int index) {	        if (index != 0) {	            throw new IndexOutOfBoundsException(String.valueOf(index));	        }	        return getValue();	    }	
/**	     * Gets the value of a duration field represented by this period.	     * <p>	     * If the field type specified does not match the type used by this class	     * then zero is returned.	     *	     * @param type  the field type to query, null returns zero	     * @return the value of that field, zero if field not supported	     */	    public int get(DurationFieldType type) {	        if (type == getFieldType()) {	            return getValue();	        }	        return 0;	    }	
/**	     * Checks whether the duration field specified is supported by this period.	     *	     * @param type  the type to check, may be null which returns false	     * @return true if the field is supported	     */	    public boolean isSupported(DurationFieldType type) {	        return (type == getFieldType());	    }	
/**	     * Get this period as an immutable <code>Period</code> object.	     * The period will use <code>PeriodType.standard()</code>.	     *	     * @return a <code>Period</code> representing the same number of days	     */	    public Period toPeriod() {	        return Period.ZERO.withFields(this);	    }	
/**	     * Get this object as a <code>MutablePeriod</code>.	     * <p>	     * This will always return a new <code>MutablePeriod</code> with the same fields.	     * The period will use <code>PeriodType.standard()</code>.	     * 	     * @return a MutablePeriod using the same field set and values	     */	    public MutablePeriod toMutablePeriod() {	        MutablePeriod period = new MutablePeriod();	        period.add(this);	        return period;	    }	
/**	     * Compares this object with the specified object for equality based on the	     * value of each field. All ReadablePeriod instances are accepted, but only	     * those with a matching <code>PeriodType</code> can return true.	     *	     * @param period  a readable period to check against	     * @return true if all the field values are equal, false if	     *  not or the period is null or of an incorrect type	     */	    public boolean equals(Object period) {	        if (this == period) {	            return true;	        }	        if (period instanceof ReadablePeriod == false) {	            return false;	        }	        ReadablePeriod other = (ReadablePeriod) period;	        return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());	    }	
/**	     * Gets a hash code for the period as defined by ReadablePeriod.	     *	     * @return a hash code	     */	    public int hashCode() {	        int total = 17;	        total = 27 * total + getValue();	        total = 27 * total + getFieldType().hashCode();	        return total;	    }	
/**	     * Compares this period to another object of the same class.	     *	     * @param other  the other period, must not be null	     * @return zero if equal, positive if greater, negative if less	     * @throws NullPointerException if the other period is null	     * @throws ClassCastException if the other period is of a different type	     */	    public int compareTo(BaseSingleFieldPeriod other) {	        if (other.getClass() != getClass()) {	            throw new ClassCastException(getClass() + " cannot be compared to " + other.getClass());	        }	        int otherValue = other.getValue();	        int thisValue = getValue();	        if (thisValue > otherValue) {	            return 1;	        }	        if (thisValue < otherValue) {	            return -1;	        }	        return 0;	    }	
/**	     * Constructor.	     */	    protected AbstractPartial() {	        super();	    }	
/**	     * Gets the field type at the specifed index.	     * 	     * @param index  the index	     * @return the field type	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public DateTimeFieldType getFieldType(int index) {	        return getField(index, getChronology()).getType();	    }	
/**	     * Gets an array of the field types that this partial supports.	     * <p>	     * The fields are returned largest to smallest, for example Hour, Minute, Second.	     *	     * @return the fields supported in an array that may be altered, largest to smallest	     */	    public DateTimeFieldType[] getFieldTypes() {	        DateTimeFieldType[] result = new DateTimeFieldType[size()];	        for (int i = 0; i < result.length; i++) {	            result[i] = getFieldType(i);	        }	        return result;	    }	
/**	     * Gets the field at the specifed index.	     * 	     * @param index  the index	     * @return the field	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public DateTimeField getField(int index) {	        return getField(index, getChronology());	    }	
/**	     * Gets an array of the fields that this partial supports.	     * <p>	     * The fields are returned largest to smallest, for example Hour, Minute, Second.	     *	     * @return the fields supported in an array that may be altered, largest to smallest	     */	    public DateTimeField[] getFields() {	        DateTimeField[] result = new DateTimeField[size()];	        for (int i = 0; i < result.length; i++) {	            result[i] = getField(i);	        }	        return result;	    }	
/**	     * Gets an array of the value of each of the fields that this partial supports.	     * <p>	     * The fields are returned largest to smallest, for example Hour, Minute, Second.	     * Each value corresponds to the same array index as <code>getFields()</code>	     *	     * @return the current values of each field in an array that may be altered, largest to smallest	     */	    public int[] getValues() {	        int[] result = new int[size()];	        for (int i = 0; i < result.length; i++) {	            result[i] = getValue(i);	        }	        return result;	    }	
/**	     * Get the value of one of the fields of a datetime.	     * <p>	     * The field specified must be one of those that is supported by the partial.	     *	     * @param type  a DateTimeFieldType instance that is supported by this partial	     * @return the value of that field	     * @throws IllegalArgumentException if the field is null or not supported	     */	    public int get(DateTimeFieldType type) {	        return getValue(indexOfSupported(type));	    }	
/**	     * Checks whether the field specified is supported by this partial.	     *	     * @param type  the type to check, may be null which returns false	     * @return true if the field is supported	     */	    public boolean isSupported(DateTimeFieldType type) {	        return (indexOf(type) != -1);	    }	
/**	     * Gets the index of the specified field, or -1 if the field is unsupported.	     *	     * @param type  the type to check, may be null which returns -1	     * @return the index of the field, -1 if unsupported	     */	    public int indexOf(DateTimeFieldType type) {	        for (int i = 0, isize = size(); i < isize; i++) {	            if (getFieldType(i) == type) {	                return i;	            }	        }	        return -1;	    }	
/**	     * Gets the index of the specified field, throwing an exception if the	     * field is unsupported.	     *	     * @param type  the type to check, not null	     * @return the index of the field	     * @throws IllegalArgumentException if the field is null or not supported	     */	    protected int indexOfSupported(DateTimeFieldType type) {	        int index = indexOf(type);	        if (index == -1) {	            throw new IllegalArgumentException("Field '" + type + "' is not supported");	        }	        return index;	    }	
/**	     * Gets the index of the first fields to have the specified duration,	     * or -1 if the field is unsupported.	     *	     * @param type  the type to check, may be null which returns -1	     * @return the index of the field, -1 if unsupported	     */	    protected int indexOf(DurationFieldType type) {	        for (int i = 0, isize = size(); i < isize; i++) {	            if (getFieldType(i).getDurationType() == type) {	                return i;	            }	        }	        return -1;	    }	
/**	     * Gets the index of the first fields to have the specified duration,	     * throwing an exception if the field is unsupported.	     *	     * @param type  the type to check, not null	     * @return the index of the field	     * @throws IllegalArgumentException if the field is null or not supported	     */	    protected int indexOfSupported(DurationFieldType type) {	        int index = indexOf(type);	        if (index == -1) {	            throw new IllegalArgumentException("Field '" + type + "' is not supported");	        }	        return index;	    }	
/**	     * Resolves this partial against another complete instant to create a new	     * full instant. The combination is performed using the chronology of the	     * specified instant.	     * <p>	     * For example, if this partial represents a time, then the result of this	     * method will be the datetime from the specified base instant plus the	     * time from this partial.	     *	     * @param baseInstant  the instant that provides the missing fields, null means now	     * @return the combined datetime	     */	    public DateTime toDateTime(ReadableInstant baseInstant) {	        Chronology chrono = DateTimeUtils.getInstantChronology(baseInstant);	        long instantMillis = DateTimeUtils.getInstantMillis(baseInstant);	        long resolved = chrono.set(this, instantMillis);	        return new DateTime(resolved, chrono);	    }	
/**	     * Compares this ReadablePartial with another returning true if the chronology,	     * field types and values are equal.	     *	     * @param partial  an object to check against	     * @return true if fields and values are equal	     */	    public boolean equals(Object partial) {	        if (this == partial) {	            return true;	        }	        if (partial instanceof ReadablePartial == false) {	            return false;	        }	        ReadablePartial other = (ReadablePartial) partial;	        if (size() != other.size()) {	            return false;	        }	        for (int i = 0, isize = size(); i < isize; i++) {	            if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {	                return false;	            }	        }	        return FieldUtils.equals(getChronology(), other.getChronology());	    }	
/**	     * Gets a hash code for the ReadablePartial that is compatible with the 	     * equals method.	     *	     * @return a suitable hash code	     */	    public int hashCode() {	        int total = 157;	        for (int i = 0, isize = size(); i < isize; i++) {	            total = 23 * total + getValue(i);	            total = 23 * total + getFieldType(i).hashCode();	        }	        total += getChronology().hashCode();	        return total;	    }	
/**	     * Compares this partial with another returning an integer	     * indicating the order.	     * <p>	     * The fields are compared in order, from largest to smallest.	     * The first field that is non-equal is used to determine the result.	     * <p>	     * The specified object must be a partial instance whose field types	     * match those of this partial.	     * <p>	     * NOTE: This implementation violates the Comparable contract.	     * This method will accept any instance of ReadablePartial as input.	     * However, it is possible that some implementations of ReadablePartial	     * exist that do not extend AbstractPartial, and thus will throw a	     * ClassCastException if compared in the opposite direction.	     * The cause of this problem is that ReadablePartial doesn't define	     * the compareTo() method, however we can't change that until v2.0.	     *	     * @param other  an object to check against	     * @return negative if this is less, zero if equal, positive if greater	     * @throws ClassCastException if the partial is the wrong class	     *  or if it has field types that don't match	     * @throws NullPointerException if the partial is null	     * @since 1.1	     */	    public int compareTo(ReadablePartial other) {	        if (this == other) {	            return 0;	        }	        if (size() != other.size()) {	            throw new ClassCastException("ReadablePartial objects must have matching field types");	        }	        for (int i = 0, isize = size(); i < isize; i++) {	            if (getFieldType(i) != other.getFieldType(i)) {	                throw new ClassCastException("ReadablePartial objects must have matching field types");	            }	        }	        // fields are ordered largest first	        for (int i = 0, isize = size(); i < isize; i++) {	            if (getValue(i) > other.getValue(i)) {	                return 1;	            }	            if (getValue(i) < other.getValue(i)) {	                return -1;	            }	        }	        return 0;	    }	
/**	     * Is this partial later than the specified partial.	     * <p>	     * The fields are compared in order, from largest to smallest.	     * The first field that is non-equal is used to determine the result.	     * <p>	     * You may not pass null into this method. This is because you need	     * a time zone to accurately determine the current date.	     *	     * @param partial  a partial to check against, must not be null	     * @return true if this date is after the date passed in	     * @throws IllegalArgumentException if the specified partial is null	     * @throws ClassCastException if the partial has field types that don't match	     * @since 1.1	     */	    public boolean isAfter(ReadablePartial partial) {	        if (partial == null) {	            throw new IllegalArgumentException("Partial cannot be null");	        }	        return compareTo(partial) > 0;	    }	
/**	     * Is this partial earlier than the specified partial.	     * <p>	     * The fields are compared in order, from largest to smallest.	     * The first field that is non-equal is used to determine the result.	     * <p>	     * You may not pass null into this method. This is because you need	     * a time zone to accurately determine the current date.	     *	     * @param partial  a partial to check against, must not be null	     * @return true if this date is before the date passed in	     * @throws IllegalArgumentException if the specified partial is null	     * @throws ClassCastException if the partial has field types that don't match	     * @since 1.1	     */	    public boolean isBefore(ReadablePartial partial) {	        if (partial == null) {	            throw new IllegalArgumentException("Partial cannot be null");	        }	        return compareTo(partial) < 0;	    }	
/**	     * Is this partial the same as the specified partial.	     * <p>	     * The fields are compared in order, from largest to smallest.	     * If all fields are equal, the result is true.	     * <p>	     * You may not pass null into this method. This is because you need	     * a time zone to accurately determine the current date.	     *	     * @param partial  a partial to check against, must not be null	     * @return true if this date is the same as the date passed in	     * @throws IllegalArgumentException if the specified partial is null	     * @throws ClassCastException if the partial has field types that don't match	     * @since 1.1	     */	    public boolean isEqual(ReadablePartial partial) {	        if (partial == null) {	            throw new IllegalArgumentException("Partial cannot be null");	        }	        return compareTo(partial) == 0;	    }	
/**	     * Uses the specified formatter to convert this partial to a String.	     *	     * @param formatter  the formatter to use, null means use <code>toString()</code>.	     * @return the formatted string	     * @since 1.1	     */	    public String toString(DateTimeFormatter formatter) {	        if (formatter == null) {	            return toString();	        }	        return formatter.print(this);	    }	
/**	     * Constructs a partial with the current time, using ISOChronology in	     * the default zone to extract the fields.	     * <p>	     * The constructor uses the default time zone, resulting in the local time	     * being initialised. Once the constructor is complete, all further calculations	     * are performed without reference to a timezone (by switching to UTC).	     */	    protected BasePartial() {	        this(DateTimeUtils.currentTimeMillis(), null);	    }	
/**	     * Constructs a partial with the current time, using the specified chronology	     * and zone to extract the fields.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a timezone (by switching to UTC).	     *	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    protected BasePartial(Chronology chronology) {	        this(DateTimeUtils.currentTimeMillis(), chronology);	    }	
/**	     * Constructs a partial extracting the partial fields from the specified	     * milliseconds using the ISOChronology in the default zone.	     * <p>	     * The constructor uses the default time zone, resulting in the local time	     * being initialised. Once the constructor is complete, all further calculations	     * are performed without reference to a timezone (by switching to UTC).	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     */	    protected BasePartial(long instant) {	        this(instant, null);	    }	
/**	     * Constructs a partial extracting the partial fields from the specified	     * milliseconds using the chronology provided.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a timezone (by switching to UTC).	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z	     * @param chronology  the chronology, null means ISOChronology in the default zone	     */	    protected BasePartial(long instant, Chronology chronology) {	        super();	        chronology = DateTimeUtils.getChronology(chronology);	        iChronology = chronology.withUTC();	        iValues = chronology.get(this, instant);	    }	
/**	     * Constructs a partial from an Object that represents a time, using the	     * specified chronology.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a timezone (by switching to UTC).	     *	     * @param instant  the datetime object	     * @param chronology  the chronology, null means use converter	     * @throws IllegalArgumentException if the date is invalid	     */	    protected BasePartial(Object instant, Chronology chronology) {	        super();	        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);	        chronology = converter.getChronology(instant, chronology);	        chronology = DateTimeUtils.getChronology(chronology);	        iChronology = chronology.withUTC();	        iValues = converter.getPartialValues(this, instant, chronology);	    }	
/**	     * Constructs a partial from an Object that represents a time, using the	     * specified chronology.	     * <p>	     * The recognised object types are defined in	     * {@link org.joda.time.convert.ConverterManager ConverterManager} and	     * include ReadableInstant, String, Calendar and Date.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a timezone (by switching to UTC).	     *	     * @param instant  the datetime object	     * @param chronology  the chronology, null means use converter	     * @param parser  if converting from a String, the given parser is preferred	     * @throws IllegalArgumentException if the date is invalid	     * @since 1.3	     */	    protected BasePartial(Object instant, Chronology chronology, DateTimeFormatter parser) {	        super();	        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);	        chronology = converter.getChronology(instant, chronology);	        chronology = DateTimeUtils.getChronology(chronology);	        iChronology = chronology.withUTC();	        iValues = converter.getPartialValues(this, instant, chronology, parser);	    }	
/**	     * Constructs a partial with specified time field values and chronology.	     * <p>	     * The constructor uses the time zone of the chronology specified.	     * Once the constructor is complete, all further calculations are performed	     * without reference to a timezone (by switching to UTC).	     * <p>	     * The array of values is assigned (not cloned) to the new instance.	     *	     * @param values  the new set of values	     * @param chronology  the chronology, null means ISOChronology in the default zone	     * @throws IllegalArgumentException if the values are invalid	     */	    protected BasePartial(int[] values, Chronology chronology) {	        super();	        chronology = DateTimeUtils.getChronology(chronology);	        iChronology = chronology.withUTC();	        chronology.validate(this, values);	        iValues = values;	    }	
/**	     * Private constructor to be used by subclasses only which performs no validation.	     * <p>	     * Data is assigned (not cloned) to the new instance.	     *	     * @param base  the base partial	     * @param values  the new set of values, not cloned, null means use base	     */	    protected BasePartial(BasePartial base, int[] values) {	        super();	        iChronology = base.iChronology;	        iValues = values;	    }	
/**	     * Private constructor to be used by subclasses only which performs no validation.	     * <p>	     * Data is assigned (not cloned) to the new instance.	     * This should not be used by mutable subclasses.	     *	     * @param base  the base partial	     * @param chrono  the chronology to use, null means use base	     */	    protected BasePartial(BasePartial base, Chronology chrono) {	        super();	        iChronology = chrono.withUTC();	        iValues = base.iValues;	    }	
/**	     * Gets the value of the field at the specifed index.	     * 	     * @param index  the index	     * @return the value	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public int getValue(int index) {	        return iValues[index];	    }	
/**	     * Gets an array of the value of each of the fields that this partial supports.	     * <p>	     * The fields are returned largest to smallest, for example Hour, Minute, Second.	     * Each value corresponds to the same array index as <code>getFields()</code>	     *	     * @return the current values of each field (cloned), largest to smallest	     */	    public int[] getValues() {	        return (int[]) iValues.clone();	    }	
/**	     * Gets the chronology of the partial which is never null.	     * <p>	     * The {@link Chronology} is the calculation engine behind the partial and	     * provides conversion and validation of the fields in a particular calendar system.	     * 	     * @return the chronology, never null	     */	    public Chronology getChronology() {	        return iChronology;	    }	
/**	     * Sets the value of the field at the specifed index.	     * 	     * @param index  the index	     * @param value  the value to set	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    protected void setValue(int index, int value) {	        DateTimeField field = getField(index);	        iValues = field.set(this, index, iValues, value);	    }	
/**	     * Sets the values of all fields.	     * 	     * @param values  the array of values	     */	    protected void setValues(int[] values) {	        getChronology().validate(this, values);	        iValues = values;	    }	
/**	     * Output the date using the specified format pattern.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @see org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern) {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).print(this);	    }	
/**	     * Output the date using the specified format pattern.	     *	     * @param pattern  the pattern specification, null means use <code>toString</code>	     * @param locale  Locale to use, null means default	     * @see org.joda.time.format.DateTimeFormat	     */	    public String toString(String pattern, Locale locale) throws IllegalArgumentException {	        if (pattern == null) {	            return toString();	        }	        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);	    }	
/**	     * Constructor.	     */	    protected AbstractInterval() {	        super();	    }	
/**	     * Validates an interval.	     * 	     * @param start  the start instant in milliseconds	     * @param end  the end instant in milliseconds	     * @throws IllegalArgumentException if the interval is invalid	     */	    protected void checkInterval(long start, long end) {	        if (end < start) {	            throw new IllegalArgumentException("The end instant must be greater or equal to the start");	        }	    }	
/**	     * Gets the start of this time interval, which is inclusive, as a DateTime.	     *	     * @return the start of the time interval	     */	    public DateTime getStart() {	        return new DateTime(getStartMillis(), getChronology());	    }	
/** 	     * Gets the end of this time interval, which is exclusive, as a DateTime.	     *	     * @return the end of the time interval	     */	    public DateTime getEnd() {	        return new DateTime(getEndMillis(), getChronology());	    }	
/**	     * Does this time interval contain the specified millisecond instant.	     * <p>	     * Non-zero duration intervals are inclusive of the start instant and	     * exclusive of the end. A zero duration interval cannot contain anything.	     *	     * @param millisInstant  the instant to compare to,	     *  millisecond instant from 1970-01-01T00:00:00Z	     * @return true if this time interval contains the millisecond	     */	    public boolean contains(long millisInstant) {	        long thisStart = getStartMillis();	        long thisEnd = getEndMillis();	        return (millisInstant >= thisStart && millisInstant < thisEnd);	    }	
/**	     * Does this time interval contain the current instant.	     * <p>	     * Non-zero duration intervals are inclusive of the start instant and	     * exclusive of the end. A zero duration interval cannot contain anything.	     *	     * @return true if this time interval contains the current instant	     */	    public boolean containsNow() {	        return contains(DateTimeUtils.currentTimeMillis());	    }	
/**	     * Does this time interval contain the specified instant.	     * <p>	     * Non-zero duration intervals are inclusive of the start instant and	     * exclusive of the end. A zero duration interval cannot contain anything.	     * <p>	     * For example:	     * <pre>	     * [09:00 to 10:00) contains 08:59  = false (before start)	     * [09:00 to 10:00) contains 09:00  = true	     * [09:00 to 10:00) contains 09:59  = true	     * [09:00 to 10:00) contains 10:00  = false (equals end)	     * [09:00 to 10:00) contains 10:01  = false (after end)	     * 	     * [14:00 to 14:00) contains 14:00  = false (zero duration contains nothing)	     * </pre>	     * Passing in a <code>null</code> parameter will have the same effect as	     * calling {@link #containsNow()}.	     *	     * @param instant  the instant, null means now	     * @return true if this time interval contains the instant	     */	    public boolean contains(ReadableInstant instant) {	        if (instant == null) {	            return containsNow();	        }	        return contains(instant.getMillis());	    }	
/**	     * Does this time interval contain the specified time interval.	     * <p>	     * Non-zero duration intervals are inclusive of the start instant and	     * exclusive of the end. The other interval is contained if this interval	     * wholly contains, starts, finishes or equals it.	     * A zero duration interval cannot contain anything.	     * <p>	     * When two intervals are compared the result is one of three states:	     * (a) they abut, (b) there is a gap between them, (c) they overlap.	     * The <code>contains</code> method is not related to these states.	     * In particular, a zero duration interval is contained at the start of	     * a larger interval, but does not overlap (it abuts instead).	     * <p>	     * For example:	     * <pre>	     * [09:00 to 10:00) contains [09:00 to 10:00)  = true	     * [09:00 to 10:00) contains [09:00 to 09:30)  = true	     * [09:00 to 10:00) contains [09:30 to 10:00)  = true	     * [09:00 to 10:00) contains [09:15 to 09:45)  = true	     * [09:00 to 10:00) contains [09:00 to 09:00)  = true	     * 	     * [09:00 to 10:00) contains [08:59 to 10:00)  = false (otherStart before thisStart)	     * [09:00 to 10:00) contains [09:00 to 10:01)  = false (otherEnd after thisEnd)	     * [09:00 to 10:00) contains [10:00 to 10:00)  = false (otherStart equals thisEnd)	     * 	     * [14:00 to 14:00) contains [14:00 to 14:00)  = false (zero duration contains nothing)	     * </pre>	     * Passing in a <code>null</code> parameter will have the same effect as	     * calling {@link #containsNow()}.	     *	     * @param interval  the time interval to compare to, null means a zero duration interval now	     * @return true if this time interval contains the time interval	     */	    public boolean contains(ReadableInterval interval) {	        if (interval == null) {	            return containsNow();	        }	        long otherStart = interval.getStartMillis();	        long otherEnd = interval.getEndMillis();	        long thisStart = getStartMillis();	        long thisEnd = getEndMillis();	        return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd);	    }	
/**	     * Does this time interval overlap the specified time interval.	     * <p>	     * Intervals are inclusive of the start instant and exclusive of the end.	     * An interval overlaps another if it shares some common part of the	     * datetime continuum. 	     * <p>	     * When two intervals are compared the result is one of three states:	     * (a) they abut, (b) there is a gap between them, (c) they overlap.	     * The abuts state takes precedence over the other two, thus a zero duration	     * interval at the start of a larger interval abuts and does not overlap.	     * <p>	     * For example:	     * <pre>	     * [09:00 to 10:00) overlaps [08:00 to 08:30)  = false (completely before)	     * [09:00 to 10:00) overlaps [08:00 to 09:00)  = false (abuts before)	     * [09:00 to 10:00) overlaps [08:00 to 09:30)  = true	     * [09:00 to 10:00) overlaps [08:00 to 10:00)  = true	     * [09:00 to 10:00) overlaps [08:00 to 11:00)  = true	     * 	     * [09:00 to 10:00) overlaps [09:00 to 09:00)  = false (abuts before)	     * [09:00 to 10:00) overlaps [09:00 to 09:30)  = true	     * [09:00 to 10:00) overlaps [09:00 to 10:00)  = true	     * [09:00 to 10:00) overlaps [09:00 to 11:00)  = true	     * 	     * [09:00 to 10:00) overlaps [09:30 to 09:30)  = true	     * [09:00 to 10:00) overlaps [09:30 to 10:00)  = true	     * [09:00 to 10:00) overlaps [09:30 to 11:00)  = true	     * 	     * [09:00 to 10:00) overlaps [10:00 to 10:00)  = false (abuts after)	     * [09:00 to 10:00) overlaps [10:00 to 11:00)  = false (abuts after)	     * 	     * [09:00 to 10:00) overlaps [10:30 to 11:00)  = false (completely after)	     * 	     * [14:00 to 14:00) overlaps [14:00 to 14:00)  = false (abuts before and after)	     * [14:00 to 14:00) overlaps [13:00 to 15:00)  = true	     * </pre>	     *	     * @param interval  the time interval to compare to, null means a zero length interval now	     * @return true if the time intervals overlap	     */	    public boolean overlaps(ReadableInterval interval) {	        long thisStart = getStartMillis();	        long thisEnd = getEndMillis();	        if (interval == null) {	            long now = DateTimeUtils.currentTimeMillis();	            return (thisStart < now && now < thisEnd);	        }  else {	            long otherStart = interval.getStartMillis();	            long otherEnd = interval.getEndMillis();	            return (thisStart < otherEnd && otherStart < thisEnd);	        }	    }	
/**	     * Is this time interval before the specified millisecond instant.	     * <p>	     * Intervals are inclusive of the start instant and exclusive of the end.	     * 	     * @param millisInstant  the instant to compare to,	     *  millisecond instant from 1970-01-01T00:00:00Z	     * @return true if this time interval is before the instant	     */	    public boolean isBefore(long millisInstant) {	        return (getEndMillis() <= millisInstant);	    }	
/**	     * Is this time interval before the current instant.	     * <p>	     * Intervals are inclusive of the start instant and exclusive of the end.	     * 	     * @return true if this time interval is before the current instant	     */	    public boolean isBeforeNow() {	        return isBefore(DateTimeUtils.currentTimeMillis());	    }	
/**	     * Is this time interval before the specified instant.	     * <p>	     * Intervals are inclusive of the start instant and exclusive of the end.	     * 	     * @param instant  the instant to compare to, null means now	     * @return true if this time interval is before the instant	     */	    public boolean isBefore(ReadableInstant instant) {	        if (instant == null) {	            return isBeforeNow();	        }	        return isBefore(instant.getMillis());	    }	
/**	     * Is this time interval entirely before the specified instant.	     * <p>	     * Intervals are inclusive of the start instant and exclusive of the end.	     * 	     * @param interval  the interval to compare to, null means now	     * @return true if this time interval is before the interval specified	     */	    public boolean isBefore(ReadableInterval interval) {	        if (interval == null) {	            return isBeforeNow();	        }	        return isBefore(interval.getStartMillis());	    }	
/**	     * Is this time interval after the specified millisecond instant.	     * <p>	     * Intervals are inclusive of the start instant and exclusive of the end.	     * 	     * @param millisInstant  the instant to compare to,	     *  millisecond instant from 1970-01-01T00:00:00Z	     * @return true if this time interval is after the instant	     */	    public boolean isAfter(long millisInstant) {	        return (getStartMillis() > millisInstant);	    }	
/**	     * Is this time interval after the current instant.	     * <p>	     * Intervals are inclusive of the start instant and exclusive of the end.	     * 	     * @return true if this time interval is after the current instant	     */	    public boolean isAfterNow() {	        return isAfter(DateTimeUtils.currentTimeMillis());	    }	
/**	     * Is this time interval after the specified instant.	     * <p>	     * Intervals are inclusive of the start instant and exclusive of the end.	     * 	     * @param instant  the instant to compare to, null means now	     * @return true if this time interval is after the instant	     */	    public boolean isAfter(ReadableInstant instant) {	        if (instant == null) {	            return isAfterNow();	        }	        return isAfter(instant.getMillis());	    }	
/**	     * Is this time interval entirely after the specified interval.	     * <p>	     * Intervals are inclusive of the start instant and exclusive of the end.	     * Only the end time of the specified interval is used in the comparison.	     * 	     * @param interval  the interval to compare to, null means now	     * @return true if this time interval is after the interval specified	     */	    public boolean isAfter(ReadableInterval interval) {	        long endMillis;	        if (interval == null) {	            endMillis = DateTimeUtils.currentTimeMillis();	        } else {	            endMillis = interval.getEndMillis();	        }	        return (getStartMillis() >= endMillis);	    }	
/**	     * Get this interval as an immutable <code>Interval</code> object.	     *	     * @return the interval as an Interval object	     */	    public Interval toInterval() {	        return new Interval(getStartMillis(), getEndMillis(), getChronology());	    }	
/**	     * Get this time interval as a <code>MutableInterval</code>.	     * <p>	     * This will always return a new <code>MutableInterval</code> with the same interval.	     *	     * @return the time interval as a MutableInterval object	     */	    public MutableInterval toMutableInterval() {	        return new MutableInterval(getStartMillis(), getEndMillis(), getChronology());	    }	
/**	     * Gets the duration of this time interval in milliseconds.	     * <p>	     * The duration is equal to the end millis minus the start millis.	     *	     * @return the duration of the time interval in milliseconds	     * @throws ArithmeticException if the duration exceeds the capacity of a long	     */	    public long toDurationMillis() {	        return FieldUtils.safeAdd(getEndMillis(), -getStartMillis());	    }	
/**	     * Gets the duration of this time interval.	     * <p>	     * The duration is equal to the end millis minus the start millis.	     *	     * @return the duration of the time interval	     * @throws ArithmeticException if the duration exceeds the capacity of a long	     */	    public Duration toDuration() {	        long durMillis = toDurationMillis();	        if (durMillis == 0) {	            return Duration.ZERO;	        } else {	            return new Duration(durMillis);	        }	    }	
/**	     * Converts the duration of the interval to a <code>Period</code> using the	     * All period type.	     * <p>	     * This method should be used to exract the field values describing the	     * difference between the start and end instants.	     *	     * @return a time period derived from the interval	     */	    public Period toPeriod() {	        return new Period(getStartMillis(), getEndMillis(), getChronology());	    }	
/**	     * Converts the duration of the interval to a <code>Period</code> using the	     * specified period type.	     * <p>	     * This method should be used to exract the field values describing the	     * difference between the start and end instants.	     *	     * @param type  the requested type of the duration, null means AllType	     * @return a time period derived from the interval	     */	    public Period toPeriod(PeriodType type) {	        return new Period(getStartMillis(), getEndMillis(), type, getChronology());	    }	
/**	     * Compares this object with the specified object for equality based	     * on start and end millis plus the chronology.	     * All ReadableInterval instances are accepted.	     * <p>	     * To compare the duration of two time intervals, use {@link #toDuration()}	     * to get the durations and compare those.	     *	     * @param readableInterval  a readable interval to check against	     * @return true if the start and end millis are equal	     */	    public boolean equals(Object readableInterval) {	        if (this == readableInterval) {	            return true;	        }	        if (readableInterval instanceof ReadableInterval == false) {	            return false;	        }	        ReadableInterval other = (ReadableInterval) readableInterval;	        return 	            getStartMillis() == other.getStartMillis() &&	            getEndMillis() == other.getEndMillis() &&	            FieldUtils.equals(getChronology(), other.getChronology());	    }	
/**	     * Hashcode compatible with equals method.	     *	     * @return suitable hashcode	     */	    public int hashCode() {	        long start = getStartMillis();	        long end = getEndMillis();	        int result = 97;	        result = 31 * result + ((int) (start ^ (start >>> 32)));	        result = 31 * result + ((int) (end ^ (end >>> 32)));	        result = 31 * result + getChronology().hashCode();	        return result;	    }	
/**	     * Output a string in ISO8601 interval format.	     *	     * @return re-parsable string	     */	    public String toString() {	        DateTimeFormatter printer = ISODateTimeFormat.dateHourMinuteSecondFraction();	        printer = printer.withChronology(getChronology());	        StringBuffer buf = new StringBuffer(48);	        printer.printTo(buf, getStartMillis());	        buf.append('/');	        printer.printTo(buf, getEndMillis());	        return buf.toString();	    }	
/**	     * Constructs a partial with the current time, using ISOChronology in	     * the default zone to extract the fields.	     * <p>	     * The constructor uses the default time zone, resulting in the local time	     * being initialised. Once the constructor is complete, all further calculations	     * are performed without reference to a timezone (by switching to UTC).	     */	    protected BaseLocal() {	        super();	    }	
/**	     * Constructor.	     */	    protected AbstractPeriod() {	        super();	    }	
/**	     * Gets an array of the field types that this period supports.	     * <p>	     * The fields are returned largest to smallest, for example Hours, Minutes, Seconds.	     *	     * @return the fields supported in an array that may be altered, largest to smallest	     */	    public DurationFieldType[] getFieldTypes() {	        DurationFieldType[] result = new DurationFieldType[size()];	        for (int i = 0; i < result.length; i++) {	            result[i] = getFieldType(i);	        }	        return result;	    }	
/**	     * Gets an array of the value of each of the fields that this period supports.	     * <p>	     * The fields are returned largest to smallest, for example Hours, Minutes, Seconds.	     * Each value corresponds to the same array index as <code>getFields()</code>	     *	     * @return the current values of each field in an array that may be altered, largest to smallest	     */	    public int[] getValues() {	        int[] result = new int[size()];	        for (int i = 0; i < result.length; i++) {	            result[i] = getValue(i);	        }	        return result;	    }	
/**	     * Gets the value of one of the fields.	     * <p>	     * If the field type specified is not supported by the period then zero	     * is returned.	     *	     * @param type  the field type to query, null returns zero	     * @return the value of that field, zero if field not supported	     */	    public int get(DurationFieldType type) {	        int index = indexOf(type);	        if (index == -1) {	            return 0;	        }	        return getValue(index);	    }	
/**	     * Checks whether the field specified is supported by this period.	     *	     * @param type  the type to check, may be null which returns false	     * @return true if the field is supported	     */	    public boolean isSupported(DurationFieldType type) {	        return getPeriodType().isSupported(type);	    }	
/**	     * Gets the index of the field in this period.	     *	     * @param type  the type to check, may be null which returns -1	     * @return the index of -1 if not supported	     */	    public int indexOf(DurationFieldType type) {	        return getPeriodType().indexOf(type);	    }	
/**	     * Get this period as an immutable <code>Period</code> object.	     * 	     * @return a Period using the same field set and values	     */	    public Period toPeriod() {	        return new Period(this);	    }	
/**	     * Get this object as a <code>MutablePeriod</code>.	     * <p>	     * This will always return a new <code>MutablePeriod</code> with the same fields.	     * 	     * @return a MutablePeriod using the same field set and values	     */	    public MutablePeriod toMutablePeriod() {	        return new MutablePeriod(this);	    }	
/**	     * Compares this object with the specified object for equality based	     * on the value of each field. All ReadablePeriod instances are accepted.	     * <p>	     * Note that a period of 1 day is not equal to a period of 24 hours,	     * nor is 1 hour equal to 60 minutes. Only periods with the same amount	     * in each field are equal.	     * <p>	     * This is because periods represent an abstracted definition of a time	     * period (eg. a day may not actually be 24 hours, it might be 23 or 25	     * at daylight savings boundary).	     * <p>	     * To compare the actual duration of two periods, convert both to	     * {@link org.joda.time.Duration Duration}s, an operation that emphasises	     * that the result may differ according to the date you choose.	     *	     * @param period  a readable period to check against	     * @return true if all the field values are equal, false if	     *  not or the period is null or of an incorrect type	     */	    public boolean equals(Object period) {	        if (this == period) {	            return true;	        }	        if (period instanceof ReadablePeriod == false) {	            return false;	        }	        ReadablePeriod other = (ReadablePeriod) period;	        if (size() != other.size()) {	            return false;	        }	        for (int i = 0, isize = size(); i < isize; i++) {	            if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {	                return false;	            }	        }	        return true;	    }	
/**	     * Gets a hash code for the period as defined by ReadablePeriod.	     *	     * @return a hash code	     */	    public int hashCode() {	        int total = 17;	        for (int i = 0, isize = size(); i < isize; i++) {	            total = 27 * total + getValue(i);	            total = 27 * total + getFieldType(i).hashCode();	        }	        return total;	    }	
/**	     * Gets the value as a String in the ISO8601 duration format.	     * <p>	     * For example, "P6H3M7S" represents 6 hours, 3 minutes, 7 seconds.	     * <p>	     * For more control over the output, see	     * {@link org.joda.time.format.PeriodFormatterBuilder PeriodFormatterBuilder}.	     *	     * @return the value as an ISO8601 string	     */	    @ToString	    public String toString() {	        return ISOPeriodFormat.standard().print(this);	    }	
/**	     * Uses the specified formatter to convert this period to a String.	     *	     * @param formatter  the formatter to use, null means use <code>toString()</code>.	     * @return the formatted string	     * @since 1.5	     */	    public String toString(PeriodFormatter formatter) {	        if (formatter == null) {	            return toString();	        }	        return formatter.print(this);	    }	
/**	     * Creates a period from a set of field values.	     *	     * @param years  amount of years in this period, which must be zero if unsupported	     * @param months  amount of months in this period, which must be zero if unsupported	     * @param weeks  amount of weeks in this period, which must be zero if unsupported	     * @param days  amount of days in this period, which must be zero if unsupported	     * @param hours  amount of hours in this period, which must be zero if unsupported	     * @param minutes  amount of minutes in this period, which must be zero if unsupported	     * @param seconds  amount of seconds in this period, which must be zero if unsupported	     * @param millis  amount of milliseconds in this period, which must be zero if unsupported	     * @param type  which set of fields this period supports	     * @throws IllegalArgumentException if period type is invalid	     * @throws IllegalArgumentException if an unsupported field's value is non-zero	     */	    protected BasePeriod(int years, int months, int weeks, int days,	                         int hours, int minutes, int seconds, int millis,	                         PeriodType type) {	        super();	        type = checkPeriodType(type);	        iType = type;	        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); // internal method	    }	
/**	     * Creates a period from the given interval endpoints.	     *	     * @param startInstant  interval start, in milliseconds	     * @param endInstant  interval end, in milliseconds	     * @param type  which set of fields this period supports, null means standard	     * @param chrono  the chronology to use, null means ISO default	     * @throws IllegalArgumentException if period type is invalid	     */	    protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) {	        super();	        type = checkPeriodType(type);	        chrono = DateTimeUtils.getChronology(chrono);	        iType = type;	        iValues = chrono.get(this, startInstant, endInstant);	    }	
/**	     * Creates a period from the given interval endpoints.	     *	     * @param startInstant  interval start, null means now	     * @param endInstant  interval end, null means now	     * @param type  which set of fields this period supports, null means standard	     * @throws IllegalArgumentException if period type is invalid	     */	    protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {	        super();	        type = checkPeriodType(type);	        if (startInstant == null && endInstant == null) {	            iType = type;	            iValues = new int[size()];	        } else {	            long startMillis = DateTimeUtils.getInstantMillis(startInstant);	            long endMillis = DateTimeUtils.getInstantMillis(endInstant);	            Chronology chrono = DateTimeUtils.getIntervalChronology(startInstant, endInstant);	            iType = type;	            iValues = chrono.get(this, startMillis, endMillis);	        }	    }	
/**	     * Creates a period from the given duration and end point.	     * <p>	     * The two partials must contain the same fields, thus you can	     * specify two <code>LocalDate</code> objects, or two <code>LocalTime</code>	     * objects, but not one of each.	     * As these are Partial objects, time zones have no effect on the result.	     * <p>	     * The two partials must also both be contiguous - see	     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a	     * definition. Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.	     *	     * @param start  the start of the period, must not be null	     * @param end  the end of the period, must not be null	     * @param type  which set of fields this period supports, null means standard	     * @throws IllegalArgumentException if the partials are null or invalid	     * @since 1.1	     */	    protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) {	        super();	        if (start == null || end == null) {	            throw new IllegalArgumentException("ReadablePartial objects must not be null");	        }	        if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) {	            // for performance	            type = checkPeriodType(type);	            long startMillis = ((BaseLocal) start).getLocalMillis();	            long endMillis = ((BaseLocal) end).getLocalMillis();	            Chronology chrono = start.getChronology();	            chrono = DateTimeUtils.getChronology(chrono);	            iType = type;	            iValues = chrono.get(this, startMillis, endMillis);	        } else {	            if (start.size() != end.size()) {	                throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields");	            }	            for (int i = 0, isize = start.size(); i < isize; i++) {	                if (start.getFieldType(i) != end.getFieldType(i)) {	                    throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields");	                }	            }	            if (DateTimeUtils.isContiguous(start) == false) {	                throw new IllegalArgumentException("ReadablePartial objects must be contiguous");	            }	            iType = checkPeriodType(type);	            Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();	            iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L));	        }	    }	
/**	     * Creates a period from the given start point and duration.	     *	     * @param startInstant  the interval start, null means now	     * @param duration  the duration of the interval, null means zero-length	     * @param type  which set of fields this period supports, null means standard	     */	    protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {	        super();	        type = checkPeriodType(type);	        long startMillis = DateTimeUtils.getInstantMillis(startInstant);	        long durationMillis = DateTimeUtils.getDurationMillis(duration);	        long endMillis = FieldUtils.safeAdd(startMillis, durationMillis);	        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);	        iType = type;	        iValues = chrono.get(this, startMillis, endMillis);	    }	
/**	     * Creates a period from the given duration and end point.	     *	     * @param duration  the duration of the interval, null means zero-length	     * @param endInstant  the interval end, null means now	     * @param type  which set of fields this period supports, null means standard	     */	    protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {	        super();	        type = checkPeriodType(type);	        long durationMillis = DateTimeUtils.getDurationMillis(duration);	        long endMillis = DateTimeUtils.getInstantMillis(endInstant);	        long startMillis = FieldUtils.safeSubtract(endMillis, durationMillis);	        Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);	        iType = type;	        iValues = chrono.get(this, startMillis, endMillis);	    }	
/**	     * Creates a period from the given millisecond duration, which is only really	     * suitable for durations less than one day.	     * <p>	     * Only fields that are precise will be used.	     * Thus the largest precise field may have a large value.	     *	     * @param duration  the duration, in milliseconds	     * @param type  which set of fields this period supports, null means standard	     * @param chrono  the chronology to use, null means ISO default	     * @throws IllegalArgumentException if period type is invalid	     */	    protected BasePeriod(long duration, PeriodType type, Chronology chrono) {	        super();	        type = checkPeriodType(type);	        chrono = DateTimeUtils.getChronology(chrono);	        iType = type;	        iValues = chrono.get(this, duration);	    }	
/**	     * Creates a new period based on another using the {@link ConverterManager}.	     *	     * @param period  the period to convert	     * @param type  which set of fields this period supports, null means use type from object	     * @param chrono  the chronology to use, null means ISO default	     * @throws IllegalArgumentException if period is invalid	     * @throws IllegalArgumentException if an unsupported field's value is non-zero	     */	    protected BasePeriod(Object period, PeriodType type, Chronology chrono) {	        super();	        PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);	        type = (type == null ? converter.getPeriodType(period) : type);	        type = checkPeriodType(type);	        iType = type;	        if (this instanceof ReadWritablePeriod) {	            iValues = new int[size()];	            chrono = DateTimeUtils.getChronology(chrono);	            converter.setInto((ReadWritablePeriod) this, period, chrono);	        } else {	            iValues = new MutablePeriod(period, type, chrono).getValues();	        }	    }	
/**	     * Constructor used when we trust ourselves.	     * Do not expose publically.	     *	     * @param values  the values to use, not null, not cloned	     * @param type  which set of fields this period supports, not null	     */	    protected BasePeriod(int[] values, PeriodType type) {	        super();	        iType = type;	        iValues = values;	    }	
/**	     * Validates a period type, converting nulls to a default value and	     * checking the type is suitable for this instance.	     * 	     * @param type  the type to check, may be null	     * @return the validated type to use, not null	     * @throws IllegalArgumentException if the period type is invalid	     */	    protected PeriodType checkPeriodType(PeriodType type) {	        return DateTimeUtils.getPeriodType(type);	    }	
/**	     * Gets the period type.	     *	     * @return the period type	     */	    public PeriodType getPeriodType() {	        return iType;	    }	
/**	     * Gets the number of fields that this period supports.	     *	     * @return the number of fields supported	     */	    public int size() {	        return iType.size();	    }	
/**	     * Gets the field type at the specified index.	     *	     * @param index  the index to retrieve	     * @return the field at the specified index	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public DurationFieldType getFieldType(int index) {	        return iType.getFieldType(index);	    }	
/**	     * Gets the value at the specified index.	     *	     * @param index  the index to retrieve	     * @return the value of the field at the specified index	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    public int getValue(int index) {	        return iValues[index];	    }	
/**	     * Gets the total millisecond duration of this period relative to a start instant.	     * <p>	     * This method adds the period to the specified instant in order to	     * calculate the duration.	     * <p>	     * An instant must be supplied as the duration of a period varies.	     * For example, a period of 1 month could vary between the equivalent of	     * 28 and 31 days in milliseconds due to different length months.	     * Similarly, a day can vary at Daylight Savings cutover, typically between	     * 23 and 25 hours.	     *	     * @param startInstant  the instant to add the period to, thus obtaining the duration	     * @return the total length of the period as a duration relative to the start instant	     * @throws ArithmeticException if the millis exceeds the capacity of the duration	     */	    public Duration toDurationFrom(ReadableInstant startInstant) {	        long startMillis = DateTimeUtils.getInstantMillis(startInstant);	        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);	        long endMillis = chrono.add(this, startMillis, 1);	        return new Duration(startMillis, endMillis);	    }	
/**	     * Gets the total millisecond duration of this period relative to an	     * end instant.	     * <p>	     * This method subtracts the period from the specified instant in order	     * to calculate the duration.	     * <p>	     * An instant must be supplied as the duration of a period varies.	     * For example, a period of 1 month could vary between the equivalent of	     * 28 and 31 days in milliseconds due to different length months.	     * Similarly, a day can vary at Daylight Savings cutover, typically between	     * 23 and 25 hours.	     *	     * @param endInstant  the instant to subtract the period from, thus obtaining the duration	     * @return the total length of the period as a duration relative to the end instant	     * @throws ArithmeticException if the millis exceeds the capacity of the duration	     */	    public Duration toDurationTo(ReadableInstant endInstant) {	        long endMillis = DateTimeUtils.getInstantMillis(endInstant);	        Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);	        long startMillis = chrono.add(this, endMillis, -1);	        return new Duration(startMillis, endMillis);	    }	
/**	     * Checks whether a field type is supported, and if so adds the new value	     * to the relevent index in the specified array.	     * 	     * @param type  the field type	     * @param values  the array to update	     * @param newValue  the new value to store if successful	     */	    private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) {	        int index = indexOf(type);	        if (index == -1) {	            if (newValue != 0) {	                throw new IllegalArgumentException(	                    "Period does not support field '" + type.getName() + "'");	            }	        } else {	            values[index] = newValue;	        }	    }	
/**	     * Sets all the fields of this period from another.	     * 	     * @param period  the period to copy from, not null	     * @throws IllegalArgumentException if an unsupported field's value is non-zero	     */	    protected void setPeriod(ReadablePeriod period) {	        if (period == null) {	            setValues(new int[size()]);	        } else {	            setPeriodInternal(period);	        }	    }	
/**	     * Private method called from constructor.	     */	    private void setPeriodInternal(ReadablePeriod period) {	        int[] newValues = new int[size()];	        for (int i = 0, isize = period.size(); i < isize; i++) {	            DurationFieldType type = period.getFieldType(i);	            int value = period.getValue(i);	            checkAndUpdate(type, newValues, value);	        }	        iValues = newValues;	    }	
/**	     * Sets the eight standard the fields in one go.	     * 	     * @param years  amount of years in this period, which must be zero if unsupported	     * @param months  amount of months in this period, which must be zero if unsupported	     * @param weeks  amount of weeks in this period, which must be zero if unsupported	     * @param days  amount of days in this period, which must be zero if unsupported	     * @param hours  amount of hours in this period, which must be zero if unsupported	     * @param minutes  amount of minutes in this period, which must be zero if unsupported	     * @param seconds  amount of seconds in this period, which must be zero if unsupported	     * @param millis  amount of milliseconds in this period, which must be zero if unsupported	     * @throws IllegalArgumentException if an unsupported field's value is non-zero	     */	    protected void setPeriod(int years, int months, int weeks, int days,	                             int hours, int minutes, int seconds, int millis) {	        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis);	    }	
/**	     * Private method called from constructor.	     */	    private void setPeriodInternal(int years, int months, int weeks, int days,	                                   int hours, int minutes, int seconds, int millis) {	        int[] newValues = new int[size()];	        checkAndUpdate(DurationFieldType.years(), newValues, years);	        checkAndUpdate(DurationFieldType.months(), newValues, months);	        checkAndUpdate(DurationFieldType.weeks(), newValues, weeks);	        checkAndUpdate(DurationFieldType.days(), newValues, days);	        checkAndUpdate(DurationFieldType.hours(), newValues, hours);	        checkAndUpdate(DurationFieldType.minutes(), newValues, minutes);	        checkAndUpdate(DurationFieldType.seconds(), newValues, seconds);	        checkAndUpdate(DurationFieldType.millis(), newValues, millis);	        iValues = newValues;	    }	
/**	     * Sets the value of a field in this period.	     * 	     * @param field  the field to set	     * @param value  the value to set	     * @throws IllegalArgumentException if field is is null or not supported.	     */	    protected void setField(DurationFieldType field, int value) {	        setFieldInto(iValues, field, value);	    }	
/**	     * Sets the value of a field in this period.	     * 	     * @param values  the array of values to update	     * @param field  the field to set	     * @param value  the value to set	     * @throws IllegalArgumentException if field is null or not supported.	     */	    protected void setFieldInto(int[] values, DurationFieldType field, int value) {	        int index = indexOf(field);	        if (index == -1) {	            if (value != 0 || field == null) {	                throw new IllegalArgumentException(	                    "Period does not support field '" + field + "'");	            }	        } else {	            values[index] = value;	        }	    }	
/**	     * Adds the value of a field in this period.	     * 	     * @param field  the field to set	     * @param value  the value to set	     * @throws IllegalArgumentException if field is is null or not supported.	     */	    protected void addField(DurationFieldType field, int value) {	        addFieldInto(iValues, field, value);	    }	
/**	     * Adds the value of a field in this period.	     * 	     * @param values  the array of values to update	     * @param field  the field to set	     * @param value  the value to set	     * @throws IllegalArgumentException if field is is null or not supported.	     */	    protected void addFieldInto(int[] values, DurationFieldType field, int value) {	        int index = indexOf(field);	        if (index == -1) {	            if (value != 0 || field == null) {	                throw new IllegalArgumentException(	                    "Period does not support field '" + field + "'");	            }	        } else {	            values[index] = FieldUtils.safeAdd(values[index], value);	        }	    }	
/**	     * Merges the fields from another period.	     * 	     * @param period  the period to add from, not null	     * @throws IllegalArgumentException if an unsupported field's value is non-zero	     */	    protected void mergePeriod(ReadablePeriod period) {	        if (period != null) {	            iValues = mergePeriodInto(getValues(), period);	        }	    }	
/**	     * Merges the fields from another period.	     * 	     * @param values  the array of values to update	     * @param period  the period to add from, not null	     * @return the updated values	     * @throws IllegalArgumentException if an unsupported field's value is non-zero	     */	    protected int[] mergePeriodInto(int[] values, ReadablePeriod period) {	         for (int i = 0, isize = period.size(); i < isize; i++) {	             DurationFieldType type = period.getFieldType(i);	             int value = period.getValue(i);	             checkAndUpdate(type, values, value);	         }	         return values;	    }	
/**	     * Adds the fields from another period.	     * 	     * @param period  the period to add from, not null	     * @throws IllegalArgumentException if an unsupported field's value is non-zero	     */	    protected void addPeriod(ReadablePeriod period) {	        if (period != null) {	            iValues = addPeriodInto(getValues(), period);	        }	    }	
/**	     * Adds the fields from another period.	     * 	     * @param values  the array of values to update	     * @param period  the period to add from, not null	     * @return the updated values	     * @throws IllegalArgumentException if an unsupported field's value is non-zero	     */	    protected int[] addPeriodInto(int[] values, ReadablePeriod period) {	         for (int i = 0, isize = period.size(); i < isize; i++) {	             DurationFieldType type = period.getFieldType(i);	             int value = period.getValue(i);	             if (value != 0) {	                 int index = indexOf(type);	                 if (index == -1) {	                     throw new IllegalArgumentException(	                         "Period does not support field '" + type.getName() + "'");	                 } else {	                     values[index] = FieldUtils.safeAdd(getValue(index), value);	                 }	             }	         }	         return values;	    }	
/**	     * Sets the value of the field at the specifed index.	     * 	     * @param index  the index	     * @param value  the value to set	     * @throws IndexOutOfBoundsException if the index is invalid	     */	    protected void setValue(int index, int value) {	        iValues[index] = value;	    }	
/**	     * Sets the values of all fields.	     * 	     * @param values  the array of values	     */	    protected void setValues(int[] values) {	        iValues = values;	    }	
/**	     * Constructor.	     */	    protected BaseDateTimeField(DateTimeFieldType type) {	        super();	        if (type == null) {	            throw new IllegalArgumentException("The type must not be null");	        }	        iType = type;	    }	
public final DateTimeFieldType getType() {	        return iType;	    }	
public final String getName() {	        return iType.getName();	    }	
/**	     * @return true always	     */	    public final boolean isSupported() {	        return true;	    }	
/**	     * Get the human-readable, text value of this field from the milliseconds.	     * If the specified locale is null, the default locale is used.	     * <p>	     * The default implementation returns getAsText(get(instant), locale).	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query	     * @param locale the locale to use for selecting a text symbol, null means default	     * @return the text value of the field	     */	    public String getAsText(long instant, Locale locale) {	        return getAsText(get(instant), locale);	    }	
/**	     * Get the human-readable, text value of this field from the milliseconds.	     * <p>	     * The default implementation calls {@link #getAsText(long, Locale)}.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query	     * @return the text value of the field	     */	    public final String getAsText(long instant) {	        return getAsText(instant, null);	    }	
/**	     * Get the human-readable, text value of this field from a partial instant.	     * If the specified locale is null, the default locale is used.	     * <p>	     * The default implementation returns getAsText(fieldValue, locale).	     *	     * @param partial  the partial instant to query	     * @param fieldValue  the field value of this field, provided for performance	     * @param locale  the locale to use for selecting a text symbol, null for default	     * @return the text value of the field	     */	    public String getAsText(ReadablePartial partial, int fieldValue, Locale locale) {	        return getAsText(fieldValue, locale);	    }	
/**	     * Get the human-readable, text value of this field from a partial instant.	     * If the specified locale is null, the default locale is used.	     * <p>	     * The default implementation calls {@link ReadablePartial#get(DateTimeFieldType)}	     * and {@link #getAsText(ReadablePartial, int, Locale)}.	     *	     * @param partial  the partial instant to query	     * @param locale  the locale to use for selecting a text symbol, null for default	     * @return the text value of the field	     */	    public final String getAsText(ReadablePartial partial, Locale locale) {	        return getAsText(partial, partial.get(getType()), locale);	    }	
/**	     * Get the human-readable, text value of this field from the field value.	     * If the specified locale is null, the default locale is used.	     * <p>	     * The default implementation returns Integer.toString(get(instant)).	     * <p>	     * Note: subclasses that override this method should also override	     * getMaximumTextLength.	     *	     * @param fieldValue  the numeric value to convert to text	     * @param locale the locale to use for selecting a text symbol, null for default	     * @return the text value of the field	     */	    public String getAsText(int fieldValue, Locale locale) {	        return Integer.toString(fieldValue);	    }	
/**	     * Get the human-readable, short text value of this field from the milliseconds.	     * If the specified locale is null, the default locale is used.	     * <p>	     * The default implementation returns getAsShortText(get(instant), locale).	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query	     * @param locale the locale to use for selecting a text symbol, null means default	     * @return the text value of the field	     */	    public String getAsShortText(long instant, Locale locale) {	        return getAsShortText(get(instant), locale);	    }	
/**	     * Get the human-readable, short text value of this field from the milliseconds.	     * <p>	     * The default implementation calls {@link #getAsShortText(long, Locale)}.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query	     * @return the text value of the field	     */	    public final String getAsShortText(long instant) {	        return getAsShortText(instant, null);	    }	
/**	     * Get the human-readable, short text value of this field from a partial instant.	     * If the specified locale is null, the default locale is used.	     * <p>	     * The default implementation returns getAsShortText(fieldValue, locale).	     *	     * @param partial  the partial instant to query	     * @param fieldValue  the field value of this field, provided for performance	     * @param locale  the locale to use for selecting a text symbol, null for default	     * @return the text value of the field	     */	    public String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) {	        return getAsShortText(fieldValue, locale);	    }	
/**	     * Get the human-readable, short text value of this field from a partial instant.	     * If the specified locale is null, the default locale is used.	     * <p>	     * The default implementation calls {@link ReadablePartial#get(DateTimeFieldType)}	     * and {@link #getAsText(ReadablePartial, int, Locale)}.	     *	     * @param partial  the partial instant to query	     * @param locale  the locale to use for selecting a text symbol, null for default	     * @return the text value of the field	     */	    public final String getAsShortText(ReadablePartial partial, Locale locale) {	        return getAsShortText(partial, partial.get(getType()), locale);	    }	
/**	     * Get the human-readable, short text value of this field from the field value.	     * If the specified locale is null, the default locale is used.	     * <p>	     * The default implementation returns getAsText(fieldValue, locale).	     * <p>	     * Note: subclasses that override this method should also override	     * getMaximumShortTextLength.	     *	     * @param fieldValue  the numeric value to convert to text	     * @param locale the locale to use for selecting a text symbol, null for default	     * @return the text value of the field	     */	    public String getAsShortText(int fieldValue, Locale locale) {	        return getAsText(fieldValue, locale);	    }	
/**	     * Adds a value (which may be negative) to the instant value,	     * overflowing into larger fields if necessary.	     * <p>	     * The value will be added to this field. If the value is too large to be	     * added solely to this field, larger fields will increase as required.	     * Smaller fields should be unaffected, except where the result would be	     * an invalid value for a smaller field. In this case the smaller field is	     * adjusted to be in range.	     * <p>	     * For example, in the ISO chronology:<br>	     * 2000-08-20 add six months is 2001-02-20<br>	     * 2000-08-20 add twenty months is 2002-04-20<br>	     * 2000-08-20 add minus nine months is 1999-11-20<br>	     * 2001-01-31 add one month  is 2001-02-28<br>	     * 2001-01-31 add two months is 2001-03-31<br>	     * 	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to	     * @param value  the value to add, in the units of the field	     * @return the updated milliseconds	     */	    public long add(long instant, int value) {	        return getDurationField().add(instant, value);	    }	
/**	     * Adds a value (which may be negative) to the instant value,	     * overflowing into larger fields if necessary.	     * 	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to	     * @param value  the long value to add, in the units of the field	     * @return the updated milliseconds	     * @throws IllegalArgumentException if value is too large	     * @see #add(long,int)	     */	    public long add(long instant, long value) {	        return getDurationField().add(instant, value);	    }	
/**	     * Adds a value (which may be negative) to the partial instant,	     * throwing an exception if the maximum size of the instant is reached.	     * <p>	     * The value will be added to this field, overflowing into larger fields	     * if necessary. Smaller fields should be unaffected, except where the	     * result would be an invalid value for a smaller field. In this case the	     * smaller field is adjusted to be in range.	     * <p>	     * Partial instants only contain some fields. This may result in a maximum	     * possible value, such as TimeOfDay being limited to 23:59:59:999. If this	     * limit is breached by the add an exception is thrown.	     * <p>	     * For example, in the ISO chronology:<br>	     * 2000-08-20 add six months is 2000-02-20<br>	     * 2000-08-20 add twenty months is 2000-04-20<br>	     * 2000-08-20 add minus nine months is 2000-11-20<br>	     * 2001-01-31 add one month  is 2001-02-28<br>	     * 2001-01-31 add two months is 2001-03-31<br>	     * 	     * @param instant  the partial instant	     * @param fieldIndex  the index of this field in the partial	     * @param values  the values of the partial instant which should be updated	     * @param valueToAdd  the value to add, in the units of the field	     * @return the passed in values	     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached	     */	    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {	        if (valueToAdd == 0) {	            return values;	        }	        // there are more efficient algorithms than this (especially for time only fields)	        // trouble is when dealing with days and months, so we use this technique of	        // adding/removing one from the larger field at a time	        DateTimeField nextField = null;	        	        while (valueToAdd > 0) {	            int max = getMaximumValue(instant, values);	            long proposed = values[fieldIndex] + valueToAdd;	            if (proposed <= max) {	                values[fieldIndex] = (int) proposed;	                break;	            }	            if (nextField == null) {	                if (fieldIndex == 0) {	                    throw new IllegalArgumentException("Maximum value exceeded for add");	                }	                nextField = instant.getField(fieldIndex - 1);	                // test only works if this field is UTC (ie. local)	                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {	                    throw new IllegalArgumentException("Fields invalid for add");	                }	            }	            valueToAdd -= (max + 1) - values[fieldIndex];  // reduce the amount to add	            values = nextField.add(instant, fieldIndex - 1, values, 1);  // add 1 to next bigger field	            values[fieldIndex] = getMinimumValue(instant, values);  // reset this field to zero	        }	        while (valueToAdd < 0) {	            int min = getMinimumValue(instant, values);	            long proposed = values[fieldIndex] + valueToAdd;	            if (proposed >= min) {	                values[fieldIndex] = (int) proposed;	                break;	            }	            if (nextField == null) {	                if (fieldIndex == 0) {	                    throw new IllegalArgumentException("Maximum value exceeded for add");	                }	                nextField = instant.getField(fieldIndex - 1);	                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {	                    throw new IllegalArgumentException("Fields invalid for add");	                }	            }	            valueToAdd -= (min - 1) - values[fieldIndex];  // reduce the amount to add	            values = nextField.add(instant, fieldIndex - 1, values, -1);  // subtract 1 from next bigger field	            values[fieldIndex] = getMaximumValue(instant, values);  // reset this field to max value	        }	        	        return set(instant, fieldIndex, values, values[fieldIndex]);  // adjusts smaller fields	    }	
/**	     * Adds a value (which may be negative) to the partial instant,	     * wrapping the whole partial if the maximum size of the partial is reached.	     * <p>	     * The value will be added to this field, overflowing into larger fields	     * if necessary. Smaller fields should be unaffected, except where the	     * result would be an invalid value for a smaller field. In this case the	     * smaller field is adjusted to be in range.	     * <p>	     * Partial instants only contain some fields. This may result in a maximum	     * possible value, such as TimeOfDay normally being limited to 23:59:59:999.	     * If ths limit is reached by the addition, this method will wrap back to	     * 00:00:00.000. In fact, you would generally only use this method for	     * classes that have a limitation such as this.	     * <p>	     * For example, in the ISO chronology:<br>	     * 10:20:30 add 20 minutes is 10:40:30<br>	     * 10:20:30 add 45 minutes is 11:05:30<br>	     * 10:20:30 add 16 hours is 02:20:30<br>	     * 	     * @param instant  the partial instant	     * @param fieldIndex  the index of this field in the partial	     * @param values  the values of the partial instant which should be updated	     * @param valueToAdd  the value to add, in the units of the field	     * @return the passed in values	     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached	     */	    public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {	        if (valueToAdd == 0) {	            return values;	        }	        // there are more efficient algorithms than this (especially for time only fields)	        // trouble is when dealing with days and months, so we use this technique of	        // adding/removing one from the larger field at a time	        DateTimeField nextField = null;	        	        while (valueToAdd > 0) {	            int max = getMaximumValue(instant, values);	            long proposed = values[fieldIndex] + valueToAdd;	            if (proposed <= max) {	                values[fieldIndex] = (int) proposed;	                break;	            }	            if (nextField == null) {	                if (fieldIndex == 0) {	                    valueToAdd -= (max + 1) - values[fieldIndex];	                    values[fieldIndex] = getMinimumValue(instant, values);	                    continue;	                }	                nextField = instant.getField(fieldIndex - 1);	                // test only works if this field is UTC (ie. local)	                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {	                    throw new IllegalArgumentException("Fields invalid for add");	                }	            }	            valueToAdd -= (max + 1) - values[fieldIndex];  // reduce the amount to add	            values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1);  // add 1 to next bigger field	            values[fieldIndex] = getMinimumValue(instant, values);  // reset this field to zero	        }	        while (valueToAdd < 0) {	            int min = getMinimumValue(instant, values);	            long proposed = values[fieldIndex] + valueToAdd;	            if (proposed >= min) {	                values[fieldIndex] = (int) proposed;	                break;	            }	            if (nextField == null) {	                if (fieldIndex == 0) {	                    valueToAdd -= (min - 1) - values[fieldIndex];	                    values[fieldIndex] = getMaximumValue(instant, values);	                    continue;	                }	                nextField = instant.getField(fieldIndex - 1);	                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {	                    throw new IllegalArgumentException("Fields invalid for add");	                }	            }	            valueToAdd -= (min - 1) - values[fieldIndex];  // reduce the amount to add	            values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1);  // subtract 1 from next bigger field	            values[fieldIndex] = getMaximumValue(instant, values);  // reset this field to max value	        }	        	        return set(instant, fieldIndex, values, values[fieldIndex]);  // adjusts smaller fields	    }	
/**	     * Adds a value (which may be negative) to the instant value,	     * wrapping within this field.	     * <p>	     * The value will be added to this field. If the value is too large to be	     * added solely to this field then it wraps. Larger fields are always	     * unaffected. Smaller fields should be unaffected, except where the	     * result would be an invalid value for a smaller field. In this case the	     * smaller field is adjusted to be in range.	     * <p>	     * For example, in the ISO chronology:<br>	     * 2000-08-20 addWrapField six months is 2000-02-20<br>	     * 2000-08-20 addWrapField twenty months is 2000-04-20<br>	     * 2000-08-20 addWrapField minus nine months is 2000-11-20<br>	     * 2001-01-31 addWrapField one month  is 2001-02-28<br>	     * 2001-01-31 addWrapField two months is 2001-03-31<br>	     * <p>	     * The default implementation internally calls set. Subclasses are	     * encouraged to provide a more efficient implementation.	     * 	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to	     * @param value  the value to add, in the units of the field	     * @return the updated milliseconds	     */	    public long addWrapField(long instant, int value) {	        int current = get(instant);	        int wrapped = FieldUtils.getWrappedValue	            (current, value, getMinimumValue(instant), getMaximumValue(instant));	        return set(instant, wrapped);	    }	
/**	     * Adds a value (which may be negative) to the partial instant,	     * wrapping within this field.	     * <p>	     * The value will be added to this field. If the value is too large to be	     * added solely to this field then it wraps. Larger fields are always	     * unaffected. Smaller fields should be unaffected, except where the	     * result would be an invalid value for a smaller field. In this case the	     * smaller field is adjusted to be in range.	     * <p>	     * For example, in the ISO chronology:<br>	     * 2000-08-20 addWrapField six months is 2000-02-20<br>	     * 2000-08-20 addWrapField twenty months is 2000-04-20<br>	     * 2000-08-20 addWrapField minus nine months is 2000-11-20<br>	     * 2001-01-31 addWrapField one month  is 2001-02-28<br>	     * 2001-01-31 addWrapField two months is 2001-03-31<br>	     * <p>	     * The default implementation internally calls set. Subclasses are	     * encouraged to provide a more efficient implementation.	     * 	     * @param instant  the partial instant	     * @param fieldIndex  the index of this field in the instant	     * @param values  the values of the partial instant which should be updated	     * @param valueToAdd  the value to add, in the units of the field	     * @return the passed in values	     * @throws IllegalArgumentException if the value is invalid	     */	    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {	        int current = values[fieldIndex];	        int wrapped = FieldUtils.getWrappedValue	            (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));	        return set(instant, fieldIndex, values, wrapped);  // adjusts smaller fields	    }	
/**	     * Computes the difference between two instants, as measured in the units	     * of this field. Any fractional units are dropped from the result. Calling	     * getDifference reverses the effect of calling add. In the following code:	     *	     * <pre>	     * long instant = ...	     * int v = ...	     * int age = getDifference(add(instant, v), instant);	     * </pre>	     *	     * The value 'age' is the same as the value 'v'.	     *	     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to	     * subtract from	     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to	     * subtract off the minuend	     * @return the difference in the units of this field	     */	    public int getDifference(long minuendInstant, long subtrahendInstant) {	        return getDurationField().getDifference(minuendInstant, subtrahendInstant);	    }	
/**	     * Computes the difference between two instants, as measured in the units	     * of this field. Any fractional units are dropped from the result. Calling	     * getDifference reverses the effect of calling add. In the following code:	     *	     * <pre>	     * long instant = ...	     * long v = ...	     * long age = getDifferenceAsLong(add(instant, v), instant);	     * </pre>	     *	     * The value 'age' is the same as the value 'v'.	     *	     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to	     * subtract from	     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to	     * subtract off the minuend	     * @return the difference in the units of this field	     */	    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);	    }	
/**	     * Sets a value using the specified partial instant.	     * <p>	     * The value of this field (specified by the index) will be set.	     * If the value is invalid, an exception if thrown.	     * <p>	     * If setting this field would make other fields invalid, then those fields	     * may be changed. For example if the current date is the 31st January, and	     * the month is set to February, the day would be invalid. Instead, the day	     * would be changed to the closest value - the 28th/29th February as appropriate.	     * 	     * @param partial  the partial instant	     * @param fieldIndex  the index of this field in the instant	     * @param values  the values to update	     * @param newValue  the value to set, in the units of the field	     * @return the updated values	     * @throws IllegalArgumentException if the value is invalid	     */	    public int[] set(ReadablePartial partial, int fieldIndex, int[] values, int newValue) {	        FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(partial, values), getMaximumValue(partial, values));	        values[fieldIndex] = newValue;	        	        // may need to adjust smaller fields	        for (int i = fieldIndex + 1; i < partial.size(); i++) {	            DateTimeField field = partial.getField(i);	            if (values[i] > field.getMaximumValue(partial, values)) {	                values[i] = field.getMaximumValue(partial, values);	            }	            if (values[i] < field.getMinimumValue(partial, values)) {	                values[i] = field.getMinimumValue(partial, values);	            }	        }	        return values;	    }	
/**	     * Sets a value in the milliseconds supplied from a human-readable, text value.	     * If the specified locale is null, the default locale is used.	     * <p>	     * This implementation uses <code>convertText(String, Locale)</code> and	     * {@link #set(long, int)}.	     * <p>	     * Note: subclasses that override this method should also override	     * getAsText.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in	     * @param text  the text value to set	     * @param locale the locale to use for selecting a text symbol, null for default	     * @return the updated milliseconds	     * @throws IllegalArgumentException if the text value is invalid	     */	    public long set(long instant, String text, Locale locale) {	        int value = convertText(text, locale);	        return set(instant, value);	    }	
/**	     * Sets a value in the milliseconds supplied from a human-readable, text value.	     * <p>	     * This implementation uses {@link #set(long, String, Locale)}.	     * <p>	     * Note: subclasses that override this method should also override getAsText.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in	     * @param text  the text value to set	     * @return the updated milliseconds	     * @throws IllegalArgumentException if the text value is invalid	     */	    public final long set(long instant, String text) {	        return set(instant, text, null);	    }	
/**	     * Sets a value in the milliseconds supplied from a human-readable, text value.	     * If the specified locale is null, the default locale is used.	     * <p>	     * This implementation uses <code>convertText(String, Locale)</code> and	     * {@link #set(ReadablePartial, int, int[], int)}.	     *	     * @param instant  the partial instant	     * @param fieldIndex  the index of this field in the instant	     * @param values  the values of the partial instant which should be updated	     * @param text  the text value to set	     * @param locale the locale to use for selecting a text symbol, null for default	     * @return the passed in values	     * @throws IllegalArgumentException if the text value is invalid	     */	    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {	        int value = convertText(text, locale);	        return set(instant, fieldIndex, values, value);	    }	
/**	     * Convert the specified text and locale into a value.	     * 	     * @param text  the text to convert	     * @param locale  the locale to convert using	     * @return the value extracted from the text	     * @throws IllegalArgumentException if the text is invalid	     */	    protected int convertText(String text, Locale locale) {	        try {	            return Integer.parseInt(text);	        } catch (NumberFormatException ex) {	            throw new IllegalFieldValueException(getType(), text);	        }	    }	
/**	     * Returns whether this field is 'leap' for the specified instant.	     * <p>	     * For example, a leap year would return true, a non leap year would return	     * false.	     * <p>	     * This implementation returns false.	     * 	     * @return true if the field is 'leap'	     */	    public boolean isLeap(long instant) {	        return false;	    }	
/**	     * Gets the amount by which this field is 'leap' for the specified instant.	     * <p>	     * For example, a leap year would return one, a non leap year would return	     * zero.	     * <p>	     * This implementation returns zero.	     */	    public int getLeapAmount(long instant) {	        return 0;	    }	
/**	     * If this field were to leap, then it would be in units described by the	     * returned duration. If this field doesn't ever leap, null is returned.	     * <p>	     * This implementation returns null.	     */	    public DurationField getLeapDurationField() {	        return null;	    }	
/**	     * Get the minimum value for this field evaluated at the specified time.	     * <p>	     * This implementation returns the same as {@link #getMinimumValue()}.	     * 	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query	     * @return the minimum value for this field, in the units of the field	     */	    public int getMinimumValue(long instant) {	        return getMinimumValue();	    }	
/**	     * Get the minimum value for this field evaluated at the specified instant.	     * <p>	     * This implementation returns the same as {@link #getMinimumValue()}.	     * 	     * @param instant  the partial instant to query	     * @return the minimum value for this field, in the units of the field	     */	    public int getMinimumValue(ReadablePartial instant) {	        return getMinimumValue();	    }	
/**	     * Get the minimum value for this field using the partial instant and	     * the specified values.	     * <p>	     * This implementation returns the same as {@link #getMinimumValue(ReadablePartial)}.	     * 	     * @param instant  the partial instant to query	     * @param values  the values to use	     * @return the minimum value for this field, in the units of the field	     */	    public int getMinimumValue(ReadablePartial instant, int[] values) {	        return getMinimumValue(instant);	    }	
/**	     * Get the maximum value for this field evaluated at the specified time.	     * <p>	     * This implementation returns the same as {@link #getMaximumValue()}.	     * 	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query	     * @return the maximum value for this field, in the units of the field	     */	    public int getMaximumValue(long instant) {	        return getMaximumValue();	    }	
/**	     * Get the maximum value for this field evaluated at the specified instant.	     * <p>	     * This implementation returns the same as {@link #getMaximumValue()}.	     * 	     * @param instant  the partial instant to query	     * @return the maximum value for this field, in the units of the field	     */	    public int getMaximumValue(ReadablePartial instant) {	        return getMaximumValue();	    }	
/**	     * Get the maximum value for this field using the partial instant and	     * the specified values.	     * <p>	     * This implementation returns the same as {@link #getMaximumValue(ReadablePartial)}.	     * 	     * @param instant  the partial instant to query	     * @param values  the values to use	     * @return the maximum value for this field, in the units of the field	     */	    public int getMaximumValue(ReadablePartial instant, int[] values) {	        return getMaximumValue(instant);	    }	
/**	     * Get the maximum text value for this field. The default implementation	     * returns the equivalent of Integer.toString(getMaximumValue()).length().	     * 	     * @param locale  the locale to use for selecting a text symbol	     * @return the maximum text length	     */	    public int getMaximumTextLength(Locale locale) {	        int max = getMaximumValue();	        if (max >= 0) {	            if (max < 10) {	                return 1;	            } else if (max < 100) {	                return 2;	            } else if (max < 1000) {	                return 3;	            }	        }	        return Integer.toString(max).length();	    }	
/**	     * Get the maximum short text value for this field. The default	     * implementation returns getMaximumTextLength().	     * 	     * @param locale  the locale to use for selecting a text symbol	     * @return the maximum short text length	     */	    public int getMaximumShortTextLength(Locale locale) {	        return getMaximumTextLength(locale);	    }	
/**	     * Round to the highest whole unit of this field. The value of this field	     * and all fields of a higher magnitude may be incremented in order to	     * achieve this result. The fractional millis that cannot be expressed in	     * whole increments of this field are set to minimum.	     * <p>	     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the	     * highest whole hour is 2002-11-03T00:00:00.000.	     * <p>	     * The default implementation calls roundFloor, and if the instant is	     * modified as a result, adds one field unit. Subclasses are encouraged to	     * provide a more efficient implementation.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round	     * @return rounded milliseconds	     */	    public long roundCeiling(long instant) {	        long newInstant = roundFloor(instant);	        if (newInstant != instant) {	            instant = add(newInstant, 1);	        }	        return instant;	    }	
/**	     * Round to the nearest whole unit of this field. If the given millisecond	     * value is closer to the floor or is exactly halfway, this function	     * behaves like roundFloor. If the millisecond value is closer to the	     * ceiling, this function behaves like roundCeiling.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round	     * @return rounded milliseconds	     */	    public long roundHalfFloor(long instant) {	        long floor = roundFloor(instant);	        long ceiling = roundCeiling(instant);		        long diffFromFloor = instant - floor;	        long diffToCeiling = ceiling - instant;		        if (diffFromFloor <= diffToCeiling) {	            // Closer to the floor, or halfway - round floor	            return floor;	        } else {	            return ceiling;	        }	    }	
/**	     * Round to the nearest whole unit of this field. If the given millisecond	     * value is closer to the floor, this function behaves like roundFloor. If	     * the millisecond value is closer to the ceiling or is exactly halfway,	     * this function behaves like roundCeiling.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round	     * @return rounded milliseconds	     */	    public long roundHalfCeiling(long instant) {	        long floor = roundFloor(instant);	        long ceiling = roundCeiling(instant);		        long diffFromFloor = instant - floor;	        long diffToCeiling = ceiling - instant;		        if (diffToCeiling <= diffFromFloor) {	            // Closer to the ceiling, or halfway - round ceiling	            return ceiling;	        } else {	            return floor;	        }	    }	
/**	     * Round to the nearest whole unit of this field. If the given millisecond	     * value is closer to the floor, this function behaves like roundFloor. If	     * the millisecond value is closer to the ceiling, this function behaves	     * like roundCeiling.	     * <p>	     * If the millisecond value is exactly halfway between the floor and	     * ceiling, the ceiling is chosen over the floor only if it makes this	     * field's value even.	     *	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round	     * @return rounded milliseconds	     */	    public long roundHalfEven(long instant) {	        long floor = roundFloor(instant);	        long ceiling = roundCeiling(instant);		        long diffFromFloor = instant - floor;	        long diffToCeiling = ceiling - instant;		        if (diffFromFloor < diffToCeiling) {	            // Closer to the floor - round floor	            return floor;	        } else if (diffToCeiling < diffFromFloor) {	            // Closer to the ceiling - round ceiling	            return ceiling;	        } else {	            // Round to the instant that makes this field even. If both values	            // make this field even (unlikely), favor the ceiling.	            if ((get(ceiling) & 1) == 0) {	                return ceiling;	            }	            return floor;	        }	    }	
/**	     * Returns the fractional duration milliseconds of this field. In other	     * words, calling remainder returns the duration that roundFloor would	     * subtract.	     * <p>	     * For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by	     * hour is 34 minutes and 56.789 seconds.	     * <p>	     * The default implementation computes	     * <code>instant - roundFloor(instant)</code>. Subclasses are encouraged to	     * provide a more efficient implementation.	     *	     * @param instant the milliseconds from 1970-01-01T00:00:00Z to get the	     * remainder	     * @return remainder duration, in milliseconds	     */	    public long remainder(long instant) {	        return instant - roundFloor(instant);	    }	
/**	     * Get a suitable debug string.	     * 	     * @return debug string	     */	    public String toString() {	        return "DateTimeField[" + getName() + ']';	    }	
/**	     * Constructor.	     * 	     * @param type  the field type this field uses	     * @param unit  precise unit duration, like "seconds()".	     * @param range precise range duration, preferably a multiple of the unit,	     * like "minutes()".	     * @throws IllegalArgumentException if either duration field is imprecise	     * @throws IllegalArgumentException if unit milliseconds is less than one	     * or effective value range is less than two.	     */	    public PreciseDateTimeField(DateTimeFieldType type,	                                DurationField unit, DurationField range) {	        super(type, unit);		        if (!range.isPrecise()) {	            throw new IllegalArgumentException("Range duration field must be precise");	        }		        long rangeMillis = range.getUnitMillis();	        iRange = (int)(rangeMillis / getUnitMillis());	        if (iRange < 2) {	            throw new IllegalArgumentException("The effective range must be at least 2");	        }		        iRangeField = range;	    }	
/**	     * Get the amount of fractional units from the specified time instant.	     * 	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query	     * @return the amount of fractional units extracted from the input.	     */	    public int get(long instant) {	        if (instant >= 0) {	            return (int) ((instant / getUnitMillis()) % iRange);	        } else {	            return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);	        }	    }	
/**	     * Add to the component of the specified time instant, wrapping around	     * within that component if necessary.	     * 	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to	     * @param amount  the amount of units to add (can be negative).	     * @return the updated time instant.	     */	    public long addWrapField(long instant, int amount) {	        int thisValue = get(instant);	        int wrappedValue = FieldUtils.getWrappedValue	            (thisValue, amount, getMinimumValue(), getMaximumValue());	        // copy code from set() to avoid repeat call to get()	        return instant + (wrappedValue - thisValue) * getUnitMillis();	    }	
/**	     * Set the specified amount of units to the specified time instant.	     * 	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in	     * @param value  value of units to set.	     * @return the updated time instant.	     * @throws IllegalArgumentException if value is too large or too small.	     */	    public long set(long instant, int value) {	        FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());	        return instant + (value - get(instant)) * iUnitMillis;	    }	
/**	     * Returns the range duration of this field. For example, if this field	     * represents "minute of hour", then the range duration field is an hours.	     *	     * @return the range duration of this field, or null if field has no range	     */	    public DurationField getRangeDurationField() {	        return iRangeField;	    }	
/**	     * Get the maximum value for the field.	     * 	     * @return the maximum value	     */	    public int getMaximumValue() {	        return iRange - 1;	    }	
/**	     * Returns the range of the field in the field's units.	     * <p>	     * For example, 60 for seconds per minute. The field is allowed values	     * from 0 to range - 1.	     * 	     * @return unit range	     */	    public int getRange() {	        return iRange;	    }	
/**	     * Constructor.	     * 	     * @param type  the field type	     * @param unitMillis  the unit milliseconds	     */    	    public PreciseDurationField(DurationFieldType type, long unitMillis) {	        super(type);	        iUnitMillis = unitMillis;	    }	
/**	     * This field is precise.	     * 	     * @return true always	     */	    public final boolean isPrecise() {	        return true;	    }	
/**	     * Returns the amount of milliseconds per unit value of this field.	     *	     * @return the unit size of this field, in milliseconds	     */	    public final long getUnitMillis() {	        return iUnitMillis;	    }	
/**	     * Get the value of this field from the milliseconds.	     * 	     * @param duration  the milliseconds to query, which may be negative	     * @param instant  ignored	     * @return the value of the field, in the units of the field, which may be	     * negative	     */	    public long getValueAsLong(long duration, long instant) {	        return duration / iUnitMillis;  // safe	    }	
/**	     * Get the millisecond duration of this field from its value.	     * 	     * @param value  the value of the field, which may be negative	     * @param instant  ignored	     * @return the milliseconds that the field represents, which may be	     * negative	     */	    public long getMillis(int value, long instant) {	        return value * iUnitMillis;  // safe	    }	
/**	     * Get the millisecond duration of this field from its value.	     * 	     * @param value  the value of the field, which may be negative	     * @param instant  ignored	     * @return the milliseconds that the field represents, which may be	     * negative	     */	    public long getMillis(long value, long instant) {	        return FieldUtils.safeMultiply(value, iUnitMillis);	    }	
public long add(long instant, int value) {	        long addition = value * iUnitMillis;  // safe	        return FieldUtils.safeAdd(instant, addition);	    }	
public long add(long instant, long value) {	        long addition = FieldUtils.safeMultiply(value, iUnitMillis);	        return FieldUtils.safeAdd(instant, addition);	    }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        long difference = FieldUtils.safeSubtract(minuendInstant, subtrahendInstant);	        return difference / iUnitMillis;	    }	
/**	     * Compares this duration field to another.	     * Two fields are equal if of the same type and duration.	     * 	     * @param obj  the object to compare to	     * @return if equal	     */	    public boolean equals(Object obj) {	        if (this == obj) {	            return true;	        } else if (obj instanceof PreciseDurationField) {	            PreciseDurationField other = (PreciseDurationField) obj;	            return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis);	        }	        return false;	    }	
/**	     * Gets a hash code for this instance.	     * 	     * @return a suitable hashcode	     */	    public int hashCode() {	        long millis = iUnitMillis;	        int hash = (int) (millis ^ (millis >>> 32));	        hash += getType().hashCode();	        return hash;	    }	
/**	     * Constructor.	     * 	     * @param field  the field being decorated	     * @param type  allow type to be overridden	     */	    protected DecoratedDateTimeField(DateTimeField field, DateTimeFieldType type) {	        super(type);	        if (field == null) {	            throw new IllegalArgumentException("The field must not be null");	        }	        if (!field.isSupported()) {	            throw new IllegalArgumentException("The field must be supported");	        }	        iField = field;	    }	
/**	     * Gets the wrapped date time field.	     * 	     * @return the wrapped DateTimeField	     */	    public final DateTimeField getWrappedField() {	        return iField;	    }	
public boolean isLenient() {	        return iField.isLenient();	    }	
public int get(long instant) {	        return iField.get(instant);	    }	
public long set(long instant, int value) {	        return iField.set(instant, value);	    }	
public DurationField getDurationField() {	        return iField.getDurationField();	    }	
public DurationField getRangeDurationField() {	        return iField.getRangeDurationField();	    }	
public int getMinimumValue() {	        return iField.getMinimumValue();	    }	
public int getMaximumValue() {	        return iField.getMaximumValue();	    }	
public long roundFloor(long instant) {	        return iField.roundFloor(instant);	    }	
/**	     * Constructor.	     * 	     * @param field  the field to wrap, like "year()".	     * @param type  the field type this field actually uses	     * @param divisor  divisor, such as 100 years in a century	     * @throws IllegalArgumentException if divisor is less than two	     */	    public RemainderDateTimeField(DateTimeField field,	                                  DateTimeFieldType type, int divisor) {	        super(field, type);		        if (divisor < 2) {	            throw new IllegalArgumentException("The divisor must be at least 2");	        }		        DurationField rangeField = field.getDurationField();	        if (rangeField == null) {	            iRangeField = null;	        } else {	            iRangeField = new ScaledDurationField(	                rangeField, type.getRangeDurationType(), divisor);	        }		        iDivisor = divisor;	    }	
/**	     * Construct a RemainderDateTimeField that compliments the given	     * DividedDateTimeField.	     *	     * @param dividedField  complimentary divided field, like "century()".	     */	    public RemainderDateTimeField(DividedDateTimeField dividedField) {	        this(dividedField, dividedField.getType());	    }	
/**	     * Construct a RemainderDateTimeField that compliments the given	     * DividedDateTimeField.	     *	     * @param dividedField  complimentary divided field, like "century()".	     * @param type  the field type this field actually uses	     */	    public RemainderDateTimeField(DividedDateTimeField dividedField, DateTimeFieldType type) {	        super(dividedField.getWrappedField(), type);	        iDivisor = dividedField.iDivisor;	        iRangeField = dividedField.iDurationField;	    }	
/**	     * Get the remainder from the specified time instant.	     * 	     * @param instant  the time instant in millis to query.	     * @return the remainder extracted from the input.	     */	    public int get(long instant) {	        int value = getWrappedField().get(instant);	        if (value >= 0) {	            return value % iDivisor;	        } else {	            return (iDivisor - 1) + ((value + 1) % iDivisor);	        }	    }	
/**	     * Add the specified amount to the specified time instant, wrapping around	     * within the remainder range if necessary. The amount added may be	     * negative.	     * 	     * @param instant  the time instant in millis to update.	     * @param amount  the amount to add (can be negative).	     * @return the updated time instant.	     */	    public long addWrapField(long instant, int amount) {	        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, 0, iDivisor - 1));	    }	
/**	     * Set the specified amount of remainder units to the specified time instant.	     * 	     * @param instant  the time instant in millis to update.	     * @param value  value of remainder units to set.	     * @return the updated time instant.	     * @throws IllegalArgumentException if value is too large or too small.	     */	    public long set(long instant, int value) {	        FieldUtils.verifyValueBounds(this, value, 0, iDivisor - 1);	        int divided = getDivided(getWrappedField().get(instant));	        return getWrappedField().set(instant, divided * iDivisor + value);	    }	
/**	     * Returns a scaled version of the wrapped field's unit duration field.	     */	    public DurationField getRangeDurationField() {	        return iRangeField;	    }	
/**	     * Get the minimum value for the field, which is always zero.	     * 	     * @return the minimum value of zero.	     */	    public int getMinimumValue() {	        return 0;	    }	
/**	     * Get the maximum value for the field, which is always one less than the	     * divisor.	     * 	     * @return the maximum value	     */	    public int getMaximumValue() {	        return iDivisor - 1;	    }	
public long roundFloor(long instant) {	        return getWrappedField().roundFloor(instant);	    }	
public long roundCeiling(long instant) {	        return getWrappedField().roundCeiling(instant);	    }	
public long roundHalfFloor(long instant) {	        return getWrappedField().roundHalfFloor(instant);	    }	
public long roundHalfCeiling(long instant) {	        return getWrappedField().roundHalfCeiling(instant);	    }	
public long roundHalfEven(long instant) {	        return getWrappedField().roundHalfEven(instant);	    }	
public long remainder(long instant) {	        return getWrappedField().remainder(instant);	    }	
/**	     * Returns the divisor applied, in the field's units.	     * 	     * @return the divisor	     */	    public int getDivisor() {	        return iDivisor;	    }	
private int getDivided(int value) {	        if (value >= 0) {	            return value / iDivisor;	        } else {	            return ((value + 1) / iDivisor) - 1;	        }	    }	
/**	     * Constructor.	     * 	     * @param type  the field type	     * @param unit  precise unit duration, like "days()".	     * @throws IllegalArgumentException if duration field is imprecise	     * @throws IllegalArgumentException if unit milliseconds is less than one	     */	    public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) {	        super(type);		        if (!unit.isPrecise()) {	            throw new IllegalArgumentException("Unit duration field must be precise");	        }		        iUnitMillis = unit.getUnitMillis();	        if (iUnitMillis < 1) {	            throw new IllegalArgumentException("The unit milliseconds must be at least 1");	        }		        iUnitField = unit;	    }	
/**	     * Returns false by default.	     */	    public boolean isLenient() {	        return false;	    }	
/**	     * Set the specified amount of units to the specified time instant.	     * 	     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in	     * @param value  value of units to set.	     * @return the updated time instant.	     * @throws IllegalArgumentException if value is too large or too small.	     */	    public long set(long instant, int value) {	        FieldUtils.verifyValueBounds(this, value, getMinimumValue(),	                                     getMaximumValueForSet(instant, value));	        return instant + (value - get(instant)) * iUnitMillis;	    }	
/**	     * This method assumes that this field is properly rounded on	     * 1970-01-01T00:00:00. If the rounding alignment differs, override this	     * method as follows:	     * <pre>	     * return super.roundFloor(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;	     * </pre>	     */	    public long roundFloor(long instant) {	        if (instant >= 0) {	            return instant - instant % iUnitMillis;	        } else {	            instant += 1;	            return instant - instant % iUnitMillis - iUnitMillis;	        }	    }	
/**	     * This method assumes that this field is properly rounded on	     * 1970-01-01T00:00:00. If the rounding alignment differs, override this	     * method as follows:	     * <pre>	     * return super.roundCeiling(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;	     * </pre>	     */	    public long roundCeiling(long instant) {	        if (instant > 0) {	            instant -= 1;	            return instant - instant % iUnitMillis + iUnitMillis;	        } else {	            return instant - instant % iUnitMillis;	        }	    }	
/**	     * This method assumes that this field is properly rounded on	     * 1970-01-01T00:00:00. If the rounding alignment differs, override this	     * method as follows:	     * <pre>	     * return super.remainder(instant + ALIGNMENT_MILLIS);	     * </pre>	     */	    public long remainder(long instant) {	        if (instant >= 0) {	            return instant % iUnitMillis;	        } else {	            return (instant + 1) % iUnitMillis + iUnitMillis - 1;	        }	    }	
/**	     * Returns the duration per unit value of this field. For example, if this	     * field represents "minute of hour", then the duration field is minutes.	     *	     * @return the duration of this field, or UnsupportedDurationField if field	     * has no duration	     */	    public DurationField getDurationField() {	        return iUnitField;	    }	
/**	     * Get the minimum value for the field.	     * 	     * @return the minimum value	     */	    public int getMinimumValue() {	        return 0;	    }	
public final long getUnitMillis() {	        return iUnitMillis;	    }	
/**	     * Called by the set method to get the maximum allowed value. By default,	     * returns getMaximumValue(instant). Override to provide a faster	     * implementation.	     */	    protected int getMaximumValueForSet(long instant, int value) {	        return getMaximumValue(instant);	    }	
/**	     * Constructor.	     * 	     * @param type  the field type	     * @param unitMillis  the average duration unit milliseconds	     */	    public ImpreciseDateTimeField(DateTimeFieldType type, long unitMillis) {	        super(type);	        iUnitMillis = unitMillis;	        iDurationField = new LinkedDurationField(type.getDurationType());	    }	
/**	     * Computes the difference between two instants, as measured in the units	     * of this field. Any fractional units are dropped from the result. Calling	     * getDifference reverses the effect of calling add. In the following code:	     *	     * <pre>	     * long instant = ...	     * int v = ...	     * int age = getDifference(add(instant, v), instant);	     * </pre>	     *	     * The value 'age' is the same as the value 'v'.	     * <p>	     * The default implementation call getDifferenceAsLong and converts the	     * return value to an int.	     *	     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to	     * subtract from	     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to	     * subtract off the minuend	     * @return the difference in the units of this field	     */	    public int getDifference(long minuendInstant, long subtrahendInstant) {	        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));	    }	
/**	     * Computes the difference between two instants, as measured in the units	     * of this field. Any fractional units are dropped from the result. Calling	     * getDifference reverses the effect of calling add. In the following code:	     *	     * <pre>	     * long instant = ...	     * long v = ...	     * long age = getDifferenceAsLong(add(instant, v), instant);	     * </pre>	     *	     * The value 'age' is the same as the value 'v'.	     * <p>	     * The default implementation performs a guess-and-check algorithm using	     * getDurationField().getUnitMillis() and the add() method. Subclasses are	     * encouraged to provide a more efficient implementation.	     *	     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to	     * subtract from	     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to	     * subtract off the minuend	     * @return the difference in the units of this field	     */	    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        if (minuendInstant < subtrahendInstant) {	            return -getDifferenceAsLong(subtrahendInstant, minuendInstant);	        }	        	        long difference = (minuendInstant - subtrahendInstant) / iUnitMillis;	        if (add(subtrahendInstant, difference) < minuendInstant) {	            do {	                difference++;	            } while (add(subtrahendInstant, difference) <= minuendInstant);	            difference--;	        } else if (add(subtrahendInstant, difference) > minuendInstant) {	            do {	                difference--;	            } while (add(subtrahendInstant, difference) > minuendInstant);	        }	        return difference;	    }	
public final DurationField getDurationField() {	        return iDurationField;	    }	
protected final long getDurationUnitMillis() {	        return iUnitMillis;	    }	
LinkedDurationField(DurationFieldType type) {	            super(type);	        }	
public boolean isPrecise() {	            return false;	        }	
public long getUnitMillis() {	            return iUnitMillis;	        }	
public int getValue(long duration, long instant) {	            return ImpreciseDateTimeField.this	                .getDifference(instant + duration, instant);	        }	
public long getValueAsLong(long duration, long instant) {	            return ImpreciseDateTimeField.this	                .getDifferenceAsLong(instant + duration, instant);	        }	
public long getMillis(int value, long instant) {	            return ImpreciseDateTimeField.this.add(instant, value) - instant;	        }	
public long getMillis(long value, long instant) {	            return ImpreciseDateTimeField.this.add(instant, value) - instant;	        }	
public long add(long instant, int value) {	            return ImpreciseDateTimeField.this.add(instant, value);	        }	
public long add(long instant, long value) {	            return ImpreciseDateTimeField.this.add(instant, value);	        }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	            return ImpreciseDateTimeField.this	                .getDifference(minuendInstant, subtrahendInstant);	        }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	            return ImpreciseDateTimeField.this	                .getDifferenceAsLong(minuendInstant, subtrahendInstant);	        }	
/**	     * Constructor.	     */	    public AbstractReadableInstantFieldProperty() {	        super();	    }	
/**	     * Gets the field type being used.	     * 	     * @return the field type	     */	    public DateTimeFieldType getFieldType() {	        return getField().getType();	    }	
/**	     * Gets the name of the field.	     * 	     * @return the field name	     */	    public String getName() {	        return getField().getName();	    }	
/**	     * Gets the chronology of the datetime that this property is linked to.	     * <p>	     * This implementation throws UnsupportedOperationException, and must be	     * implemented by subclasses to enable the equals() and hashCode() methods.	     * 	     * @return the chronology	     * @since 1.4	     */	    protected Chronology getChronology() {	        throw new UnsupportedOperationException(	                "The method getChronology() was added in v1.4 and needs " +	                "to be implemented by subclasses of AbstractReadableInstantFieldProperty");	    }	
/**	     * Gets the value of this property from the instant.	     * <p>	     * For example, the following two lines of code are equivalent:	     * <pre>	     * datetime.getDayOfMonth();	     * datetime.dayOfMonth().get();	     * </pre>	     * 	     * @return the current value	     * @see DateTimeField#get	     */	    public int get() {	        return getField().get(getMillis());	    }	
/**	     * Gets the value of this property from the instant as a string.	     * <p>	     * This method returns the value converted to a <code>String</code>	     * using <code>Integer.toString</code>. This method does NOT return	     * textual descriptions such as 'Monday' or 'January'.	     * See {@link #getAsText()} and {@link #getAsShortText()} for those.	     * 	     * @return the current value	     * @see DateTimeField#get	     * @since 1.1	     */	    public String getAsString() {	        return Integer.toString(get());	    }	
/**	     * Gets the textual value of this property from the instant as a	     * string in the default locale.	     * <p>	     * This method returns the value converted to a <code>String</code>	     * returning the appropriate textual description wherever possible.	     * Thus, a day of week of 1 would return 'Monday' in English.	     * 	     * @return the current text value	     * @see DateTimeField#getAsText	     */	    public String getAsText() {	        return getAsText(null);	    }	
/**	     * Gets the textual value of this property from the instant as a	     * string in the specified locale.	     * <p>	     * This method returns the value converted to a <code>String</code>	     * returning the appropriate textual description wherever possible.	     * Thus, a day of week of 1 would return 'Monday' in English.	     * 	     * @param locale  locale to use for selecting a text symbol, null means default	     * @return the current text value	     * @see DateTimeField#getAsText	     */	    public String getAsText(Locale locale) {	        return getField().getAsText(getMillis(), locale);	    }	
/**	     * Gets the short textual value of this property from the instant as a	     * string in the default locale.	     * <p>	     * This method returns the value converted to a <code>String</code>	     * returning the appropriate textual description wherever possible.	     * Thus, a day of week of 1 would return 'Mon' in English.	     * 	     * @return the current text value	     * @see DateTimeField#getAsShortText	     */	    public String getAsShortText() {	        return getAsShortText(null);	    }	
/**	     * Gets the short textual value of this property from the instant as a	     * string in the specified locale.	     * <p>	     * This method returns the value converted to a <code>String</code>	     * returning the appropriate textual description wherever possible.	     * Thus, a day of week of 1 would return 'Mon' in English.	     * 	     * @param locale  locale to use for selecting a text symbol, null means default	     * @return the current text value	     * @see DateTimeField#getAsShortText	     */	    public String getAsShortText(Locale locale) {	        return getField().getAsShortText(getMillis(), locale);	    }	
/**	     * Returns the difference between this field property instant and the one	     * passed in, in the units of this field. The sign of the difference	     * matches that of compareTo. In other words, this field property's instant	     * is the minuend.	     *	     * @param instant  the subtrahend, null means now	     * @return the difference in the units of this field	     * @see DateTimeField#getDifference	     */	    public int getDifference(ReadableInstant instant) {	        if (instant == null) {	            return getField().getDifference(getMillis(), DateTimeUtils.currentTimeMillis());	        }	        return getField().getDifference(getMillis(), instant.getMillis());	    }	
/**	     * Returns the difference between this field property instant and the one	     * passed in, in the units of this field. The sign of the difference	     * matches that of compareTo. In other words, this field property's instant	     * is the minuend.	     *	     * @param instant  the subtrahend, null means now	     * @return the difference in the units of this field	     * @see DateTimeField#getDifference	     */	    public long getDifferenceAsLong(ReadableInstant instant) {	        if (instant == null) {	            return getField().getDifferenceAsLong(getMillis(), DateTimeUtils.currentTimeMillis());	        }	        return getField().getDifferenceAsLong(getMillis(), instant.getMillis());	    }	
/**	     * Returns the duration per unit value of this field. For example, if this	     * field represents "hour of day", then the duration is an hour.	     *	     * @return the duration of this field, or UnsupportedDurationField	     */	    public DurationField getDurationField() {	        return getField().getDurationField();	    }	
/**	     * Returns the range duration of this field. For example, if this field	     * represents "hour of day", then the range duration is a day.	     *	     * @return the range duration of this field, or null if field has no range	     */	    public DurationField getRangeDurationField() {	        return getField().getRangeDurationField();	    }	
/**	     * Gets whether this field is leap.	     * 	     * @return true if a leap field	     * @see DateTimeField#isLeap	     */	    public boolean isLeap() {	        return getField().isLeap(getMillis());	    }	
/**	     * Gets the amount by which this field is leap.	     * 	     * @return the amount by which the field is leap	     * @see DateTimeField#getLeapAmount	     */	    public int getLeapAmount() {	        return getField().getLeapAmount(getMillis());	    }	
/**	     * If this field were to leap, then it would be in units described by the	     * returned duration. If this field doesn't ever leap, null is returned.	     */	    public DurationField getLeapDurationField() {	        return getField().getLeapDurationField();	    }	
/**	     * Gets the minimum value for the field ignoring the current time.	     * 	     * @return the minimum value	     * @see DateTimeField#getMinimumValue	     */	    public int getMinimumValueOverall() {	        return getField().getMinimumValue();	    }	
/**	     * Gets the minimum value for the field.	     * 	     * @return the minimum value	     * @see DateTimeField#getMinimumValue	     */	    public int getMinimumValue() {	        return getField().getMinimumValue(getMillis());	    }	
/**	     * Gets the maximum value for the field ignoring the current time.	     * 	     * @return the maximum value	     * @see DateTimeField#getMaximumValue	     */	    public int getMaximumValueOverall() {	        return getField().getMaximumValue();	    }	
/**	     * Gets the maximum value for the field.	     * 	     * @return the maximum value	     * @see DateTimeField#getMaximumValue	     */	    public int getMaximumValue() {	        return getField().getMaximumValue(getMillis());	    }	
/**	     * Gets the maximum text length for the field.	     * 	     * @param locale  optional locale to use for selecting a text symbol	     * @return the maximum length	     * @see DateTimeField#getMaximumTextLength	     */	    public int getMaximumTextLength(Locale locale) {	        return getField().getMaximumTextLength(locale);	    }	
/**	     * Gets the maximum short text length for the field.	     * 	     * @param locale  optional locale to use for selecting a text symbol	     * @return the maximum length	     * @see DateTimeField#getMaximumShortTextLength	     */	    public int getMaximumShortTextLength(Locale locale) {	        return getField().getMaximumShortTextLength(locale);	    }	
/**	     * Returns the fractional duration milliseconds of this field.	     *	     * @see DateTimeField#remainder	     * @return remainder duration, in milliseconds	     */	    public long remainder() {	        return getField().remainder(getMillis());	    }	
/**	     * Returns the interval that represents the range of the minimum	     * and maximum values of this field.	     * <p>	     * For example, <code>datetime.monthOfYear().toInterval()</code>	     * will return an interval over the whole month.	     *	     * @return the interval of this field	     * @since 1.2	     */	    public Interval toInterval() {	        DateTimeField field = getField();	        long start = field.roundFloor(getMillis());	        long end = field.add(start, 1);	        Interval interval = new Interval(start, end);	        return interval;	    }	
/**	     * Compare this field to the same field on another instant.	     * <p>	     * The comparison is based on the value of the same field type, irrespective	     * of any difference in chronology. Thus, if this property represents the	     * hourOfDay field, then the hourOfDay field of the other instant will be queried	     * whether in the same chronology or not.	     * 	     * @param instant  the instant to compare to	     * @return negative value if this is less, 0 if equal, or positive value if greater	     * @throws IllegalArgumentException if the instant is null	     */	    public int compareTo(ReadableInstant instant) {	        if (instant == null) {	            throw new IllegalArgumentException("The instant must not be null");	        }	        int thisValue = get();	        int otherValue = instant.get(getFieldType());	        if (thisValue < otherValue) {	            return -1;	        } else if (thisValue > otherValue) {	            return 1;	        } else {	            return 0;	        }	    }	
/**	     * Compare this field to the same field on another partial instant.	     * <p>	     * The comparison is based on the value of the same field type, irrespective	     * of any difference in chronology. Thus, if this property represents the	     * hourOfDay field, then the hourOfDay field of the other partial will be queried	     * whether in the same chronology or not.	     * 	     * @param partial  the partial to compare to	     * @return negative value if this is less, 0 if equal, or positive value if greater	     * @throws IllegalArgumentException if the partial is null	     * @throws IllegalArgumentException if the partial doesn't support this field	     */	    public int compareTo(ReadablePartial partial) {	        if (partial == null) {	            throw new IllegalArgumentException("The partial must not be null");	        }	        int thisValue = get();	        int otherValue = partial.get(getFieldType());	        if (thisValue < otherValue) {	            return -1;	        } else if (thisValue > otherValue) {	            return 1;	        } else {	            return 0;	        }	    }	
/**	     * Compares this property to another.	     * 	     * @param object  the object to compare to	     * @return true if equal	     */	    public boolean equals(Object object) {	        if (this == object) {	            return true;	        }	        if (object instanceof AbstractReadableInstantFieldProperty == false) {	            return false;	        }	        AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object;	        return 	            get() == other.get() &&	            getFieldType().equals(other.getFieldType()) &&	            FieldUtils.equals(getChronology(), other.getChronology());	    }	
/**	     * Returns a hashcode compatible with the equals method.	     * 	     * @return the hashcode	     */	    public int hashCode() {	        return get() * 17 + getFieldType().hashCode() + getChronology().hashCode();	    }	
/**	     * Output a debugging string.	     * 	     * @return debugging string	     */	    public String toString() {	        return "Property[" + getName() + "]";	    }	
/**	     * Constructor.	     * 	     * @param field  the base field	     * @param type  the type to actually use	     */	    public DecoratedDurationField(DurationField field, DurationFieldType type) {	        super(type);	        if (field == null) {	            throw new IllegalArgumentException("The field must not be null");	        }	        if (!field.isSupported()) {	            throw new IllegalArgumentException("The field must be supported");	        }	        iField = field;	    }	
/**	     * Gets the wrapped duration field.	     * 	     * @return the wrapped DurationField	     */	    public final DurationField getWrappedField() {	        return iField;	    }	
public boolean isPrecise() {	        return iField.isPrecise();	    }	
public long getValueAsLong(long duration, long instant) {	        return iField.getValueAsLong(duration, instant);	    }	
public long getMillis(int value, long instant) {	        return iField.getMillis(value, instant);	    }	
public long getMillis(long value, long instant) {	        return iField.getMillis(value, instant);	    }	
public long add(long instant, int value) {	        return iField.add(instant, value);	    }	
public long add(long instant, long value) {	        return iField.add(instant, value);	    }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);	    }	
public long getUnitMillis() {	        return iField.getUnitMillis();	    }	
/**	     * Returns a strict version of the given field. If it is already strict,	     * then it is returned as-is. Otherwise, a new StrictDateTimeField is	     * returned.	     */	    public static DateTimeField getInstance(DateTimeField field) {	        if (field == null) {	            return null;	        }	        if (field instanceof LenientDateTimeField) {	            field = ((LenientDateTimeField)field).getWrappedField();	        }	        if (!field.isLenient()) {	            return field;	        }	        return new StrictDateTimeField(field);	    }	
protected StrictDateTimeField(DateTimeField field) {	        super(field);	    }	
public final boolean isLenient() {	        return false;	    }	
/**	     * Does a bounds check before setting the value.	     *	     * @throws IllegalArgumentException if the value is invalid	     */	    public long set(long instant, int value) {	        FieldUtils.verifyValueBounds	            (this, value, getMinimumValue(instant), getMaximumValue(instant));	        return super.set(instant, value);	    }	
/**	     * Constructor	     * 	     * @param field  the field to wrap, like "year()".	     * @param type  the type this field will actually use	     * @param scalar  scalar, such as 100 years in a century	     * @throws IllegalArgumentException if scalar is zero or one.	     */	    public ScaledDurationField(DurationField field, DurationFieldType type, int scalar) {	        super(field, type);	        if (scalar == 0 || scalar == 1) {	            throw new IllegalArgumentException("The scalar must not be 0 or 1");	        }	        iScalar = scalar;	    }	
public int getValue(long duration) {	        return getWrappedField().getValue(duration) / iScalar;	    }	
public long getValueAsLong(long duration) {	        return getWrappedField().getValueAsLong(duration) / iScalar;	    }	
public int getValue(long duration, long instant) {	        return getWrappedField().getValue(duration, instant) / iScalar;	    }	
public long getValueAsLong(long duration, long instant) {	        return getWrappedField().getValueAsLong(duration, instant) / iScalar;	    }	
public long getMillis(int value) {	        long scaled = ((long) value) * ((long) iScalar);	        return getWrappedField().getMillis(scaled);	    }	
public long getMillis(long value) {	        long scaled = FieldUtils.safeMultiply(value, iScalar);	        return getWrappedField().getMillis(scaled);	    }	
public long getMillis(int value, long instant) {	        long scaled = ((long) value) * ((long) iScalar);	        return getWrappedField().getMillis(scaled, instant);	    }	
public long getMillis(long value, long instant) {	        long scaled = FieldUtils.safeMultiply(value, iScalar);	        return getWrappedField().getMillis(scaled, instant);	    }	
public long add(long instant, int value) {	        long scaled = ((long) value) * ((long) iScalar);	        return getWrappedField().add(instant, scaled);	    }	
public long add(long instant, long value) {	        long scaled = FieldUtils.safeMultiply(value, iScalar);	        return getWrappedField().add(instant, scaled);	    }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	        return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iScalar;	    }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iScalar;	    }	
public long getUnitMillis() {	        return getWrappedField().getUnitMillis() * iScalar;	    }	
/**	     * Returns the scalar applied, in the field's units.	     * 	     * @return the scalar	     */	    public int getScalar() {	        return iScalar;	    }	
/**	     * Compares this duration field to another.	     * Two fields are equal if of the same type and duration.	     * 	     * @param obj  the object to compare to	     * @return if equal	     */	    public boolean equals(Object obj) {	        if (this == obj) {	            return true;	        } else if (obj instanceof ScaledDurationField) {	            ScaledDurationField other = (ScaledDurationField) obj;	            return (getWrappedField().equals(other.getWrappedField())) &&	                   (getType() == other.getType()) &&	                   (iScalar == other.iScalar);	        }	        return false;	    }	
/**	     * Gets a hash code for this instance.	     * 	     * @return a suitable hashcode	     */	    public int hashCode() {	        long scalar = iScalar;	        int hash = (int) (scalar ^ (scalar >>> 32));	        hash += getType().hashCode();	        hash += getWrappedField().hashCode();	        return hash;	    }	
protected BaseDurationField(DurationFieldType type) {	        super();	        if (type == null) {	            throw new IllegalArgumentException("The type must not be null");	        }	        iType = type;	    }	
public final DurationFieldType getType() {	        return iType;	    }	
public final String getName() {	        return iType.getName();	    }	
/**	     * @return true always	     */	    public final boolean isSupported() {	        return true;	    }	
/**	     * Get the value of this field from the milliseconds, which is approximate	     * if this field is imprecise.	     *	     * @param duration  the milliseconds to query, which may be negative	     * @return the value of the field, in the units of the field, which may be	     * negative	     */	    public int getValue(long duration) {	        return FieldUtils.safeToInt(getValueAsLong(duration));	    }	
/**	     * Get the value of this field from the milliseconds, which is approximate	     * if this field is imprecise.	     *	     * @param duration  the milliseconds to query, which may be negative	     * @return the value of the field, in the units of the field, which may be	     * negative	     */	    public long getValueAsLong(long duration) {	        return duration / getUnitMillis();	    }	
/**	     * Get the value of this field from the milliseconds relative to an	     * instant.	     *	     * <p>If the milliseconds is positive, then the instant is treated as a	     * "start instant". If negative, the instant is treated as an "end	     * instant".	     *	     * <p>The default implementation returns	     * <code>Utils.safeToInt(getAsLong(millisDuration, instant))</code>.	     * 	     * @param duration  the milliseconds to query, which may be negative	     * @param instant  the start instant to calculate relative to	     * @return the value of the field, in the units of the field, which may be	     * negative	     */	    public int getValue(long duration, long instant) {	        return FieldUtils.safeToInt(getValueAsLong(duration, instant));	    }	
/**	     * Get the millisecond duration of this field from its value, which is	     * approximate if this field is imprecise.	     * 	     * @param value  the value of the field, which may be negative	     * @return the milliseconds that the field represents, which may be	     * negative	     */	    public long getMillis(int value) {	        return value * getUnitMillis();  // safe	    }	
/**	     * Get the millisecond duration of this field from its value, which is	     * approximate if this field is imprecise.	     * 	     * @param value  the value of the field, which may be negative	     * @return the milliseconds that the field represents, which may be	     * negative	     */	    public long getMillis(long value) {	        return FieldUtils.safeMultiply(value, getUnitMillis());	    }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));	    }	
public int compareTo(DurationField otherField) {	        long otherMillis = otherField.getUnitMillis();	        long thisMillis = getUnitMillis();	        // cannot do (thisMillis - otherMillis) as can overflow	        if (thisMillis == otherMillis) {	            return 0;	        }	        if (thisMillis < otherMillis) {	            return -1;	        } else {	            return 1;	        }	    }	
/**	     * Get a suitable debug string.	     * 	     * @return debug string	     */	    public String toString() {	        return "DurationField[" + getName() + ']';	    }	
/**	     * Gets an instance of UnsupportedDurationField for a specific named field.	     * The returned instance is cached.	     * 	     * @param type  the type to obtain	     * @return the instance	     */	    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {	        UnsupportedDurationField field;	        if (cCache == null) {	            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);	            field = null;	        } else {	            field = cCache.get(type);	        }	        if (field == null) {	            field = new UnsupportedDurationField(type);	            cCache.put(type, field);	        }	        return field;	    }	
/**	     * Constructor.	     * 	     * @param type  the type to use	     */	    private UnsupportedDurationField(DurationFieldType type) {	        iType = type;	    }	
public final DurationFieldType getType() {	        return iType;	    }	
public String getName() {	        return iType.getName();	    }	
/**	     * This field is not supported.	     *	     * @return false always	     */	    public boolean isSupported() {	        return false;	    }	
/**	     * This field is precise.	     * 	     * @return true always	     */	    public boolean isPrecise() {	        return true;	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int getValue(long duration) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long getValueAsLong(long duration) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int getValue(long duration, long instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long getValueAsLong(long duration, long instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long getMillis(int value) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long getMillis(long value) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long getMillis(int value, long instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long getMillis(long value, long instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long add(long instant, int value) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long add(long instant, long value) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int getDifference(long minuendInstant, long subtrahendInstant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        throw unsupported();	    }	
/**	     * Always returns zero.	     *	     * @return zero always	     */	    public long getUnitMillis() {	        return 0;	    }	
/**	     * Always returns zero, indicating that sort order is not relevent.	     *	     * @return zero always	     */	    public int compareTo(DurationField durationField) {	        return 0;	    }	
/**	     * Compares this duration field to another.	     * 	     * @param obj  the object to compare to	     * @return true if equal	     */	    public boolean equals(Object obj) {	        if (this == obj) {	            return true;	        } else if (obj instanceof UnsupportedDurationField) {	            UnsupportedDurationField other = (UnsupportedDurationField) obj;	            if (other.getName() == null) {	                return (getName() == null);	            }	            return (other.getName().equals(getName()));	        }	        return false;	    }	
/**	     * Gets a suitable hashcode.	     * 	     * @return the hashcode	     */	    public int hashCode() {	        return getName().hashCode();	    }	
/**	     * Get a suitable debug string.	     * 	     * @return debug string	     */	    public String toString() {	        return "UnsupportedDurationField[" + getName() + ']';	    }	
/**	     * Ensure proper singleton serialization	     */	    private Object readResolve() {	        return getInstance(iType);	    }	
private UnsupportedOperationException unsupported() {	        return new UnsupportedOperationException(iType + " field is unsupported");	    }	
/**	     * Constructor that skips zero.	     * 	     * @param chronology  the chronoogy to use	     * @param field  the field to skip zero on	     */	    public SkipDateTimeField(Chronology chronology, DateTimeField field) {	        this(chronology, field, 0);	    }	
/**	     * Constructor.	     * 	     * @param chronology  the chronoogy to use	     * @param field  the field to skip zero on	     * @param skip  the value to skip	     */	    public SkipDateTimeField(Chronology chronology, DateTimeField field, int skip) {	        super(field);	        iChronology = chronology;	        int min = super.getMinimumValue();	        if (min < skip) {	            iMinValue = min - 1;	        } else if (min == skip) {	            iMinValue = skip + 1;	        } else {	            iMinValue = min;	        }	        iSkip = skip;	    }	
public int get(long millis) {	        int value = super.get(millis);	        if (value <= iSkip) {	            value--;	        }	        return value;	    }	
public long set(long millis, int value) {	        FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue());	        if (value <= iSkip) {	            if (value == iSkip) {	                throw new IllegalFieldValueException	                    (DateTimeFieldType.year(), new Integer(value), null, null);	            }	            value++;	        }	        return super.set(millis, value);	    }	
public int getMinimumValue() {	        return iMinValue;	    }	
private Object readResolve() {	        return getType().getField(iChronology);	    }	
/**	     * Restricted constructor.	     */	    private FieldUtils() {	        super();	    }	
/**	     * Negates the input throwing an exception if it can't negate it.	     * 	     * @param value  the value to negate	     * @return the negated value	     * @throws ArithmeticException if the value is Integer.MIN_VALUE	     * @since 1.1	     */	    public static int safeNegate(int value) {	        if (value == Integer.MIN_VALUE) {	            throw new ArithmeticException("Integer.MIN_VALUE cannot be negated");	        }	        return -value;	    }	
/**	     * Add two values throwing an exception if overflow occurs.	     * 	     * @param val1  the first value	     * @param val2  the second value	     * @return the new total	     * @throws ArithmeticException if the value is too big or too small	     */	    public static int safeAdd(int val1, int val2) {	        int sum = val1 + val2;	        // If there is a sign change, but the two values have the same sign...	        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {	            throw new ArithmeticException	                ("The calculation caused an overflow: " + val1 + " + " + val2);	        }	        return sum;	    }	
/**	     * Add two values throwing an exception if overflow occurs.	     * 	     * @param val1  the first value	     * @param val2  the second value	     * @return the new total	     * @throws ArithmeticException if the value is too big or too small	     */	    public static long safeAdd(long val1, long val2) {	        long sum = val1 + val2;	        // If there is a sign change, but the two values have the same sign...	        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {	            throw new ArithmeticException	                ("The calculation caused an overflow: " + val1 + " + " + val2);	        }	        return sum;	    }	
/**	     * Subtracts two values throwing an exception if overflow occurs.	     * 	     * @param val1  the first value, to be taken away from	     * @param val2  the second value, the amount to take away	     * @return the new total	     * @throws ArithmeticException if the value is too big or too small	     */	    public static long safeSubtract(long val1, long val2) {	        long diff = val1 - val2;	        // If there is a sign change, but the two values have different signs...	        if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {	            throw new ArithmeticException	                ("The calculation caused an overflow: " + val1 + " - " + val2);	        }	        return diff;	    }	
/**	     * Multiply two values throwing an exception if overflow occurs.	     * 	     * @param val1  the first value	     * @param val2  the second value	     * @return the new total	     * @throws ArithmeticException if the value is too big or too small	     * @since 1.2	     */	    public static int safeMultiply(int val1, int val2) {	        long total = (long) val1 * (long) val2;	        if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {	            throw new ArithmeticException	                ("The calculation caused an overflow: " + val1 + " * " + val2);	        }	        return (int) total;	    }	
/**	     * Multiply two values throwing an exception if overflow occurs.	     * 	     * @param val1  the first value	     * @param scalar  the second value	     * @return the new total	     * @throws ArithmeticException if the value is too big or too small	     * @since 1.2	     */	    public static long safeMultiply(long val1, int scalar) {	        switch (scalar) {	        case -1:	            return -val1;	        case 0:	            return 0L;	        case 1:	            return val1;	        }	        long total = val1 * scalar;	        if (total / scalar != val1) {	            throw new ArithmeticException	                ("The calculation caused an overflow: " + val1 + " * " + scalar);	        }	        return total;	    }	
/**	     * Multiply two values throwing an exception if overflow occurs.	     * 	     * @param val1  the first value	     * @param val2  the second value	     * @return the new total	     * @throws ArithmeticException if the value is too big or too small	     */	    public static long safeMultiply(long val1, long val2) {	        if (val2 == 1) {	            return val1;	        }	        if (val2 == 0) {	            return 0;	        }	        long total = val1 * val2;	        if (total / val2 != val1) {	            throw new ArithmeticException	                ("The calculation caused an overflow: " + val1 + " * " + val2);	        }	        return total;	    }	
/**	     * Casts to an int throwing an exception if overflow occurs.	     * 	     * @param value  the value	     * @return the value as an int	     * @throws ArithmeticException if the value is too big or too small	     */	    public static int safeToInt(long value) {	        if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {	            return (int) value;	        }	        throw new ArithmeticException("Value cannot fit in an int: " + value);	    }	
/**	     * Multiply two values to return an int throwing an exception if overflow occurs.	     * 	     * @param val1  the first value	     * @param val2  the second value	     * @return the new total	     * @throws ArithmeticException if the value is too big or too small	     */	    public static int safeMultiplyToInt(long val1, long val2) {	        long val = FieldUtils.safeMultiply(val1, val2);	        return FieldUtils.safeToInt(val);	    }	
/**	     * Verify that input values are within specified bounds.	     * 	     * @param value  the value to check	     * @param lowerBound  the lower bound allowed for value	     * @param upperBound  the upper bound allowed for value	     * @throws IllegalFieldValueException if value is not in the specified bounds	     */	    public static void verifyValueBounds(DateTimeField field, 	                                         int value, int lowerBound, int upperBound) {	        if ((value < lowerBound) || (value > upperBound)) {	            throw new IllegalFieldValueException	                (field.getType(), new Integer(value),	                 new Integer(lowerBound), new Integer(upperBound));	        }	    }	
/**	     * Verify that input values are within specified bounds.	     * 	     * @param value  the value to check	     * @param lowerBound  the lower bound allowed for value	     * @param upperBound  the upper bound allowed for value	     * @throws IllegalFieldValueException if value is not in the specified bounds	     * @since 1.1	     */	    public static void verifyValueBounds(DateTimeFieldType fieldType, 	                                         int value, int lowerBound, int upperBound) {	        if ((value < lowerBound) || (value > upperBound)) {	            throw new IllegalFieldValueException	                (fieldType, new Integer(value),	                 new Integer(lowerBound), new Integer(upperBound));	        }	    }	
/**	     * Verify that input values are within specified bounds.	     * 	     * @param value  the value to check	     * @param lowerBound  the lower bound allowed for value	     * @param upperBound  the upper bound allowed for value	     * @throws IllegalFieldValueException if value is not in the specified bounds	     */	    public static void verifyValueBounds(String fieldName,	                                         int value, int lowerBound, int upperBound) {	        if ((value < lowerBound) || (value > upperBound)) {	            throw new IllegalFieldValueException	                (fieldName, new Integer(value),	                 new Integer(lowerBound), new Integer(upperBound));	        }	    }	
/**	     * Utility method used by addWrapField implementations to ensure the new	     * value lies within the field's legal value range.	     *	     * @param currentValue the current value of the data, which may lie outside	     * the wrapped value range	     * @param wrapValue  the value to add to current value before	     *  wrapping.  This may be negative.	     * @param minValue the wrap range minimum value.	     * @param maxValue the wrap range maximum value.  This must be	     *  greater than minValue (checked by the method).	     * @return the wrapped value	     * @throws IllegalArgumentException if minValue is greater	     *  than or equal to maxValue	     */	    public static int getWrappedValue(int currentValue, int wrapValue,	                                      int minValue, int maxValue) {	        return getWrappedValue(currentValue + wrapValue, minValue, maxValue);	    }	
/**	     * Utility method that ensures the given value lies within the field's	     * legal value range.	     * 	     * @param value  the value to fit into the wrapped value range	     * @param minValue the wrap range minimum value.	     * @param maxValue the wrap range maximum value.  This must be	     *  greater than minValue (checked by the method).	     * @return the wrapped value	     * @throws IllegalArgumentException if minValue is greater	     *  than or equal to maxValue	     */	    public static int getWrappedValue(int value, int minValue, int maxValue) {	        if (minValue >= maxValue) {	            throw new IllegalArgumentException("MIN > MAX");	        }		        int wrapRange = maxValue - minValue + 1;	        value -= minValue;		        if (value >= 0) {	            return (value % wrapRange) + minValue;	        }		        int remByRange = (-value) % wrapRange;		        if (remByRange == 0) {	            return 0 + minValue;	        }	        return (wrapRange - remByRange) + minValue;	    }	
/**	     * Compares two objects as equals handling null.	     * 	     * @param object1  the first object	     * @param object2  the second object	     * @return true if equal	     * @since 1.4	     */	    public static boolean equals(Object object1, Object object2) {	        if (object1 == object2) {	            return true;	        }	        if (object1 == null || object2 == null) {	            return false;	        }	        return object1.equals(object2);	    }	
/**	     * Constructor.	     * 	     * @param field  the field to wrap, like "year()".	     * @param type  the field type this field will actually use	     * @param divisor  divisor, such as 100 years in a century	     * @throws IllegalArgumentException if divisor is less than two	     */	    public DividedDateTimeField(DateTimeField field,	                                DateTimeFieldType type, int divisor) {	        super(field, type);	                	        if (divisor < 2) {	            throw new IllegalArgumentException("The divisor must be at least 2");	        }		        DurationField unitField = field.getDurationField();	        if (unitField == null) {	            iDurationField = null;	        } else {	            iDurationField = new ScaledDurationField(	                unitField, type.getDurationType(), divisor);	        }		        iDivisor = divisor;		        int i = field.getMinimumValue();	        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);		        int j = field.getMaximumValue();	        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);		        iMin = min;	        iMax = max;	    }	
/**	     * Construct a DividedDateTimeField that compliments the given	     * RemainderDateTimeField.	     *	     * @param remainderField  complimentary remainder field, like "yearOfCentury()".	     * @param type  the field type this field will actually use	     */	    public DividedDateTimeField(RemainderDateTimeField remainderField, DateTimeFieldType type) {	        super(remainderField.getWrappedField(), type);	        int divisor = iDivisor = remainderField.iDivisor;	        iDurationField = remainderField.iRangeField;		        DateTimeField field = getWrappedField();	        int i = field.getMinimumValue();	        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);		        int j = field.getMaximumValue();	        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);		        iMin = min;	        iMax = max;	    }	
/**	     * Get the amount of scaled units from the specified time instant.	     * 	     * @param instant  the time instant in millis to query.	     * @return the amount of scaled units extracted from the input.	     */	    public int get(long instant) {	        int value = getWrappedField().get(instant);	        if (value >= 0) {	            return value / iDivisor;	        } else {	            return ((value + 1) / iDivisor) - 1;	        }	    }	
/**	     * Add the specified amount of scaled units to the specified time	     * instant. The amount added may be negative.	     * 	     * @param instant  the time instant in millis to update.	     * @param amount  the amount of scaled units to add (can be negative).	     * @return the updated time instant.	     */	    public long add(long instant, int amount) {	        return getWrappedField().add(instant, amount * iDivisor);	    }	
/**	     * Add the specified amount of scaled units to the specified time	     * instant. The amount added may be negative.	     * 	     * @param instant  the time instant in millis to update.	     * @param amount  the amount of scaled units to add (can be negative).	     * @return the updated time instant.	     */	    public long add(long instant, long amount) {	        return getWrappedField().add(instant, amount * iDivisor);	    }	
/**	     * Add to the scaled component of the specified time instant,	     * wrapping around within that component if necessary.	     * 	     * @param instant  the time instant in millis to update.	     * @param amount  the amount of scaled units to add (can be negative).	     * @return the updated time instant.	     */	    public long addWrapField(long instant, int amount) {	        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));	    }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	        return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iDivisor;	    }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iDivisor;	    }	
/**	     * Set the specified amount of scaled units to the specified time instant.	     * 	     * @param instant  the time instant in millis to update.	     * @param value  value of scaled units to set.	     * @return the updated time instant.	     * @throws IllegalArgumentException if value is too large or too small.	     */	    public long set(long instant, int value) {	        FieldUtils.verifyValueBounds(this, value, iMin, iMax);	        int remainder = getRemainder(getWrappedField().get(instant));	        return getWrappedField().set(instant, value * iDivisor + remainder);	    }	
/**	     * Returns a scaled version of the wrapped field's unit duration field.	     */	    public DurationField getDurationField() {	        return iDurationField;	    }	
/**	     * Get the minimum value for the field.	     * 	     * @return the minimum value	     */	    public int getMinimumValue() {	        return iMin;	    }	
/**	     * Get the maximum value for the field.	     * 	     * @return the maximum value	     */	    public int getMaximumValue() {	        return iMax;	    }	
public long roundFloor(long instant) {	        DateTimeField field = getWrappedField();	        return field.roundFloor(field.set(instant, get(instant) * iDivisor));	    }	
public long remainder(long instant) {	        return set(instant, get(getWrappedField().remainder(instant)));	    }	
/**	     * Returns the divisor applied, in the field's units.	     * 	     * @return the divisor	     */	    public int getDivisor() {	        return iDivisor;	    }	
private int getRemainder(int value) {	        if (value >= 0) {	            return value % iDivisor;	        } else {	            return (iDivisor - 1) + ((value + 1) % iDivisor);	        }	    }	
/**	     * Restricted constructor.	     */	    private MillisDurationField() {	        super();	    }	
public DurationFieldType getType() {	        return DurationFieldType.millis();	    }	
public String getName() {	        return "millis";	    }	
/**	     * Returns true as this field is supported.	     * 	     * @return true always	     */	    public boolean isSupported() {	        return true;	    }	
/**	     * Returns true as this field is precise.	     * 	     * @return true always	     */	    public final boolean isPrecise() {	        return true;	    }	
/**	     * Returns the amount of milliseconds per unit value of this field.	     *	     * @return one always	     */	    public final long getUnitMillis() {	        return 1;	    }	
public int getValue(long duration) {	        return FieldUtils.safeToInt(duration);	    }	
public long getValueAsLong(long duration) {	        return duration;	    }	
public int getValue(long duration, long instant) {	        return FieldUtils.safeToInt(duration);	    }	
public long getValueAsLong(long duration, long instant) {	        return duration;	    }	
public long getMillis(int value) {	        return value;	    }	
public long getMillis(long value) {	        return value;	    }	
public long getMillis(int value, long instant) {	        return value;	    }	
public long getMillis(long value, long instant) {	        return value;	    }	
public long add(long instant, int value) {	        return FieldUtils.safeAdd(instant, value);	    }	
public long add(long instant, long value) {	        return FieldUtils.safeAdd(instant, value);	    }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	        return FieldUtils.safeToInt(FieldUtils.safeSubtract(minuendInstant, subtrahendInstant));	    }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        return FieldUtils.safeSubtract(minuendInstant, subtrahendInstant);	    }	
public int compareTo(DurationField otherField) {	        long otherMillis = otherField.getUnitMillis();	        long thisMillis = getUnitMillis();	        // cannot do (thisMillis - otherMillis) as can overflow	        if (thisMillis == otherMillis) {	            return 0;	        }	        if (thisMillis < otherMillis) {	            return -1;	        } else {	            return 1;	        }	    }	
/**	     * Get a suitable debug string.	     * 	     * @return debug string	     */	    public String toString() {	        return "DurationField[millis]";	    }	
/**	     * Deserialize to the singleton.	     */	    private Object readResolve() {	        return INSTANCE;	    }	
/**	     * Returns a lenient version of the given field. If it is already lenient,	     * then it is returned as-is. Otherwise, a new LenientDateTimeField is	     * returned.	     */	    public static DateTimeField getInstance(DateTimeField field, Chronology base) {	        if (field == null) {	            return null;	        }	        if (field instanceof StrictDateTimeField) {	            field = ((StrictDateTimeField)field).getWrappedField();	        }	        if (field.isLenient()) {	            return field;	        }	        return new LenientDateTimeField(field, base);	    }	
protected LenientDateTimeField(DateTimeField field, Chronology base) {	        super(field);	        iBase = base;	    }	
public final boolean isLenient() {	        return true;	    }	
/**	     * Set values which may be out of bounds by adding the difference between	     * the new value and the current value.	     */	    public long set(long instant, int value) {	        // lenient needs to handle time zone chronologies	        // so we do the calculation using local milliseconds	        long localInstant = iBase.getZone().convertUTCToLocal(instant);	        long difference = FieldUtils.safeSubtract(value, get(instant));	        localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);	        return iBase.getZone().convertLocalToUTC(localInstant, false, instant);	    }	
/**	     * Constructor.	     */	    protected AbstractPartialFieldProperty() {	        super();	    }	
/**	     * Gets the field type being used.	     * 	     * @return the field type	     */	    public DateTimeFieldType getFieldType() {	        return getField().getType();	    }	
/**	     * Gets the name of the field.	     * 	     * @return the field name	     */	    public String getName() {	        return getField().getName();	    }	
/**	     * Gets the value of this property from the instant as a string.	     * <p>	     * This method returns the value converted to a <code>String</code>	     * using <code>Integer.toString</code>. This method does NOT return	     * textual descriptions such as 'Monday' or 'January'.	     * See {@link #getAsText()} and {@link #getAsShortText()} for those.	     * 	     * @return the current value	     * @see DateTimeField#get	     * @since 1.1	     */	    public String getAsString() {	        return Integer.toString(get());	    }	
/**	     * Gets the textual value of this property from the instant as a	     * string in the default locale.	     * <p>	     * This method returns the value converted to a <code>String</code>	     * returning the appropriate textual description wherever possible.	     * Thus, a day of week of 1 would return 'Monday' in English.	     * 	     * @return the current text value	     * @see DateTimeField#getAsText	     */	    public String getAsText() {	        return getAsText(null);	    }	
/**	     * Gets the textual value of this property from the instant as a	     * string in the specified locale.	     * <p>	     * This method returns the value converted to a <code>String</code>	     * returning the appropriate textual description wherever possible.	     * Thus, a day of week of 1 would return 'Monday' in English.	     * 	     * @param locale  locale to use for selecting a text symbol, null means default	     * @return the current text value	     * @see DateTimeField#getAsText	     */	    public String getAsText(Locale locale) {	        return getField().getAsText(getReadablePartial(), get(), locale);	    }	
/**	     * Gets the short textual value of this property from the instant as a	     * string in the default locale.	     * <p>	     * This method returns the value converted to a <code>String</code>	     * returning the appropriate textual description wherever possible.	     * Thus, a day of week of 1 would return 'Mon' in English.	     * 	     * @return the current text value	     * @see DateTimeField#getAsShortText	     */	    public String getAsShortText() {	        return getAsShortText(null);	    }	
/**	     * Gets the short textual value of this property from the instant as a	     * string in the specified locale.	     * <p>	     * This method returns the value converted to a <code>String</code>	     * returning the appropriate textual description wherever possible.	     * Thus, a day of week of 1 would return 'Mon' in English.	     * 	     * @param locale  locale to use for selecting a text symbol, null means default	     * @return the current text value	     * @see DateTimeField#getAsShortText	     */	    public String getAsShortText(Locale locale) {	        return getField().getAsShortText(getReadablePartial(), get(), locale);	    }	
/**	     * Returns the duration per unit value of this field. For example, if this	     * field represents "hour of day", then the duration is an hour.	     *	     * @return the duration of this field, or UnsupportedDurationField	     */	    public DurationField getDurationField() {	        return getField().getDurationField();	    }	
/**	     * Returns the range duration of this field. For example, if this field	     * represents "hour of day", then the range duration is a day.	     *	     * @return the range duration of this field, or null if field has no range	     */	    public DurationField getRangeDurationField() {	        return getField().getRangeDurationField();	    }	
/**	     * Gets the minimum value for the field ignoring the current time.	     * 	     * @return the minimum value	     * @see DateTimeField#getMinimumValue	     */	    public int getMinimumValueOverall() {	        return getField().getMinimumValue();	    }	
/**	     * Gets the minimum value for this field given the current field values.	     * 	     * @return the minimum value	     * @see DateTimeField#getMinimumValue	     */	    public int getMinimumValue() {	        return getField().getMinimumValue(getReadablePartial());	    }	
/**	     * Gets the maximum value for the field ignoring the current time.	     * 	     * @return the maximum value	     * @see DateTimeField#getMaximumValue	     */	    public int getMaximumValueOverall() {	        return getField().getMaximumValue();	    }	
/**	     * Gets the maximum value for this field given the current field values.	     * 	     * @return the maximum value	     * @see DateTimeField#getMaximumValue	     */	    public int getMaximumValue() {	        return getField().getMaximumValue(getReadablePartial());	    }	
/**	     * Gets the maximum text length for the field.	     * 	     * @param locale  optional locale to use for selecting a text symbol	     * @return the maximum length	     * @see DateTimeField#getMaximumTextLength	     */	    public int getMaximumTextLength(Locale locale) {	        return getField().getMaximumTextLength(locale);	    }	
/**	     * Gets the maximum short text length for the field.	     * 	     * @param locale  optional locale to use for selecting a text symbol	     * @return the maximum length	     * @see DateTimeField#getMaximumShortTextLength	     */	    public int getMaximumShortTextLength(Locale locale) {	        return getField().getMaximumShortTextLength(locale);	    }	
/**	     * Compare this field to the same field on another instant.	     * <p>	     * The comparison is based on the value of the same field type, irrespective	     * of any difference in chronology. Thus, if this property represents the	     * hourOfDay field, then the hourOfDay field of the other instant will be queried	     * whether in the same chronology or not.	     * 	     * @param instant  the instant to compare to	     * @return negative value if this is less, 0 if equal, or positive value if greater	     * @throws IllegalArgumentException if the instant is null or the instant	     *  doesn't support the field of this property	     */	    public int compareTo(ReadableInstant instant) {	        if (instant == null) {	            throw new IllegalArgumentException("The instant must not be null");	        }	        int thisValue = get();	        int otherValue = instant.get(getFieldType());	        if (thisValue < otherValue) {	            return -1;	        } else if (thisValue > otherValue) {	            return 1;	        } else {	            return 0;	        }	    }	
/**	     * Compare this field to the same field on another partial instant.	     * <p>	     * The comparison is based on the value of the same field type, irrespective	     * of any difference in chronology. Thus, if this property represents the	     * hourOfDay field, then the hourOfDay field of the other partial will be queried	     * whether in the same chronology or not.	     * 	     * @param partial  the partial to compare to	     * @return negative value if this is less, 0 if equal, or positive value if greater	     * @throws IllegalArgumentException if the instant is null	     * @throws IllegalArgumentException if the field of this property cannot be queried	     *  on the specified instant	     */	    public int compareTo(ReadablePartial partial) {	        if (partial == null) {	            throw new IllegalArgumentException("The instant must not be null");	        }	        int thisValue = get();	        int otherValue = partial.get(getFieldType());	        if (thisValue < otherValue) {	            return -1;	        } else if (thisValue > otherValue) {	            return 1;	        } else {	            return 0;	        }	    }	
/**	     * Compares this property to another.	     * 	     * @param object  the object to compare to	     * @return true if equal	     */	    public boolean equals(Object object) {	        if (this == object) {	            return true;	        }	        if (object instanceof AbstractPartialFieldProperty == false) {	            return false;	        }	        AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object;	        return	            get() == other.get() &&	            getFieldType() == other.getFieldType() &&	            FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology());	    }	
/**	     * Gets a suitable hashcode for the object.	     * 	     * @return the hashcode	     * @since 1.3	     */	    public int hashCode() {	        int hash = 19;	        hash = 13 * hash + get();	        hash = 13 * hash + getFieldType().hashCode();	        hash = 13 * hash + getReadablePartial().getChronology().hashCode();	        return hash;	    }	
/**	     * Output a debugging string.	     * 	     * @return debugging string	     */	    public String toString() {	        return "Property[" + getName() + "]";	    }	
/**	     * Constructor.	     * 	     * @param field  the base field	     */	    protected DelegatedDurationField(DurationField field) {	        this(field, null);	    }	
/**	     * Constructor.	     * 	     * @param field  the base field	     * @param type  the field type to use	     */	    protected DelegatedDurationField(DurationField field, DurationFieldType type) {	        super();	        if (field == null) {	            throw new IllegalArgumentException("The field must not be null");	        }	        iField = field;	        iType = (type == null ? field.getType() : type);	    }	
/**	     * Gets the wrapped duration field.	     * 	     * @return the wrapped DurationField	     */	    public final DurationField getWrappedField() {	        return iField;	    }	
public DurationFieldType getType() {	        return iType;	    }	
public String getName() {	        return iType.getName();	    }	
/**	     * Returns true if this field is supported.	     */	    public boolean isSupported() {	        return iField.isSupported();	    }	
public boolean isPrecise() {	        return iField.isPrecise();	    }	
public int getValue(long duration) {	        return iField.getValue(duration);	    }	
public long getValueAsLong(long duration) {	        return iField.getValueAsLong(duration);	    }	
public int getValue(long duration, long instant) {	        return iField.getValue(duration, instant);	    }	
public long getValueAsLong(long duration, long instant) {	        return iField.getValueAsLong(duration, instant);	    }	
public long getMillis(int value) {	        return iField.getMillis(value);	    }	
public long getMillis(long value) {	        return iField.getMillis(value);	    }	
public long getMillis(int value, long instant) {	        return iField.getMillis(value, instant);	    }	
public long getMillis(long value, long instant) {	        return iField.getMillis(value, instant);	    }	
public long add(long instant, int value) {	        return iField.add(instant, value);	    }	
public long add(long instant, long value) {	        return iField.add(instant, value);	    }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	        return iField.getDifference(minuendInstant, subtrahendInstant);	    }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);	    }	
public long getUnitMillis() {	        return iField.getUnitMillis();	    }	
public int compareTo(DurationField durationField) {	        return iField.compareTo(durationField);	    }	
public String toString() {	        return (iType == null) ? iField.toString() :	            ("DurationField[" + iType + ']');	    }	
/**	     * Constructor.	     * 	     * @param field  the base field	     * @param type  the field type this field will actually use	     * @throws IllegalArgumentException if wrapped field's minimum value is not zero	     */	    public ZeroIsMaxDateTimeField(DateTimeField field, DateTimeFieldType type) {	        super(field, type);	        if (field.getMinimumValue() != 0) {	            throw new IllegalArgumentException("Wrapped field's minumum value must be zero");	        }	    }	
public int get(long instant) {	        int value = getWrappedField().get(instant);	        if (value == 0) {	            value = getMaximumValue();	        }	        return value;	    }	
public long add(long instant, int value) {	        return getWrappedField().add(instant, value);	    }	
public long add(long instant, long value) {	        return getWrappedField().add(instant, value);	    }	
public long addWrapField(long instant, int value) {	        return getWrappedField().addWrapField(instant, value);	    }	
public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {	        return getWrappedField().addWrapField(instant, fieldIndex, values, valueToAdd);	    }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);	    }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);	    }	
public long set(long instant, int value) {	        int max = getMaximumValue();	        FieldUtils.verifyValueBounds(this, value, 1, max);	        if (value == max) {	            value = 0;	        }	        return getWrappedField().set(instant, value);	    }	
public boolean isLeap(long instant) {	        return getWrappedField().isLeap(instant);	    }	
public int getLeapAmount(long instant) {	        return getWrappedField().getLeapAmount(instant);	    }	
public DurationField getLeapDurationField() {	        return getWrappedField().getLeapDurationField();	    }	
/**	     * Always returns 1.	     * 	     * @return the minimum value of 1	     */	    public int getMinimumValue() {	        return 1;	    }	
/**	     * Always returns 1.	     * 	     * @return the minimum value of 1	     */	    public int getMinimumValue(long instant) {	        return 1;	    }	
/**	     * Always returns 1.	     * 	     * @return the minimum value of 1	     */	    public int getMinimumValue(ReadablePartial instant) {	        return 1;	    }	
/**	     * Always returns 1.	     * 	     * @return the minimum value of 1	     */	    public int getMinimumValue(ReadablePartial instant, int[] values) {	        return 1;	    }	
/**	     * Get the maximum value for the field, which is one more than the wrapped	     * field's maximum value.	     * 	     * @return the maximum value	     */	    public int getMaximumValue() {	        return getWrappedField().getMaximumValue() + 1;	    }	
/**	     * Get the maximum value for the field, which is one more than the wrapped	     * field's maximum value.	     * 	     * @return the maximum value	     */	    public int getMaximumValue(long instant) {	        return getWrappedField().getMaximumValue(instant) + 1;	    }	
/**	     * Get the maximum value for the field, which is one more than the wrapped	     * field's maximum value.	     * 	     * @return the maximum value	     */	    public int getMaximumValue(ReadablePartial instant) {	        return getWrappedField().getMaximumValue(instant) + 1;	    }	
/**	     * Get the maximum value for the field, which is one more than the wrapped	     * field's maximum value.	     * 	     * @return the maximum value	     */	    public int getMaximumValue(ReadablePartial instant, int[] values) {	        return getWrappedField().getMaximumValue(instant, values) + 1;	    }	
public long roundFloor(long instant) {	        return getWrappedField().roundFloor(instant);	    }	
public long roundCeiling(long instant) {	        return getWrappedField().roundCeiling(instant);	    }	
public long roundHalfFloor(long instant) {	        return getWrappedField().roundHalfFloor(instant);	    }	
public long roundHalfCeiling(long instant) {	        return getWrappedField().roundHalfCeiling(instant);	    }	
public long roundHalfEven(long instant) {	        return getWrappedField().roundHalfEven(instant);	    }	
public long remainder(long instant) {	        return getWrappedField().remainder(instant);	    }	
/**	     * Constructor.	     * 	     * @param field  the field to wrap, like "year()".	     * @param offset  offset to add to field values	     * @throws IllegalArgumentException if offset is zero	     */	    public OffsetDateTimeField(DateTimeField field, int offset) {	        this(field, (field == null ? null : field.getType()), offset, Integer.MIN_VALUE, Integer.MAX_VALUE);	    }	
/**	     * Constructor.	     * 	     * @param field  the field to wrap, like "year()".	     * @param type  the field type this field actually uses	     * @param offset  offset to add to field values	     * @throws IllegalArgumentException if offset is zero	     */	    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset) {	        this(field, type, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);	    }	
/**	     * Constructor.	     * 	     * @param field  the field to wrap, like "year()".	     * @param type  the field type this field actually uses	     * @param offset  offset to add to field values	     * @param minValue  minimum allowed value	     * @param maxValue  maximum allowed value	     * @throws IllegalArgumentException if offset is zero	     */	    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset,	                               int minValue, int maxValue) {	        super(field, type);	                	        if (offset == 0) {	            throw new IllegalArgumentException("The offset cannot be zero");	        }		        iOffset = offset;		        if (minValue < (field.getMinimumValue() + offset)) {	            iMin = field.getMinimumValue() + offset;	        } else {	            iMin = minValue;	        }	        if (maxValue > (field.getMaximumValue() + offset)) {	            iMax = field.getMaximumValue() + offset;	        } else {	            iMax = maxValue;	        }	    }	
/**	     * Get the amount of offset units from the specified time instant.	     * 	     * @param instant  the time instant in millis to query.	     * @return the amount of units extracted from the input.	     */	    public int get(long instant) {	        return super.get(instant) + iOffset;	    }	
/**	     * Add the specified amount of offset units to the specified time	     * instant. The amount added may be negative.	     * 	     * @param instant  the time instant in millis to update.	     * @param amount  the amount of units to add (can be negative).	     * @return the updated time instant.	     */	    public long add(long instant, int amount) {	        instant = super.add(instant, amount);	        FieldUtils.verifyValueBounds(this, get(instant), iMin, iMax);	        return instant;	    }	
/**	     * Add the specified amount of offset units to the specified time	     * instant. The amount added may be negative.	     * 	     * @param instant  the time instant in millis to update.	     * @param amount  the amount of units to add (can be negative).	     * @return the updated time instant.	     */	    public long add(long instant, long amount) {	        instant = super.add(instant, amount);	        FieldUtils.verifyValueBounds(this, get(instant), iMin, iMax);	        return instant;	    }	
/**	     * Add to the offset component of the specified time instant,	     * wrapping around within that component if necessary.	     * 	     * @param instant  the time instant in millis to update.	     * @param amount  the amount of units to add (can be negative).	     * @return the updated time instant.	     */	    public long addWrapField(long instant, int amount) {	        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));	    }	
/**	     * Set the specified amount of offset units to the specified time instant.	     * 	     * @param instant  the time instant in millis to update.	     * @param value  value of units to set.	     * @return the updated time instant.	     * @throws IllegalArgumentException if value is too large or too small.	     */	    public long set(long instant, int value) {	        FieldUtils.verifyValueBounds(this, value, iMin, iMax);	        return super.set(instant, value - iOffset);	    }	
public boolean isLeap(long instant) {	        return getWrappedField().isLeap(instant);	    }	
public int getLeapAmount(long instant) {	        return getWrappedField().getLeapAmount(instant);	    }	
public DurationField getLeapDurationField() {	        return getWrappedField().getLeapDurationField();	    }	
/**	     * Get the minimum value for the field.	     * 	     * @return the minimum value	     */	    public int getMinimumValue() {	        return iMin;	    }	
/**	     * Get the maximum value for the field.	     * 	     * @return the maximum value	     */	    public int getMaximumValue() {	        return iMax;	    }	
public long roundFloor(long instant) {	        return getWrappedField().roundFloor(instant);	    }	
public long roundCeiling(long instant) {	        return getWrappedField().roundCeiling(instant);	    }	
public long roundHalfFloor(long instant) {	        return getWrappedField().roundHalfFloor(instant);	    }	
public long roundHalfCeiling(long instant) {	        return getWrappedField().roundHalfCeiling(instant);	    }	
public long roundHalfEven(long instant) {	        return getWrappedField().roundHalfEven(instant);	    }	
public long remainder(long instant) {	        return getWrappedField().remainder(instant);	    }	
/**	     * Returns the offset added to the field values.	     * 	     * @return the offset	     */	    public int getOffset() {	        return iOffset;	    }	
/**	     * Gets an instance of UnsupportedDateTimeField for a specific named field.	     * Names should be of standard format, such as 'monthOfYear' or 'hourOfDay'.	     * The returned instance is cached.	     * 	     * @param type  the type to obtain	     * @return the instance	     * @throws IllegalArgumentException if durationField is null	     */	    public static synchronized UnsupportedDateTimeField getInstance(	            DateTimeFieldType type, DurationField durationField) {		        UnsupportedDateTimeField field;	        if (cCache == null) {	            cCache = new HashMap<DateTimeFieldType, UnsupportedDateTimeField>(7);	            field = null;	        } else {	            field = cCache.get(type);	            if (field != null && field.getDurationField() != durationField) {	                field = null;	            }	        }	        if (field == null) {	            field = new UnsupportedDateTimeField(type, durationField);	            cCache.put(type, field);	        }	        return field;	    }	
/**	     * Constructor.	     * 	     * @param type  the field type	     * @param durationField  the duration to use	     */	    private UnsupportedDateTimeField(DateTimeFieldType type, DurationField durationField) {	        if (type == null || durationField == null) {	            throw new IllegalArgumentException();	        }	        iType = type;	        iDurationField = durationField;	    }	
public DateTimeFieldType getType() {	        return iType;	    }	
public String getName() {	        return iType.getName();	    }	
/**	     * This field is not supported.	     *	     * @return false always	     */	    public boolean isSupported() {	        return false;	    }	
/**	     * This field is not lenient.	     *	     * @return false always	     */	    public boolean isLenient() {	        return false;	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int get(long instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public String getAsText(long instant, Locale locale) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public String getAsText(long instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public String getAsText(ReadablePartial partial, int fieldValue, Locale locale) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public String getAsText(ReadablePartial partial, Locale locale) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public String getAsText(int fieldValue, Locale locale) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public String getAsShortText(long instant, Locale locale) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public String getAsShortText(long instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public String getAsShortText(ReadablePartial partial, Locale locale) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public String getAsShortText(int fieldValue, Locale locale) {	        throw unsupported();	    }	
/**	     * Delegates to the duration field.	     *	     * @throws UnsupportedOperationException if the duration is unsupported	     */	    public long add(long instant, int value) {	        return getDurationField().add(instant, value);	    }	
/**	     * Delegates to the duration field.	     *	     * @throws UnsupportedOperationException if the duration is unsupported	     */	    public long add(long instant, long value) {	        return getDurationField().add(instant, value);	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long addWrapField(long instant, int value) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {	        throw unsupported();	    }	
/**	     * Delegates to the duration field.	     *	     * @throws UnsupportedOperationException if the duration is unsupported	     */	    public int getDifference(long minuendInstant, long subtrahendInstant) {	        return getDurationField().getDifference(minuendInstant, subtrahendInstant);	    }	
/**	     * Delegates to the duration field.	     *	     * @throws UnsupportedOperationException if the duration is unsupported	     */	    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long set(long instant, int value) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long set(long instant, String text, Locale locale) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long set(long instant, String text) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {	        throw unsupported();	    }	
/**	     * Even though this DateTimeField is unsupported, the duration field might	     * be supported.	     *	     * @return a possibly supported DurationField	     */	    public DurationField getDurationField() {	        return iDurationField;	    }	
/**	     * Always returns null.	     *	     * @return null always	     */	    public DurationField getRangeDurationField() {	        return null;	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public boolean isLeap(long instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int getLeapAmount(long instant) {	        throw unsupported();	    }	
/**	     * Always returns null.	     *	     * @return null always	     */	    public DurationField getLeapDurationField() {	        return null;	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int getMinimumValue() {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int getMinimumValue(long instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int getMinimumValue(ReadablePartial instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int getMinimumValue(ReadablePartial instant, int[] values) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int getMaximumValue() {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int getMaximumValue(long instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int getMaximumValue(ReadablePartial instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int getMaximumValue(ReadablePartial instant, int[] values) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int getMaximumTextLength(Locale locale) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public int getMaximumShortTextLength(Locale locale) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long roundFloor(long instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long roundCeiling(long instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long roundHalfFloor(long instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long roundHalfCeiling(long instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long roundHalfEven(long instant) {	        throw unsupported();	    }	
/**	     * Always throws UnsupportedOperationException	     *	     * @throws UnsupportedOperationException	     */	    public long remainder(long instant) {	        throw unsupported();	    }	
/**	     * Get a suitable debug string.	     * 	     * @return debug string	     */	    public String toString() {	        return "UnsupportedDateTimeField";	    }	
/**	     * Ensure proper singleton serialization	     */	    private Object readResolve() {	        return getInstance(iType, iDurationField);	    }	
private UnsupportedOperationException unsupported() {	        return new UnsupportedOperationException(iType + " field is unsupported");	    }	
/**	     * Constructor.	     * 	     * @param field  the field being decorated	     */	    public DelegatedDateTimeField(DateTimeField field) {	        this(field, null);	    }	
/**	     * Constructor.	     * 	     * @param field  the field being decorated	     * @param type  the field type override	     */	    public DelegatedDateTimeField(DateTimeField field, DateTimeFieldType type) {	        super();	        if (field == null) {	            throw new IllegalArgumentException("The field must not be null");	        }	        iField = field;	        iType = (type == null ? field.getType() : type);	    }	
/**	     * Gets the wrapped date time field.	     * 	     * @return the wrapped DateTimeField	     */	    public final DateTimeField getWrappedField() {	        return iField;	    }	
public DateTimeFieldType getType() {	        return iType;	    }	
public String getName() {	        return iType.getName();	    }	
public boolean isSupported() {	        return iField.isSupported();	    }	
public boolean isLenient() {	        return iField.isLenient();	    }	
public int get(long instant) {	        return iField.get(instant);	    }	
public String getAsText(long instant, Locale locale) {	        return iField.getAsText(instant, locale);	    }	
public String getAsText(long instant) {	        return iField.getAsText(instant);	    }	
public String getAsText(ReadablePartial partial, int fieldValue, Locale locale) {	        return iField.getAsText(partial, fieldValue, locale);	    }	
public String getAsText(ReadablePartial partial, Locale locale) {	        return iField.getAsText(partial, locale);	    }	
public String getAsText(int fieldValue, Locale locale) {	        return iField.getAsText(fieldValue, locale);	    }	
public String getAsShortText(long instant, Locale locale) {	        return iField.getAsShortText(instant, locale);	    }	
public String getAsShortText(long instant) {	        return iField.getAsShortText(instant);	    }	
public String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) {	        return iField.getAsShortText(partial, fieldValue, locale);	    }	
public String getAsShortText(ReadablePartial partial, Locale locale) {	        return iField.getAsShortText(partial, locale);	    }	
public String getAsShortText(int fieldValue, Locale locale) {	        return iField.getAsShortText(fieldValue, locale);	    }	
public long add(long instant, int value) {	        return iField.add(instant, value);	    }	
public long add(long instant, long value) {	        return iField.add(instant, value);	    }	
public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {	        return iField.add(instant, fieldIndex, values, valueToAdd);	    }	
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {	        return iField.addWrapPartial(instant, fieldIndex, values, valueToAdd);	    }	
public long addWrapField(long instant, int value) {	        return iField.addWrapField(instant, value);	    }	
public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {	        return iField.addWrapField(instant, fieldIndex, values, valueToAdd);	    }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	        return iField.getDifference(minuendInstant, subtrahendInstant);	    }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);	    }	
public long set(long instant, int value) {	        return iField.set(instant, value);	    }	
public long set(long instant, String text, Locale locale) {	        return iField.set(instant, text, locale);	    }	
public long set(long instant, String text) {	        return iField.set(instant, text);	    }	
public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) {	        return iField.set(instant, fieldIndex, values, newValue);	    }	
public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {	        return iField.set(instant, fieldIndex, values, text, locale);	    }	
public DurationField getDurationField() {	        return iField.getDurationField();	    }	
public DurationField getRangeDurationField() {	        return iField.getRangeDurationField();	    }	
public boolean isLeap(long instant) {	        return iField.isLeap(instant);	    }	
public int getLeapAmount(long instant) {	        return iField.getLeapAmount(instant);	    }	
public DurationField getLeapDurationField() {	        return iField.getLeapDurationField();	    }	
public int getMinimumValue() {	        return iField.getMinimumValue();	    }	
public int getMinimumValue(long instant) {	        return iField.getMinimumValue(instant);	    }	
public int getMinimumValue(ReadablePartial instant) {	        return iField.getMinimumValue(instant);	    }	
public int getMinimumValue(ReadablePartial instant, int[] values) {	        return iField.getMinimumValue(instant, values);	    }	
public int getMaximumValue() {	        return iField.getMaximumValue();	    }	
public int getMaximumValue(long instant) {	        return iField.getMaximumValue(instant);	    }	
public int getMaximumValue(ReadablePartial instant) {	        return iField.getMaximumValue(instant);	    }	
public int getMaximumValue(ReadablePartial instant, int[] values) {	        return iField.getMaximumValue(instant, values);	    }	
public int getMaximumTextLength(Locale locale) {	        return iField.getMaximumTextLength(locale);	    }	
public int getMaximumShortTextLength(Locale locale) {	        return iField.getMaximumShortTextLength(locale);	    }	
public long roundFloor(long instant) {	        return iField.roundFloor(instant);	    }	
public long roundCeiling(long instant) {	        return iField.roundCeiling(instant);	    }	
public long roundHalfFloor(long instant) {	        return iField.roundHalfFloor(instant);	    }	
public long roundHalfCeiling(long instant) {	        return iField.roundHalfCeiling(instant);	    }	
public long roundHalfEven(long instant) {	        return iField.roundHalfEven(instant);	    }	
public long remainder(long instant) {	        return iField.remainder(instant);	    }	
public String toString() {	        return ("DateTimeField[" + getName() + ']');	    }	
/**	     * Constructor that reinserts zero.	     * 	     * @param chronology  the chronoogy to use	     * @param field  the field to skip zero on	     */	    public SkipUndoDateTimeField(Chronology chronology, DateTimeField field) {	        this(chronology, field, 0);	    }	
/**	     * Constructor.	     * 	     * @param chronology  the chronoogy to use	     * @param field  the field to skip zero on	     * @param skip  the value to skip	     */	    public SkipUndoDateTimeField(Chronology chronology, DateTimeField field, int skip) {	        super(field);	        iChronology = chronology;	        int min = super.getMinimumValue();	        if (min < skip) {	            iMinValue = min + 1;	        } else if (min == skip + 1) {	            iMinValue = skip;	        } else {	            iMinValue = min;	        }	        iSkip = skip;	    }	
public int get(long millis) {	        int value = super.get(millis);	        if (value < iSkip) {	            value++;	        }	        return value;	    }	
public long set(long millis, int value) {	        FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue());	        if (value <= iSkip) {	            value--;	        }	        return super.set(millis, value);	    }	
public int getMinimumValue() {	        return iMinValue;	    }	
private Object readResolve() {	        return getType().getField(iChronology);	    }	
/**	     * Gets an instance of the IslamicChronology.	     * The time zone of the returned instance is UTC.	     * 	     * @return a singleton UTC instance of the chronology	     */	    public static IslamicChronology getInstanceUTC() {	        return INSTANCE_UTC;	    }	
/**	     * Gets an instance of the IslamicChronology in the default time zone.	     * 	     * @return a chronology in the default time zone	     */	    public static IslamicChronology getInstance() {	        return getInstance(DateTimeZone.getDefault(), LEAP_YEAR_16_BASED);	    }	
/**	     * Gets an instance of the IslamicChronology in the given time zone.	     * 	     * @param zone  the time zone to get the chronology in, null is default	     * @return a chronology in the specified time zone	     */	    public static IslamicChronology getInstance(DateTimeZone zone) {	        return getInstance(zone, LEAP_YEAR_16_BASED);	    }	
/**	     * Gets an instance of the IslamicChronology in the given time zone.	     * 	     * @param zone  the time zone to get the chronology in, null is default	     * @param leapYears  the type defining the leap year pattern	     * @return a chronology in the specified time zone	     */	    public static IslamicChronology getInstance(DateTimeZone zone, LeapYearPatternType leapYears) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        IslamicChronology chrono;	        synchronized (cCache) {	            IslamicChronology[] chronos = cCache.get(zone);	            if (chronos == null) {	                chronos = new IslamicChronology[4];	                cCache.put(zone, chronos);	            }	            chrono = chronos[leapYears.index];	            if (chrono == null) {	                if (zone == DateTimeZone.UTC) {	                    // First create without a lower limit.	                    chrono = new IslamicChronology(null, null, leapYears);	                    // Impose lower limit and make another IslamicChronology.	                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);	                    chrono = new IslamicChronology(	                        LimitChronology.getInstance(chrono, lowerLimit, null),	                         null, leapYears);	                } else {	                    chrono = getInstance(DateTimeZone.UTC, leapYears);	                    chrono = new IslamicChronology	                        (ZonedChronology.getInstance(chrono, zone), null, leapYears);	                }	                chronos[leapYears.index] = chrono;	            }	        }	        return chrono;	    }	
/**	     * Restricted constructor.	     */	    IslamicChronology(Chronology base, Object param, LeapYearPatternType leapYears) {	        super(base, param, 4);	        this.iLeapYears = leapYears;	    }	
/**	     * Serialization singleton.	     */	    private Object readResolve() {	        Chronology base = getBase();	        return base == null ? getInstanceUTC() : getInstance(base.getZone());	    }	
/**	     * Gets the leap year pattern type.	     *	     * @return the pattern type	     */	    public LeapYearPatternType getLeapYearPatternType() {	        return iLeapYears;	    }	
/**	     * Gets the Chronology in the UTC time zone.	     * 	     * @return the chronology in UTC	     */	    public Chronology withUTC() {	        return INSTANCE_UTC;	    }	
/**	     * Gets the Chronology in a specific time zone.	     * 	     * @param zone  the zone to get the chronology in, null is default	     * @return the chronology	     */	    public Chronology withZone(DateTimeZone zone) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        if (zone == getZone()) {	            return this;	        }	        return getInstance(zone);	    }	
/**	     * A suitable hash code for the chronology.	     * 	     * @return the hash code	     * @since 1.6	     */	    public int hashCode() {	        return super.hashCode() * 13 + getLeapYearPatternType().hashCode();	    }	
int getYear(long instant) {	        long millisIslamic = instant - MILLIS_YEAR_1;	        long cycles = millisIslamic / MILLIS_PER_CYCLE;	        long cycleRemainder = millisIslamic % MILLIS_PER_CYCLE;	        	        int year = (int) ((cycles * CYCLE) + 1L);	        long yearMillis = (isLeapYear(year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR);	        while (cycleRemainder >= yearMillis) {	            cycleRemainder -= yearMillis;	            yearMillis = (isLeapYear(++year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR);	        }	        return year;	    }	
long setYear(long instant, int year) {	        // optimsed implementation of set, due to fixed months	        int thisYear = getYear(instant);	        int dayOfYear = getDayOfYear(instant, thisYear);	        int millisOfDay = getMillisOfDay(instant);		        if (dayOfYear > 354) {	            // Current year is leap, and day is leap.	            if (!isLeapYear(year)) {	                // Moving to a non-leap year, leap day doesn't exist.	                dayOfYear--;	            }	        }		        instant = getYearMonthDayMillis(year, 1, dayOfYear);	        instant += millisOfDay;	        return instant;	    }	
long getYearDifference(long minuendInstant, long subtrahendInstant) {	        // optimsed implementation of getDifference, due to fixed months	        int minuendYear = getYear(minuendInstant);	        int subtrahendYear = getYear(subtrahendInstant);		        // Inlined remainder method to avoid duplicate calls to get.	        long minuendRem = minuendInstant - getYearMillis(minuendYear);	        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);		        int difference = minuendYear - subtrahendYear;	        if (minuendRem < subtrahendRem) {	            difference--;	        }	        return difference;	    }	
long getTotalMillisByYearMonth(int year, int month) {	        if (--month % 2 == 1) {	            month /= 2;	            return month * MILLIS_PER_MONTH_PAIR + MILLIS_PER_LONG_MONTH;	        } else {	            month /= 2;	            return month * MILLIS_PER_MONTH_PAIR;	        }	    }	
int getDayOfMonth(long millis) {	        // optimised for simple months	        int doy = getDayOfYear(millis) - 1;	        if (doy == 354) {	            return 30;	        }	        return (doy % MONTH_PAIR_LENGTH) % LONG_MONTH_LENGTH + 1;	    }	
boolean isLeapYear(int year) {	        return iLeapYears.isLeapYear(year);	    }	
int getDaysInYearMax() {	        return 355;	    }	
int getDaysInYear(int year) {	        return isLeapYear(year) ? 355 : 354;	    }	
int getDaysInYearMonth(int year, int month) {	        if (month == 12 && isLeapYear(year)) {	            return LONG_MONTH_LENGTH;	        }	        return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH);	    }	
int getDaysInMonthMax() {	        return LONG_MONTH_LENGTH;	    }	
int getDaysInMonthMax(int month) {	        if (month == 12) {	            return LONG_MONTH_LENGTH;	        }	        return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH);	    }	
int getMonthOfYear(long millis, int year) {	        int doyZeroBased = (int) ((millis - getYearMillis(year)) / DateTimeConstants.MILLIS_PER_DAY);	        if (doyZeroBased == 354) {	            return 12;	        }	        return ((doyZeroBased * 2) / MONTH_PAIR_LENGTH) + 1;	//        return (int) (doyZeroBased / 29.9f) + 1;	//        	//        int monthPairZeroBased = doyZeroBased / MONTH_PAIR_LENGTH;	//        int monthPairRemainder = doyZeroBased % MONTH_PAIR_LENGTH;	//        return (monthPairZeroBased * 2) + 1 + (monthPairRemainder >= LONG_MONTH_LENGTH ? 1 : 0);	    }	
long getAverageMillisPerYear() {	        return MILLIS_PER_YEAR;	    }	
long getAverageMillisPerYearDividedByTwo() {	        return MILLIS_PER_YEAR / 2;	    }	
long getAverageMillisPerMonth() {	        return MILLIS_PER_MONTH;	    }	
long calculateFirstDayOfYearMillis(int year) {	        if (year > MAX_YEAR) {	            throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR);	        }	        if (year < MIN_YEAR) {	            throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR);	        }		        // Java epoch is 1970-01-01 Gregorian which is 0622-07-16 Islamic.	        // 0001-01-01 Islamic is -42520809600000L	        // would prefer to calculate against year zero, but leap year	        // can be in that year so it doesn't work	        year--;	        long cycle = year / CYCLE;	        long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE;	        int cycleRemainder = (year % CYCLE) + 1;	        	        for (int i = 1; i < cycleRemainder; i++) {	            millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR);	        }	        	        return millis;	    }	
int getMinYear() {	        return 1; //MIN_YEAR;	    }	
int getMaxYear() {	        return MAX_YEAR;	    }	
long getApproxMillisAtEpochDividedByTwo() {	        // Epoch 1970-01-01 ISO = 1389-10-22 Islamic	        return (-MILLIS_YEAR_1) / 2;	    }	
protected void assemble(Fields fields) {	        if (getBase() == null) {	            super.assemble(fields);		            fields.era = ERA_FIELD;	            fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 12);	            fields.months = fields.monthOfYear.getDurationField();	        }	    }	
/**	         * Constructor.	         * This constructor takes a bit pattern where bits 0-29 correspond	         * to years 0-29 in the 30 year Islamic cycle of years. This allows	         * a highly efficient lookup by bit-matching.	         *	         * @param index  the index	         * @param pattern  the bit pattern	         */	        LeapYearPatternType(int index, int pattern) {	            super();	            this.index = (byte) index;	            this.pattern = pattern;	        }	
/**	         * Is the year a leap year.	         * @param year  the year to query	         * @return true if leap	         */	        boolean isLeapYear(int year) {	            int key = 1 << (year % 30);	            return ((pattern & key) > 0);	        }	
/**	         * Ensure a singleton is returned if possible.	         * @return the singleton instance	         */	        private Object readResolve() {	            switch (index) {	                case 0:	                    return LEAP_YEAR_15_BASED;	                case 1:	                    return LEAP_YEAR_16_BASED;	                case 2:	                    return LEAP_YEAR_INDIAN;	                case 3:	                    return LEAP_YEAR_HABASH_AL_HASIB;	                default:	                    return this;	            }	        }	
/**	     * Restricted constructor	     */	    BasicWeekyearDateTimeField(BasicChronology chronology) {	        super(DateTimeFieldType.weekyear(), chronology.getAverageMillisPerYear());	        iChronology = chronology;	    }	
public boolean isLenient() {	        return false;	    }	
/**	     * Get the Year of a week based year component of the specified time instant.	     * 	     * @see org.joda.time.DateTimeField#get	     * @param instant  the time instant in millis to query.	     * @return the year extracted from the input.	     */	    public int get(long instant) {	        return iChronology.getWeekyear(instant);	    }	
/**	     * Add the specified years to the specified time instant.	     * 	     * @see org.joda.time.DateTimeField#add	     * @param instant  the time instant in millis to update.	     * @param years  the years to add (can be negative).	     * @return the updated time instant.	     */	    public long add(long instant, int years) {	        if (years == 0) {	            return instant;	        }	        return set(instant, get(instant) + years);	    }	
public long add(long instant, long value) {	        return add(instant, FieldUtils.safeToInt(value));	    }	
/**	     * Add to the year component of the specified time instant	     * wrapping around within that component if necessary.	     * 	     * @see org.joda.time.DateTimeField#addWrapField	     * @param instant  the time instant in millis to update.	     * @param years  the years to add (can be negative).	     * @return the updated time instant.	     */	    public long addWrapField(long instant, int years) {	        return add(instant, years);	    }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        if (minuendInstant < subtrahendInstant) {	            return -getDifference(subtrahendInstant, minuendInstant);	        }		        int minuendWeekyear = get(minuendInstant);	        int subtrahendWeekyear = get(subtrahendInstant);		        long minuendRem = remainder(minuendInstant);	        long subtrahendRem = remainder(subtrahendInstant);		        // Balance leap weekyear differences on remainders.	        if (subtrahendRem >= WEEK_53 && iChronology.getWeeksInYear(minuendWeekyear) <= 52) {	            subtrahendRem -= DateTimeConstants.MILLIS_PER_WEEK;	        }		        int difference = minuendWeekyear - subtrahendWeekyear;	        if (minuendRem < subtrahendRem) {	            difference--;	        }	        return difference;	    }	
/**	     * Set the Year of a week based year component of the specified time instant.	     *	     * @see org.joda.time.DateTimeField#set	     * @param instant  the time instant in millis to update.	     * @param year  the year (-9999,9999) to set the date to.	     * @return the updated DateTime.	     * @throws IllegalArgumentException  if year is invalid.	     */	    public long set(long instant, int year) {	        FieldUtils.verifyValueBounds(this, Math.abs(year),	                                     iChronology.getMinYear(), iChronology.getMaxYear());	        //	        // Do nothing if no real change is requested.	        //	        int thisWeekyear = get( instant );	        if ( thisWeekyear == year ) {	            return instant;	        }	        //	        // Calculate the DayOfWeek (to be preserved).	        //	        int thisDow = iChronology.getDayOfWeek(instant);	        //	        // Calculate the maximum weeks in the target year.	        //	        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );	        int weeksInToYear = iChronology.getWeeksInYear( year );	        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?	            weeksInToYear : weeksInFromYear;	        //	        // Get the current week of the year. This will be preserved in	        // the output unless it is greater than the maximum possible	        // for the target weekyear.  In that case it is adjusted	        // to the maximum possible.	        //	        int setToWeek = iChronology.getWeekOfWeekyear(instant);	        if ( setToWeek > maxOutWeeks ) {	            setToWeek = maxOutWeeks;	        }	        //	        // Get a wroking copy of the current date-time.	        // This can be a convenience for debugging.	        //	        long workInstant = instant; // Get a copy	        //	        // Attempt to get close to the proper weekyear.	        // Note - we cannot currently call ourself, so we just call	        // set for the year.  This at least gets us close.	        //	        workInstant = iChronology.setYear( workInstant, year );	        //	        // Calculate the weekyear number for the get close to value	        // (which might not be equal to the year just set).	        //	        int workWoyYear = get( workInstant );		        //	        // At most we are off by one year, which can be "fixed" by	        // adding/subtracting a week.	        //	        if ( workWoyYear < year ) {	            workInstant += DateTimeConstants.MILLIS_PER_WEEK;	        } else if ( workWoyYear > year ) {	            workInstant -= DateTimeConstants.MILLIS_PER_WEEK;	        }	        //	        // Set the proper week in the current weekyear.	        //		        // BEGIN: possible set WeekOfWeekyear logic.	        int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant);	        // No range check required (we already know it is OK).	        workInstant = workInstant + (setToWeek - currentWoyWeek)	            * (long)DateTimeConstants.MILLIS_PER_WEEK;	        // END: possible set WeekOfWeekyear logic.		        //	        // Reset DayOfWeek to previous value.	        //	        // Note: This works fine, but it ideally shouldn't invoke other	        // fields from within a field.	        workInstant = iChronology.dayOfWeek().set( workInstant, thisDow );	        //	        // Return result.	        //	        return workInstant;	    }	
public DurationField getRangeDurationField() {	        return null;	    }	
public boolean isLeap(long instant) {	        return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) > 52;	    }	
public int getLeapAmount(long instant) {	        return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) - 52;	    }	
public DurationField getLeapDurationField() {	        return iChronology.weeks();	    }	
public int getMinimumValue() {	        return iChronology.getMinYear();	    }	
public int getMaximumValue() {	        return iChronology.getMaxYear();	    }	
public long roundFloor(long instant) {	        // Note: This works fine, but it ideally shouldn't invoke other	        // fields from within a field.	        instant = iChronology.weekOfWeekyear().roundFloor(instant);	        int wow = iChronology.getWeekOfWeekyear(instant);	        if (wow > 1) {	            instant -= ((long) DateTimeConstants.MILLIS_PER_WEEK) * (wow - 1);	        }	        return instant;	    }	
public long remainder(long instant) {	        return instant - roundFloor(instant);	    }	
/**	     * Serialization singleton	     */	    private Object readResolve() {	        return iChronology.weekyear();	    }	
/**	     * Restricted constructor.	     * 	     * @param leapMonth the month of year that leaps	     */	    BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {	        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());	        iChronology = chronology;	        iMax = iChronology.getMaxMonth();	        iLeapMonth = leapMonth;	    }	
public boolean isLenient() {	        return false;	    }	
/**	     * Get the Month component of the specified time instant.	     *	     * @see org.joda.time.DateTimeField#get(long)	     * @see org.joda.time.ReadableDateTime#getMonthOfYear()	     * @param instant  the time instant in millis to query.	     * @return the month extracted from the input.	     */	    public int get(long instant) {	        return iChronology.getMonthOfYear(instant);	    }	
/**	     * Add the specified month to the specified time instant.	     * The amount added may be negative.<p>	     * If the new month has less total days than the specified	     * day of the month, this value is coerced to the nearest	     * sane value. e.g.<p>	     * 07-31 - (1 month) = 06-30<p>	     * 03-31 - (1 month) = 02-28 or 02-29 depending<p>	     * 	     * @see org.joda.time.DateTimeField#add	     * @see org.joda.time.ReadWritableDateTime#addMonths(int)	     * @param instant  the time instant in millis to update.	     * @param months  the months to add (can be negative).	     * @return the updated time instant.	     */	    public long add(long instant, int months) {	        if (months == 0) {	            return instant; // the easy case	        }	        //	        // Save time part first.	        //	        long timePart = iChronology.getMillisOfDay(instant);	        //	        //	        // Get this year and month.	        //	        int thisYear = iChronology.getYear(instant);	        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);	        // ----------------------------------------------------------	        //	        // Do not refactor without careful consideration.	        // Order of calculation is important.	        //	        int yearToUse;	        // Initially, monthToUse is zero-based	        int monthToUse = thisMonth - 1 + months;	        if (monthToUse >= 0) {	            yearToUse = thisYear + (monthToUse / iMax);	            monthToUse = (monthToUse % iMax) + 1;	        } else {	            yearToUse = thisYear + (monthToUse / iMax) - 1;	            monthToUse = Math.abs(monthToUse);	            int remMonthToUse = monthToUse % iMax;	            // Take care of the boundary condition	            if (remMonthToUse == 0) {	                remMonthToUse = iMax;	            }	            monthToUse = iMax - remMonthToUse + 1;	            // Take care of the boundary condition	            if (monthToUse == 1) {	                yearToUse += 1;	            }	        }	        // End of do not refactor.	        // ----------------------------------------------------------		        //	        // Quietly force DOM to nearest sane value.	        //	        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);	        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);	        if (dayToUse > maxDay) {	            dayToUse = maxDay;	        }	        //	        // get proper date part, and return result	        //	        long datePart =	            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);	        return datePart + timePart;	    }	
public long add(long instant, long months) {	        int i_months = (int)months;	        if (i_months == months) {	            return add(instant, i_months);	        }		        // Copied from add(long, int) and modified slightly:		        long timePart = iChronology.getMillisOfDay(instant);		        int thisYear = iChronology.getYear(instant);	        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);		        long yearToUse;	        long monthToUse = thisMonth - 1 + months;	        if (monthToUse >= 0) {	            yearToUse = thisYear + (monthToUse / iMax);	            monthToUse = (monthToUse % iMax) + 1;	        } else {	            yearToUse = thisYear + (monthToUse / iMax) - 1;	            monthToUse = Math.abs(monthToUse);	            int remMonthToUse = (int)(monthToUse % iMax);	            if (remMonthToUse == 0) {	                remMonthToUse = iMax;	            }	            monthToUse = iMax - remMonthToUse + 1;	            if (monthToUse == 1) {	                yearToUse += 1;	            }	        }		        if (yearToUse < iChronology.getMinYear() ||	            yearToUse > iChronology.getMaxYear()) {		            throw new IllegalArgumentException	                ("Magnitude of add amount is too large: " + months);	        }		        int i_yearToUse = (int)yearToUse;	        int i_monthToUse = (int)monthToUse;		        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);	        int maxDay = iChronology.getDaysInYearMonth(i_yearToUse, i_monthToUse);	        if (dayToUse > maxDay) {	            dayToUse = maxDay;	        }		        long datePart =	            iChronology.getYearMonthDayMillis(i_yearToUse, i_monthToUse, dayToUse);	        return datePart + timePart;	    }	
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {	        // overridden as superclass algorithm can't handle	        // 2004-02-29 + 48 months -> 2008-02-29 type dates	        if (valueToAdd == 0) {	            return values;	        }	        if (DateTimeUtils.isContiguous(partial)) {	            long instant = 0L;	            for (int i = 0, isize = partial.size(); i < isize; i++) {	                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);	            }	            instant = add(instant, valueToAdd);	            return iChronology.get(partial, instant);	        } else {	            return super.add(partial, fieldIndex, values, valueToAdd);	        }	    }	
/**	     * Add to the Month component of the specified time instant	     * wrapping around within that component if necessary.	     * 	     * @see org.joda.time.DateTimeField#addWrapField	     * @param instant  the time instant in millis to update.	     * @param months  the months to add (can be negative).	     * @return the updated time instant.	     */	    public long addWrapField(long instant, int months) {	        return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, iMax));	    }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        if (minuendInstant < subtrahendInstant) {	            return -getDifference(subtrahendInstant, minuendInstant);	        }		        int minuendYear = iChronology.getYear(minuendInstant);	        int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);	        int subtrahendYear = iChronology.getYear(subtrahendInstant);	        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);		        long difference = (minuendYear - subtrahendYear) * ((long) iMax) + minuendMonth - subtrahendMonth;		        // Before adjusting for remainder, account for special case of add	        // where the day-of-month is forced to the nearest sane value.	        int minuendDom = iChronology.getDayOfMonth	            (minuendInstant, minuendYear, minuendMonth);	        if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {	            // Last day of the minuend month...	            int subtrahendDom = iChronology.getDayOfMonth	                (subtrahendInstant, subtrahendYear, subtrahendMonth);	            if (subtrahendDom > minuendDom) {	                // ...and day of subtrahend month is larger.	                // Note: This works fine, but it ideally shouldn't invoke other	                // fields from within a field.	                subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);	            }	        }		        // Inlined remainder method to avoid duplicate calls.	        long minuendRem = minuendInstant	            - iChronology.getYearMonthMillis(minuendYear, minuendMonth);	        long subtrahendRem = subtrahendInstant	            - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);		        if (minuendRem < subtrahendRem) {	            difference--;	        }		        return difference;	    }	
/**	     * Set the Month component of the specified time instant.<p>	     * If the new month has less total days than the specified	     * day of the month, this value is coerced to the nearest	     * sane value. e.g.<p>	     * 07-31 to month 6 = 06-30<p>	     * 03-31 to month 2 = 02-28 or 02-29 depending<p>	     * 	     * @param instant  the time instant in millis to update.	     * @param month  the month (1,12) to update the time to.	     * @return the updated time instant.	     * @throws IllegalArgumentException  if month is invalid	     */	    public long set(long instant, int month) {	        FieldUtils.verifyValueBounds(this, month, MIN, iMax);	        //	        int thisYear = iChronology.getYear(instant);	        //	        int thisDom = iChronology.getDayOfMonth(instant, thisYear);	        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);	        if (thisDom > maxDom) {	            // Quietly force DOM to nearest sane value.	            thisDom = maxDom;	        }	        // Return newly calculated millis value	        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +	            iChronology.getMillisOfDay(instant);	    }	
public DurationField getRangeDurationField() {	        return iChronology.years();	    }	
public boolean isLeap(long instant) {	        int thisYear = iChronology.getYear(instant);	        if (iChronology.isLeapYear(thisYear)) {	            return (iChronology.getMonthOfYear(instant, thisYear) == iLeapMonth);	        }	        return false;	    }	
public int getLeapAmount(long instant) {	        return isLeap(instant) ? 1 : 0;	    }	
public DurationField getLeapDurationField() {	        return iChronology.days();	    }	
public int getMinimumValue() {	        return MIN;	    }	
public int getMaximumValue() {	        return iMax;	    }	
public long roundFloor(long instant) {	        int year = iChronology.getYear(instant);	        int month = iChronology.getMonthOfYear(instant, year);	        return iChronology.getYearMonthMillis(year, month);	    }	
public long remainder(long instant) {	        return instant - roundFloor(instant);	    }	
/**	     * Serialization singleton	     */	    private Object readResolve() {	        return iChronology.monthOfYear();	    }	
/**	     * Standard instance of a Buddhist Chronology, that matches	     * Sun's BuddhistCalendar class. This means that it follows the	     * GregorianJulian calendar rules with a cutover date.	     * <p>	     * The time zone of the returned instance is UTC.	     */	    public static BuddhistChronology getInstanceUTC() {	        return INSTANCE_UTC;	    }	
/**	     * Standard instance of a Buddhist Chronology, that matches	     * Sun's BuddhistCalendar class. This means that it follows the	     * GregorianJulian calendar rules with a cutover date.	     */	    public static BuddhistChronology getInstance() {	        return getInstance(DateTimeZone.getDefault());	    }	
/**	     * Standard instance of a Buddhist Chronology, that matches	     * Sun's BuddhistCalendar class. This means that it follows the	     * GregorianJulian calendar rules with a cutover date.	     *	     * @param zone  the time zone to use, null is default	     */	    public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        BuddhistChronology chrono = cCache.get(zone);	        if (chrono == null) {	            // First create without a lower limit.	            chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);	            // Impose lower limit and make another BuddhistChronology.	            DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);	            chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), "");	            cCache.put(zone, chrono);	        }	        return chrono;	    }	
/**	     * Restricted constructor.	     *	     * @param param if non-null, then don't change the field set	     */	    private BuddhistChronology(Chronology base, Object param) {	        super(base, param);	    }	
/**	     * Serialization singleton	     */	    private Object readResolve() {	        Chronology base = getBase();	        return base == null ? getInstanceUTC() : getInstance(base.getZone());	    }	
/**	     * Gets the Chronology in the UTC time zone.	     * 	     * @return the chronology in UTC	     */	    public Chronology withUTC() {	        return INSTANCE_UTC;	    }	
/**	     * Gets the Chronology in a specific time zone.	     * 	     * @param zone  the zone to get the chronology in, null is default	     * @return the chronology	     */	    public Chronology withZone(DateTimeZone zone) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        if (zone == getZone()) {	            return this;	        }	        return getInstance(zone);	    }	
/**	     * Checks if this chronology instance equals another.	     * 	     * @param obj  the object to compare to	     * @return true if equal	     * @since 1.6	     */	    public boolean equals(Object obj) {	        return super.equals(obj);	    }	
/**	     * A suitable hash code for the chronology.	     * 	     * @return the hash code	     * @since 1.6	     */	    public int hashCode() {	        return "Buddhist".hashCode() * 11 + getZone().hashCode();	    }	
/**	     * Gets a debugging toString.	     * 	     * @return a debugging string	     */	    public String toString() {	        String str = "BuddhistChronology";	        DateTimeZone zone = getZone();	        if (zone != null) {	            str = str + '[' + zone.getID() + ']';	        }	        return str;	    }	
protected void assemble(Fields fields) {	        if (getParam() == null) {	            // julian chrono removed zero, but we need to put it back	            DateTimeField field = fields.year;	            fields.year = new OffsetDateTimeField(	                    new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET);	            	            // one era, so yearOfEra is the same	            field = fields.yearOfEra;	            fields.yearOfEra = new DelegatedDateTimeField(	                fields.year, DateTimeFieldType.yearOfEra());	            	            // julian chrono removed zero, but we need to put it back	            field = fields.weekyear;	            fields.weekyear = new OffsetDateTimeField(	                    new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET);	            	            field = new OffsetDateTimeField(fields.yearOfEra, 99);	            fields.centuryOfEra = new DividedDateTimeField(	                field, DateTimeFieldType.centuryOfEra(), 100);	            	            field = new RemainderDateTimeField(	                (DividedDateTimeField) fields.centuryOfEra);	            fields.yearOfCentury = new OffsetDateTimeField(	                field, DateTimeFieldType.yearOfCentury(), 1);	            	            field = new RemainderDateTimeField(	                fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);	            fields.weekyearOfCentury = new OffsetDateTimeField(	                field, DateTimeFieldType.weekyearOfCentury(), 1);	            	            fields.era = ERA_FIELD;	        }	    }	
/**	     * Restricted constructor.	     */	    BasicSingleEraDateTimeField(String text) {	        super(DateTimeFieldType.era());	        iEraText = text;	    }	
/** @inheritDoc */	    public boolean isLenient() {	        return false;	    }	
/** @inheritDoc */	    public int get(long instant) {	        return ERA_VALUE;	    }	
/** @inheritDoc */	    public long set(long instant, int era) {	        FieldUtils.verifyValueBounds(this, era, ERA_VALUE, ERA_VALUE);	        return instant;	    }	
/** @inheritDoc */	    public long set(long instant, String text, Locale locale) {	        if (iEraText.equals(text) == false && "1".equals(text) == false) {	            throw new IllegalFieldValueException(DateTimeFieldType.era(), text);	        }	        return instant;	    }	
/** @inheritDoc */	    public long roundFloor(long instant) {	        return Long.MIN_VALUE;	    }	
/** @inheritDoc */	    public long roundCeiling(long instant) {	        return Long.MAX_VALUE;	    }	
/** @inheritDoc */	    public long roundHalfFloor(long instant) {	        return Long.MIN_VALUE;	    }	
/** @inheritDoc */	    public long roundHalfCeiling(long instant) {	        return Long.MIN_VALUE;	    }	
/** @inheritDoc */	    public long roundHalfEven(long instant) {	        return Long.MIN_VALUE;	    }	
/** @inheritDoc */	    public DurationField getDurationField() {	        return UnsupportedDurationField.getInstance(DurationFieldType.eras());	    }	
/** @inheritDoc */	    public DurationField getRangeDurationField() {	        return null;	    }	
/** @inheritDoc */	    public int getMinimumValue() {	        return ERA_VALUE;	    }	
/** @inheritDoc */	    public int getMaximumValue() {	        return ERA_VALUE;	    }	
/** @inheritDoc */	    public String getAsText(int fieldValue, Locale locale) {	        return iEraText;	    }	
/** @inheritDoc */	    public int getMaximumTextLength(Locale locale) {	        return iEraText.length();	    }	
/**	     * Restricted constructor	     */	    BasicDayOfYearDateTimeField(BasicChronology chronology, DurationField days) {	        super(DateTimeFieldType.dayOfYear(), days);	        iChronology = chronology;	    }	
/**	     * Get the day of the year component of the specified time instant.	     * 	     * @param instant  the time instant in millis to query.	     * @return the day of the year extracted from the input.	     */	    public int get(long instant) {	        return iChronology.getDayOfYear(instant);	    }	
public DurationField getRangeDurationField() {	        return iChronology.years();	    }	
public int getMinimumValue() {	        return 1;	    }	
public int getMaximumValue() {	        return iChronology.getDaysInYearMax();	    }	
public int getMaximumValue(long instant) {	        int year = iChronology.getYear(instant);	        return iChronology.getDaysInYear(year);	    }	
public int getMaximumValue(ReadablePartial partial) {	        if (partial.isSupported(DateTimeFieldType.year())) {	            int year = partial.get(DateTimeFieldType.year());	            return iChronology.getDaysInYear(year);	        }	        return iChronology.getDaysInYearMax();	    }	
public int getMaximumValue(ReadablePartial partial, int[] values) {	        int size = partial.size();	        for (int i = 0; i < size; i++) {	            if (partial.getFieldType(i) == DateTimeFieldType.year()) {	                int year = values[i];	                return iChronology.getDaysInYear(year);	            }	        }	        return iChronology.getDaysInYearMax();	    }	
protected int getMaximumValueForSet(long instant, int value) {	        int maxLessOne = iChronology.getDaysInYearMax() - 1;	        return (value > maxLessOne || value < 1) ? getMaximumValue(instant) : maxLessOne;	    }	
/**	     * Serialization singleton	     */	    private Object readResolve() {	        return iChronology.dayOfYear();	    }	
/**	     * Restricted constructor.	     */	    BasicDayOfMonthDateTimeField(BasicChronology chronology, DurationField days) {	        super(DateTimeFieldType.dayOfMonth(), days);	        iChronology = chronology;	    }	
public int get(long instant) {	        return iChronology.getDayOfMonth(instant);	    }	
public DurationField getRangeDurationField() {	        return iChronology.months();	    }	
public int getMinimumValue() {	        return 1;	    }	
public int getMaximumValue() {	        return iChronology.getDaysInMonthMax();	    }	
public int getMaximumValue(long instant) {	        return iChronology.getDaysInMonthMax(instant);	    }	
public int getMaximumValue(ReadablePartial partial) {	        if (partial.isSupported(DateTimeFieldType.monthOfYear())) {	            int month = partial.get(DateTimeFieldType.monthOfYear());	            if (partial.isSupported(DateTimeFieldType.year())) {	                int year = partial.get(DateTimeFieldType.year());	                return iChronology.getDaysInYearMonth(year, month);	            }	            return iChronology.getDaysInMonthMax(month);	        }	        return getMaximumValue();	    }	
public int getMaximumValue(ReadablePartial partial, int[] values) {	        int size = partial.size();	        for (int i = 0; i < size; i++) {	            if (partial.getFieldType(i) == DateTimeFieldType.monthOfYear()) {	                int month = values[i];	                for (int j = 0; j < size; j++) {	                    if (partial.getFieldType(j) == DateTimeFieldType.year()) {	                        int year = values[j];	                        return iChronology.getDaysInYearMonth(year, month);	                    }	                }	                return iChronology.getDaysInMonthMax(month);	            }	        }	        return getMaximumValue();	    }	
protected int getMaximumValueForSet(long instant, int value) {	        return iChronology.getDaysInMonthMaxForSet(instant, value);	    }	
/**	     * Serialization singleton	     */	    private Object readResolve() {	        return iChronology.dayOfMonth();	    }	
/**	     * Constructor.	     */	    BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {	        super(base, param, minDaysInFirstWeek);	    }	
int getMonthOfYear(long millis, int year) {	        // Perform a binary search to get the month. To make it go even faster,	        // compare using ints instead of longs. The number of milliseconds per	        // year exceeds the limit of a 32-bit int's capacity, so divide by	        // 1024. No precision is lost (except time of day) since the number of	        // milliseconds per day contains 1024 as a factor. After the division,	        // the instant isn't measured in milliseconds, but in units of	        // (128/125)seconds.		        int i = (int)((millis - getYearMillis(year)) >> 10);		        // There are 86400000 milliseconds per day, but divided by 1024 is	        // 84375. There are 84375 (128/125)seconds per day.		        return	            (isLeapYear(year))	            ? ((i < 182 * 84375)	               ? ((i < 91 * 84375)	                  ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)	                  : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))	               : ((i < 274 * 84375)	                  ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)	                  : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))	            : ((i < 181 * 84375)	               ? ((i < 90 * 84375)	                  ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)	                  : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))	               : ((i < 273 * 84375)	                  ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)	                  : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));	    }	
/**	     * Gets the number of days in the specified month and year.	     * 	     * @param year  the year	     * @param month  the month	     * @return the number of days	     */	    int getDaysInYearMonth(int year, int month) {	        if (isLeapYear(year)) {	            return MAX_DAYS_PER_MONTH_ARRAY[month - 1];	        } else {	            return MIN_DAYS_PER_MONTH_ARRAY[month - 1];	        }	    }	
int getDaysInMonthMax(int month) {	        return MAX_DAYS_PER_MONTH_ARRAY[month - 1];	    }	
int getDaysInMonthMaxForSet(long instant, int value) {	        return (value > 28 ? getDaysInMonthMax(instant) : 28);	    }	
long getTotalMillisByYearMonth(int year, int month) {	        if (isLeapYear(year)) {	            return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];	        } else {	            return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];	        }	    }	
long getYearDifference(long minuendInstant, long subtrahendInstant) {	        int minuendYear = getYear(minuendInstant);	        int subtrahendYear = getYear(subtrahendInstant);	    	        // Inlined remainder method to avoid duplicate calls to get.	        long minuendRem = minuendInstant - getYearMillis(minuendYear);	        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);	    	        // Balance leap year differences on remainders.	        if (subtrahendRem >= FEB_29) {	            if (isLeapYear(subtrahendYear)) {	                if (!isLeapYear(minuendYear)) {	                    subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY;	                }	            } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) {	                minuendRem -= DateTimeConstants.MILLIS_PER_DAY;	            }	        }	    	        int difference = minuendYear - subtrahendYear;	        if (minuendRem < subtrahendRem) {	            difference--;	        }	        return difference;	    }	
long setYear(long instant, int year) {	        int thisYear = getYear(instant);	        int dayOfYear = getDayOfYear(instant, thisYear);	        int millisOfDay = getMillisOfDay(instant);		        if (dayOfYear > (31 + 28)) { // after Feb 28	            if (isLeapYear(thisYear)) {	                // Current date is Feb 29 or later.	                if (!isLeapYear(year)) {	                    // Moving to a non-leap year, Feb 29 does not exist.	                    dayOfYear--;	                }	            } else {	                // Current date is Mar 01 or later.	                if (isLeapYear(year)) {	                    // Moving to a leap year, account for Feb 29.	                    dayOfYear++;	                }	            }	        }		        instant = getYearMonthDayMillis(year, 1, dayOfYear);	        instant += millisOfDay;		        return instant;	    }	
/**	     * Gets an instance of the CopticChronology.	     * The time zone of the returned instance is UTC.	     * 	     * @return a singleton UTC instance of the chronology	     */	    public static CopticChronology getInstanceUTC() {	        return INSTANCE_UTC;	    }	
/**	     * Gets an instance of the CopticChronology in the default time zone.	     * 	     * @return a chronology in the default time zone	     */	    public static CopticChronology getInstance() {	        return getInstance(DateTimeZone.getDefault(), 4);	    }	
/**	     * Gets an instance of the CopticChronology in the given time zone.	     * 	     * @param zone  the time zone to get the chronology in, null is default	     * @return a chronology in the specified time zone	     */	    public static CopticChronology getInstance(DateTimeZone zone) {	        return getInstance(zone, 4);	    }	
/**	     * Gets an instance of the CopticChronology in the given time zone.	     * 	     * @param zone  the time zone to get the chronology in, null is default	     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4	     * @return a chronology in the specified time zone	     */	    public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        CopticChronology chrono;	        synchronized (cCache) {	            CopticChronology[] chronos = cCache.get(zone);	            if (chronos == null) {	                chronos = new CopticChronology[7];	                cCache.put(zone, chronos);	            }	            try {	                chrono = chronos[minDaysInFirstWeek - 1];	            } catch (ArrayIndexOutOfBoundsException e) {	                throw new IllegalArgumentException	                    ("Invalid min days in first week: " + minDaysInFirstWeek);	            }	            if (chrono == null) {	                if (zone == DateTimeZone.UTC) {	                    // First create without a lower limit.	                    chrono = new CopticChronology(null, null, minDaysInFirstWeek);	                    // Impose lower limit and make another CopticChronology.	                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);	                    chrono = new CopticChronology	                        (LimitChronology.getInstance(chrono, lowerLimit, null),	                         null, minDaysInFirstWeek);	                } else {	                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);	                    chrono = new CopticChronology	                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);	                }	                chronos[minDaysInFirstWeek - 1] = chrono;	            }	        }	        return chrono;	    }	
/**	     * Restricted constructor.	     */	    CopticChronology(Chronology base, Object param, int minDaysInFirstWeek) {	        super(base, param, minDaysInFirstWeek);	    }	
/**	     * Serialization singleton.	     */	    private Object readResolve() {	        Chronology base = getBase();	        int minDays = getMinimumDaysInFirstWeek();	        minDays = (minDays == 0 ? 4 : minDays);  // handle rename of BaseGJChronology	        return base == null ?	                getInstance(DateTimeZone.UTC, minDays) :	                    getInstance(base.getZone(), minDays);	    }	
/**	     * Gets the Chronology in the UTC time zone.	     * 	     * @return the chronology in UTC	     */	    public Chronology withUTC() {	        return INSTANCE_UTC;	    }	
/**	     * Gets the Chronology in a specific time zone.	     * 	     * @param zone  the zone to get the chronology in, null is default	     * @return the chronology	     */	    public Chronology withZone(DateTimeZone zone) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        if (zone == getZone()) {	            return this;	        }	        return getInstance(zone);	    }	
long calculateFirstDayOfYearMillis(int year) {	        // Java epoch is 1970-01-01 Gregorian which is 1686-04-23 Coptic.	        // Calculate relative to the nearest leap year and account for the	        // difference later.		        int relativeYear = year - 1687;	        int leapYears;	        if (relativeYear <= 0) {	            // Add 3 before shifting right since /4 and >>2 behave differently	            // on negative numbers.	            leapYears = (relativeYear + 3) >> 2;	        } else {	            leapYears = relativeYear >> 2;	            // For post 1687 an adjustment is needed as jan1st is before leap day	            if (!isLeapYear(year)) {	                leapYears++;	            }	        }	        	        long millis = (relativeYear * 365L + leapYears)	            * (long)DateTimeConstants.MILLIS_PER_DAY;		        // Adjust to account for difference between 1687-01-01 and 1686-04-23.		        return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY;	    }	
int getMinYear() {	        return MIN_YEAR;	    }	
int getMaxYear() {	        return MAX_YEAR;	    }	
long getApproxMillisAtEpochDividedByTwo() {	        return (1686L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY) / 2;	    }	
protected void assemble(Fields fields) {	        if (getBase() == null) {	            super.assemble(fields);		            // Coptic, like Julian, has no year zero.	            fields.year = new SkipDateTimeField(this, fields.year);	            fields.weekyear = new SkipDateTimeField(this, fields.weekyear);	            	            fields.era = ERA_FIELD;	            fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 13);	            fields.months = fields.monthOfYear.getDurationField();	        }	    }	
/**	     * Restricted constructor.	     * 	     * @param chronology  the chronology this field belogs to	     */	    BasicYearDateTimeField(BasicChronology chronology) {	        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());	        iChronology = chronology;	    }	
public boolean isLenient() {	        return false;	    }	
public int get(long instant) {	        return iChronology.getYear(instant);	    }	
public long add(long instant, int years) {	        if (years == 0) {	            return instant;	        }	        int thisYear = get(instant);	        int newYear = FieldUtils.safeAdd(thisYear, years);	        return set(instant, newYear);	    }	
public long add(long instant, long years) {	        return add(instant, FieldUtils.safeToInt(years));	    }	
public long addWrapField(long instant, int years) {	        if (years == 0) {	            return instant;	        }	        // Return newly calculated millis value	        int thisYear = iChronology.getYear(instant);	        int wrappedYear = FieldUtils.getWrappedValue	            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());	        return set(instant, wrappedYear);	    }	
public long set(long instant, int year) {	        FieldUtils.verifyValueBounds	            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());	        return iChronology.setYear(instant, year);	    }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        if (minuendInstant < subtrahendInstant) {	            return -iChronology.getYearDifference(subtrahendInstant, minuendInstant);	        }	        return iChronology.getYearDifference(minuendInstant, subtrahendInstant);	    }	
public DurationField getRangeDurationField() {	        return null;	    }	
public boolean isLeap(long instant) {	        return iChronology.isLeapYear(get(instant));	    }	
public int getLeapAmount(long instant) {	        if (iChronology.isLeapYear(get(instant))) {	            return 1;	        } else {	            return 0;	        }	    }	
public DurationField getLeapDurationField() {	        return iChronology.days();	    }	
public int getMinimumValue() {	        return iChronology.getMinYear();	    }	
public int getMaximumValue() {	        return iChronology.getMaxYear();	    }	
public long roundFloor(long instant) {	        return iChronology.getYearMillis(get(instant));	    }	
public long roundCeiling(long instant) {	        int year = get(instant);	        long yearStartMillis = iChronology.getYearMillis(year);	        if (instant != yearStartMillis) {	            // Bump up to start of next year.	            instant = iChronology.getYearMillis(year + 1);	        }	        return instant;	    }	
public long remainder(long instant) {	        return instant - roundFloor(instant);	    }	
/**	     * Serialization singleton	     */	    private Object readResolve() {	        return iChronology.year();	    }	
/**	     * Wraps another chronology, with datetime limits. When withUTC or	     * withZone is called, the returned LimitChronology instance has	     * the same limits, except they are time zone adjusted.	     *	     * @param base  base chronology to wrap	     * @param lowerLimit  inclusive lower limit, or null if none	     * @param upperLimit  exclusive upper limit, or null if none	     * @throws IllegalArgumentException if chronology is null or limits are invalid	     */	    public static LimitChronology getInstance(Chronology base,	                                              ReadableDateTime lowerLimit,	                                              ReadableDateTime upperLimit) {	        if (base == null) {	            throw new IllegalArgumentException("Must supply a chronology");	        }		        lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime();	        upperLimit = upperLimit == null ? null : upperLimit.toDateTime();		        if (lowerLimit != null && upperLimit != null) {	            if (!lowerLimit.isBefore(upperLimit)) {	                throw new IllegalArgumentException	                    ("The lower limit must be come before than the upper limit");	            }	        }		        return new LimitChronology(base, (DateTime)lowerLimit, (DateTime)upperLimit);	    }	
/**	     * Wraps another chronology, with datetime limits. When withUTC or	     * withZone is called, the returned LimitChronology instance has	     * the same limits, except they are time zone adjusted.	     *	     * @param lowerLimit  inclusive lower limit, or null if none	     * @param upperLimit  exclusive upper limit, or null if none	     */	    private LimitChronology(Chronology base,	                            DateTime lowerLimit, DateTime upperLimit) {	        super(base, null);	        // These can be set after assembly.	        iLowerLimit = lowerLimit;	        iUpperLimit = upperLimit;	    }	
/**	     * Returns the inclusive lower limit instant.	     * 	     * @return lower limit	     */	    public DateTime getLowerLimit() {	        return iLowerLimit;	    }	
/**	     * Returns the inclusive upper limit instant.	     * 	     * @return upper limit	     */	    public DateTime getUpperLimit() {	        return iUpperLimit;	    }	
/**	     * If this LimitChronology is already UTC, then this is	     * returned. Otherwise, a new instance is returned, with the limits	     * adjusted to the new time zone.	     */	    public Chronology withUTC() {	        return withZone(DateTimeZone.UTC);	    }	
/**	     * If this LimitChronology has the same time zone as the one given, then	     * this is returned. Otherwise, a new instance is returned, with the limits	     * adjusted to the new time zone.	     */	    public Chronology withZone(DateTimeZone zone) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        if (zone == getZone()) {	            return this;	        }		        if (zone == DateTimeZone.UTC && iWithUTC != null) {	            return iWithUTC;	        }		        DateTime lowerLimit = iLowerLimit;	        if (lowerLimit != null) {	            MutableDateTime mdt = lowerLimit.toMutableDateTime();	            mdt.setZoneRetainFields(zone);	            lowerLimit = mdt.toDateTime();	        }		        DateTime upperLimit = iUpperLimit;	        if (upperLimit != null) {	            MutableDateTime mdt = upperLimit.toMutableDateTime();	            mdt.setZoneRetainFields(zone);	            upperLimit = mdt.toDateTime();	        }	        	        LimitChronology chrono = getInstance	            (getBase().withZone(zone), lowerLimit, upperLimit);		        if (zone == DateTimeZone.UTC) {	            iWithUTC = chrono;	        }		        return chrono;	    }	
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,	                                  int millisOfDay)	        throws IllegalArgumentException	    {	        long instant = getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);	        checkLimits(instant, "resulting");	        return instant;	    }	
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,	                                  int hourOfDay, int minuteOfHour,	                                  int secondOfMinute, int millisOfSecond)	        throws IllegalArgumentException	    {	        long instant = getBase().getDateTimeMillis	            (year, monthOfYear, dayOfMonth,	             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	        checkLimits(instant, "resulting");	        return instant;	    }	
public long getDateTimeMillis(long instant,	                                  int hourOfDay, int minuteOfHour,	                                  int secondOfMinute, int millisOfSecond)	        throws IllegalArgumentException	    {	        checkLimits(instant, null);	        instant = getBase().getDateTimeMillis	            (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	        checkLimits(instant, "resulting");	        return instant;	    }	
protected void assemble(Fields fields) {	        // Keep a local cache of converted fields so as not to create redundant	        // objects.	        HashMap<Object, Object> converted = new HashMap<Object, Object>();		        // Convert duration fields...		        fields.eras = convertField(fields.eras, converted);	        fields.centuries = convertField(fields.centuries, converted);	        fields.years = convertField(fields.years, converted);	        fields.months = convertField(fields.months, converted);	        fields.weekyears = convertField(fields.weekyears, converted);	        fields.weeks = convertField(fields.weeks, converted);	        fields.days = convertField(fields.days, converted);		        fields.halfdays = convertField(fields.halfdays, converted);	        fields.hours = convertField(fields.hours, converted);	        fields.minutes = convertField(fields.minutes, converted);	        fields.seconds = convertField(fields.seconds, converted);	        fields.millis = convertField(fields.millis, converted);		        // Convert datetime fields...		        fields.year = convertField(fields.year, converted);	        fields.yearOfEra = convertField(fields.yearOfEra, converted);	        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);	        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);	        fields.era = convertField(fields.era, converted);	        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);	        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);	        fields.dayOfYear = convertField(fields.dayOfYear, converted);	        fields.monthOfYear = convertField(fields.monthOfYear, converted);	        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);	        fields.weekyear = convertField(fields.weekyear, converted);	        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);		        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);	        fields.millisOfDay = convertField(fields.millisOfDay, converted);	        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);	        fields.secondOfDay = convertField(fields.secondOfDay, converted);	        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);	        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);	        fields.hourOfDay = convertField(fields.hourOfDay, converted);	        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);	        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);	        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);	        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);	    }	
private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {	        if (field == null || !field.isSupported()) {	            return field;	        }	        if (converted.containsKey(field)) {	            return (DurationField)converted.get(field);	        }	        LimitDurationField limitField = new LimitDurationField(field);	        converted.put(field, limitField);	        return limitField;	    }	
private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {	        if (field == null || !field.isSupported()) {	            return field;	        }	        if (converted.containsKey(field)) {	            return (DateTimeField)converted.get(field);	        }	        LimitDateTimeField limitField =	            new LimitDateTimeField(field,	                                   convertField(field.getDurationField(), converted),	                                   convertField(field.getRangeDurationField(), converted),	                                   convertField(field.getLeapDurationField(), converted));	        converted.put(field, limitField);	        return limitField;	    }	
void checkLimits(long instant, String desc) {	        DateTime limit;	        if ((limit = iLowerLimit) != null && instant < limit.getMillis()) {	            throw new LimitException(desc, true);	        }	        if ((limit = iUpperLimit) != null && instant >= limit.getMillis()) {	            throw new LimitException(desc, false);	        }	    }	
/**	     * A limit chronology is only equal to a limit chronology with the	     * same base chronology and limits.	     * 	     * @param obj  the object to compare to	     * @return true if equal	     * @since 1.4	     */	    public boolean equals(Object obj) {	        if (this == obj) {	            return true;	        }	        if (obj instanceof LimitChronology == false) {	            return false;	        }	        LimitChronology chrono = (LimitChronology) obj;	        return	            getBase().equals(chrono.getBase()) &&	            FieldUtils.equals(getLowerLimit(), chrono.getLowerLimit()) &&	            FieldUtils.equals(getUpperLimit(), chrono.getUpperLimit());	    }	
/**	     * A suitable hashcode for the chronology.	     * 	     * @return the hashcode	     * @since 1.4	     */	    public int hashCode() {	        int hash = 317351877;	        hash += (getLowerLimit() != null ? getLowerLimit().hashCode() : 0);	        hash += (getUpperLimit() != null ? getUpperLimit().hashCode() : 0);	        hash += getBase().hashCode() * 7;	        return hash;	    }	
/**	     * A debugging string for the chronology.	     * 	     * @return the debugging string	     */	    public String toString() {	        return "LimitChronology[" + getBase().toString() + ", " +	            (getLowerLimit() == null ? "NoLimit" : getLowerLimit().toString()) + ", " +	            (getUpperLimit() == null ? "NoLimit" : getUpperLimit().toString()) + ']';	    }	
LimitException(String desc, boolean isLow) {	            super(desc);	            iIsLow = isLow;	        }	
public String getMessage() {	            StringBuffer buf = new StringBuffer(85);	            buf.append("The");	            String desc = super.getMessage();	            if (desc != null) {	                buf.append(' ');	                buf.append(desc);	            }	            buf.append(" instant is ");		            DateTimeFormatter p = ISODateTimeFormat.dateTime();	            p = p.withChronology(getBase());	            if (iIsLow) {	                buf.append("below the supported minimum of ");	                p.printTo(buf, getLowerLimit().getMillis());	            } else {	                buf.append("above the supported maximum of ");	                p.printTo(buf, getUpperLimit().getMillis());	            }	            	            buf.append(" (");	            buf.append(getBase());	            buf.append(')');		            return buf.toString();	        }	
public String toString() {	            return "IllegalArgumentException: " + getMessage();	        }	
LimitDurationField(DurationField field) {	            super(field, field.getType());	        }	
public int getValue(long duration, long instant) {	            checkLimits(instant, null);	            return getWrappedField().getValue(duration, instant);	        }	
public long getValueAsLong(long duration, long instant) {	            checkLimits(instant, null);	            return getWrappedField().getValueAsLong(duration, instant);	        }	
public long getMillis(int value, long instant) {	            checkLimits(instant, null);	            return getWrappedField().getMillis(value, instant);	        }	
public long getMillis(long value, long instant) {	            checkLimits(instant, null);	            return getWrappedField().getMillis(value, instant);	        }	
public long add(long instant, int amount) {	            checkLimits(instant, null);	            long result = getWrappedField().add(instant, amount);	            checkLimits(result, "resulting");	            return result;	        }	
public long add(long instant, long amount) {	            checkLimits(instant, null);	            long result = getWrappedField().add(instant, amount);	            checkLimits(result, "resulting");	            return result;	        }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	            checkLimits(minuendInstant, "minuend");	            checkLimits(subtrahendInstant, "subtrahend");	            return getWrappedField().getDifference(minuendInstant, subtrahendInstant);	        }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	            checkLimits(minuendInstant, "minuend");	            checkLimits(subtrahendInstant, "subtrahend");	            return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);	        }	
LimitDateTimeField(DateTimeField field,	                           DurationField durationField,	                           DurationField rangeDurationField,	                           DurationField leapDurationField) {	            super(field, field.getType());	            iDurationField = durationField;	            iRangeDurationField = rangeDurationField;	            iLeapDurationField = leapDurationField;	        }	
public int get(long instant) {	            checkLimits(instant, null);	            return getWrappedField().get(instant);	        }	
public String getAsText(long instant, Locale locale) {	            checkLimits(instant, null);	            return getWrappedField().getAsText(instant, locale);	        }	
public String getAsShortText(long instant, Locale locale) {	            checkLimits(instant, null);	            return getWrappedField().getAsShortText(instant, locale);	        }	
public long add(long instant, int amount) {	            checkLimits(instant, null);	            long result = getWrappedField().add(instant, amount);	            checkLimits(result, "resulting");	            return result;	        }	
public long add(long instant, long amount) {	            checkLimits(instant, null);	            long result = getWrappedField().add(instant, amount);	            checkLimits(result, "resulting");	            return result;	        }	
public long addWrapField(long instant, int amount) {	            checkLimits(instant, null);	            long result = getWrappedField().addWrapField(instant, amount);	            checkLimits(result, "resulting");	            return result;	        }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	            checkLimits(minuendInstant, "minuend");	            checkLimits(subtrahendInstant, "subtrahend");	            return getWrappedField().getDifference(minuendInstant, subtrahendInstant);	        }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	            checkLimits(minuendInstant, "minuend");	            checkLimits(subtrahendInstant, "subtrahend");	            return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);	        }	
public long set(long instant, int value) {	            checkLimits(instant, null);	            long result = getWrappedField().set(instant, value);	            checkLimits(result, "resulting");	            return result;	        }	
public long set(long instant, String text, Locale locale) {	            checkLimits(instant, null);	            long result = getWrappedField().set(instant, text, locale);	            checkLimits(result, "resulting");	            return result;	        }	
public final DurationField getDurationField() {	            return iDurationField;	        }	
public final DurationField getRangeDurationField() {	            return iRangeDurationField;	        }	
public boolean isLeap(long instant) {	            checkLimits(instant, null);	            return getWrappedField().isLeap(instant);	        }	
public int getLeapAmount(long instant) {	            checkLimits(instant, null);	            return getWrappedField().getLeapAmount(instant);	        }	
public final DurationField getLeapDurationField() {	            return iLeapDurationField;	        }	
public long roundFloor(long instant) {	            checkLimits(instant, null);	            long result = getWrappedField().roundFloor(instant);	            checkLimits(result, "resulting");	            return result;	        }	
public long roundCeiling(long instant) {	            checkLimits(instant, null);	            long result = getWrappedField().roundCeiling(instant);	            checkLimits(result, "resulting");	            return result;	        }	
public long roundHalfFloor(long instant) {	            checkLimits(instant, null);	            long result = getWrappedField().roundHalfFloor(instant);	            checkLimits(result, "resulting");	            return result;	        }	
public long roundHalfCeiling(long instant) {	            checkLimits(instant, null);	            long result = getWrappedField().roundHalfCeiling(instant);	            checkLimits(result, "resulting");	            return result;	        }	
public long roundHalfEven(long instant) {	            checkLimits(instant, null);	            long result = getWrappedField().roundHalfEven(instant);	            checkLimits(result, "resulting");	            return result;	        }	
public long remainder(long instant) {	            checkLimits(instant, null);	            long result = getWrappedField().remainder(instant);	            checkLimits(result, "resulting");	            return result;	        }	
public int getMinimumValue(long instant) {	            checkLimits(instant, null);	            return getWrappedField().getMinimumValue(instant);	        }	
public int getMaximumValue(long instant) {	            checkLimits(instant, null);	            return getWrappedField().getMaximumValue(instant);	        }	
public int getMaximumTextLength(Locale locale) {	            return getWrappedField().getMaximumTextLength(locale);	        }	
public int getMaximumShortTextLength(Locale locale) {	            return getWrappedField().getMaximumShortTextLength(locale);	        }	
/**	     * Create a ZonedChronology for any chronology, overriding any time zone it	     * may already have.	     *	     * @param base base chronology to wrap	     * @param zone the time zone	     * @throws IllegalArgumentException if chronology or time zone is null	     */	    public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {	        if (base == null) {	            throw new IllegalArgumentException("Must supply a chronology");	        }	        base = base.withUTC();	        if (base == null) {	            throw new IllegalArgumentException("UTC chronology must not be null");	        }	        if (zone == null) {	            throw new IllegalArgumentException("DateTimeZone must not be null");	        }	        return new ZonedChronology(base, zone);	    }	
static boolean useTimeArithmetic(DurationField field) {	        // Use time of day arithmetic rules for unit durations less than	        // typical time zone offsets.	        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;	    }	
/**	     * Restricted constructor	     *	     * @param base base chronology to wrap	     * @param zone the time zone	     */	    private ZonedChronology(Chronology base, DateTimeZone zone) {	        super(base, zone);	    }	
public DateTimeZone getZone() {	        return (DateTimeZone)getParam();	    }	
public Chronology withUTC() {	        return getBase();	    }	
public Chronology withZone(DateTimeZone zone) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        if (zone == getParam()) {	            return this;	        }	        if (zone == DateTimeZone.UTC) {	            return getBase();	        }	        return new ZonedChronology(getBase(), zone);	    }	
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,	                                  int millisOfDay)	        throws IllegalArgumentException	    {	        return localToUTC(getBase().getDateTimeMillis	                          (year, monthOfYear, dayOfMonth, millisOfDay));	    }	
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,	                                  int hourOfDay, int minuteOfHour,	                                  int secondOfMinute, int millisOfSecond)	        throws IllegalArgumentException	    {	        return localToUTC(getBase().getDateTimeMillis	                          (year, monthOfYear, dayOfMonth, 	                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));	    }	
public long getDateTimeMillis(long instant,	                                  int hourOfDay, int minuteOfHour,	                                  int secondOfMinute, int millisOfSecond)	        throws IllegalArgumentException	    {	        return localToUTC(getBase().getDateTimeMillis	                          (instant + getZone().getOffset(instant),	                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));	    }	
/**	     * @param instant instant from 1970-01-01T00:00:00 local time	     * @return instant from 1970-01-01T00:00:00Z	     */	    private long localToUTC(long instant) {	        DateTimeZone zone = getZone();	        int offset = zone.getOffsetFromLocal(instant);	        instant -= offset;	        if (offset != zone.getOffset(instant)) {	            throw new IllegalArgumentException	                ("Illegal instant due to time zone offset transition: " +	                    DateTimeFormat.forPattern("yyyy-MM-dd'T'HH:mm:ss.SSS").print(new Instant(instant)));	        }	        return instant;	    }	
protected void assemble(Fields fields) {	        // Keep a local cache of converted fields so as not to create redundant	        // objects.	        HashMap<Object, Object> converted = new HashMap<Object, Object>();		        // Convert duration fields...		        fields.eras = convertField(fields.eras, converted);	        fields.centuries = convertField(fields.centuries, converted);	        fields.years = convertField(fields.years, converted);	        fields.months = convertField(fields.months, converted);	        fields.weekyears = convertField(fields.weekyears, converted);	        fields.weeks = convertField(fields.weeks, converted);	        fields.days = convertField(fields.days, converted);		        fields.halfdays = convertField(fields.halfdays, converted);	        fields.hours = convertField(fields.hours, converted);	        fields.minutes = convertField(fields.minutes, converted);	        fields.seconds = convertField(fields.seconds, converted);	        fields.millis = convertField(fields.millis, converted);		        // Convert datetime fields...		        fields.year = convertField(fields.year, converted);	        fields.yearOfEra = convertField(fields.yearOfEra, converted);	        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);	        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);	        fields.era = convertField(fields.era, converted);	        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);	        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);	        fields.dayOfYear = convertField(fields.dayOfYear, converted);	        fields.monthOfYear = convertField(fields.monthOfYear, converted);	        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);	        fields.weekyear = convertField(fields.weekyear, converted);	        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);		        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);	        fields.millisOfDay = convertField(fields.millisOfDay, converted);	        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);	        fields.secondOfDay = convertField(fields.secondOfDay, converted);	        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);	        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);	        fields.hourOfDay = convertField(fields.hourOfDay, converted);	        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);	        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);	        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);	        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);	    }	
private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {	        if (field == null || !field.isSupported()) {	            return field;	        }	        if (converted.containsKey(field)) {	            return (DurationField)converted.get(field);	        }	        ZonedDurationField zonedField = new ZonedDurationField(field, getZone());	        converted.put(field, zonedField);	        return zonedField;	    }	
private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {	        if (field == null || !field.isSupported()) {	            return field;	        }	        if (converted.containsKey(field)) {	            return (DateTimeField)converted.get(field);	        }	        ZonedDateTimeField zonedField =	            new ZonedDateTimeField(field, getZone(),	                                   convertField(field.getDurationField(), converted),	                                   convertField(field.getRangeDurationField(), converted),	                                   convertField(field.getLeapDurationField(), converted));	        converted.put(field, zonedField);	        return zonedField;	    }	
/**	     * A zoned chronology is only equal to a zoned chronology with the	     * same base chronology and zone.	     * 	     * @param obj  the object to compare to	     * @return true if equal	     * @since 1.4	     */	    public boolean equals(Object obj) {	        if (this == obj) {	            return true;	        }	        if (obj instanceof ZonedChronology == false) {	            return false;	        }	        ZonedChronology chrono = (ZonedChronology) obj;	        return	            getBase().equals(chrono.getBase()) &&	            getZone().equals(chrono.getZone());	    }	
/**	     * A suitable hashcode for the chronology.	     * 	     * @return the hashcode	     * @since 1.4	     */	    public int hashCode() {	        return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7;	    }	
/**	     * A debugging string for the chronology.	     * 	     * @return the debugging string	     */	    public String toString() {	        return "ZonedChronology[" + getBase() + ", " + getZone().getID() + ']';	    }	
ZonedDurationField(DurationField field, DateTimeZone zone) {	            super(field.getType());	            if (!field.isSupported()) {	                throw new IllegalArgumentException();	            }	            iField = field;	            iTimeField = useTimeArithmetic(field);	            iZone = zone;	        }	
public boolean isPrecise() {	            return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed();	        }	
public long getUnitMillis() {	            return iField.getUnitMillis();	        }	
public int getValue(long duration, long instant) {	            return iField.getValue(duration, addOffset(instant));	        }	
public long getValueAsLong(long duration, long instant) {	            return iField.getValueAsLong(duration, addOffset(instant));	        }	
public long getMillis(int value, long instant) {	            return iField.getMillis(value, addOffset(instant));	        }	
public long getMillis(long value, long instant) {	            return iField.getMillis(value, addOffset(instant));	        }	
public long add(long instant, int value) {	            int offset = getOffsetToAdd(instant);	            instant = iField.add(instant + offset, value);	            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));	        }	
public long add(long instant, long value) {	            int offset = getOffsetToAdd(instant);	            instant = iField.add(instant + offset, value);	            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));	        }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	            int offset = getOffsetToAdd(subtrahendInstant);	            return iField.getDifference	                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),	                 subtrahendInstant + offset);	        }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	            int offset = getOffsetToAdd(subtrahendInstant);	            return iField.getDifferenceAsLong	                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),	                 subtrahendInstant + offset);	        }	
private int getOffsetToAdd(long instant) {	            int offset = this.iZone.getOffset(instant);	            long sum = instant + offset;	            // If there is a sign change, but the two values have the same sign...	            if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {	                throw new ArithmeticException("Adding time zone offset caused overflow");	            }	            return offset;	        }	
private int getOffsetFromLocalToSubtract(long instant) {	            int offset = this.iZone.getOffsetFromLocal(instant);	            long diff = instant - offset;	            // If there is a sign change, but the two values have different signs...	            if ((instant ^ diff) < 0 && (instant ^ offset) < 0) {	                throw new ArithmeticException("Subtracting time zone offset caused overflow");	            }	            return offset;	        }	
private long addOffset(long instant) {	            return iZone.convertUTCToLocal(instant);	        }	
ZonedDateTimeField(DateTimeField field,	                           DateTimeZone zone,	                           DurationField durationField,	                           DurationField rangeDurationField,	                           DurationField leapDurationField) {	            super(field.getType());	            if (!field.isSupported()) {	                throw new IllegalArgumentException();	            }	            iField = field;	            iZone = zone;	            iDurationField = durationField;	            iTimeField = useTimeArithmetic(durationField);	            iRangeDurationField = rangeDurationField;	            iLeapDurationField = leapDurationField;	        }	
public boolean isLenient() {	            return iField.isLenient();	        }	
public int get(long instant) {	            long localInstant = iZone.convertUTCToLocal(instant);	            return iField.get(localInstant);	        }	
public String getAsText(long instant, Locale locale) {	            long localInstant = iZone.convertUTCToLocal(instant);	            return iField.getAsText(localInstant, locale);	        }	
public String getAsShortText(long instant, Locale locale) {	            long localInstant = iZone.convertUTCToLocal(instant);	            return iField.getAsShortText(localInstant, locale);	        }	
public String getAsText(int fieldValue, Locale locale) {	            return iField.getAsText(fieldValue, locale);	        }	
public String getAsShortText(int fieldValue, Locale locale) {	            return iField.getAsShortText(fieldValue, locale);	        }	
public long add(long instant, int value) {	            if (iTimeField) {	                int offset = getOffsetToAdd(instant);	                long localInstant = iField.add(instant + offset, value);	                return localInstant - offset;	            } else {	               long localInstant = iZone.convertUTCToLocal(instant);	               localInstant = iField.add(localInstant, value);	               return iZone.convertLocalToUTC(localInstant, false, instant);	            }	        }	
public long add(long instant, long value) {	            if (iTimeField) {	                int offset = getOffsetToAdd(instant);	                long localInstant = iField.add(instant + offset, value);	                return localInstant - offset;	            } else {	               long localInstant = iZone.convertUTCToLocal(instant);	               localInstant = iField.add(localInstant, value);	               return iZone.convertLocalToUTC(localInstant, false, instant);	            }	        }	
public long addWrapField(long instant, int value) {	            if (iTimeField) {	                int offset = getOffsetToAdd(instant);	                long localInstant = iField.addWrapField(instant + offset, value);	                return localInstant - offset;	            } else {	                long localInstant = iZone.convertUTCToLocal(instant);	                localInstant = iField.addWrapField(localInstant, value);	                return iZone.convertLocalToUTC(localInstant, false, instant);	            }	        }	
public long set(long instant, int value) {	            long localInstant = iZone.convertUTCToLocal(instant);	            localInstant = iField.set(localInstant, value);	            long result = iZone.convertLocalToUTC(localInstant, false, instant);	            if (get(result) != value) {	                throw new IllegalFieldValueException(iField.getType(), new Integer(value),	                    "Illegal instant due to time zone offset transition: " +	                    DateTimeFormat.forPattern("yyyy-MM-dd'T'HH:mm:ss.SSS").print(new Instant(localInstant)) +	                    " (" + iZone.getID() + ")");	            }	            return result;	        }	
public long set(long instant, String text, Locale locale) {	            // cannot verify that new value stuck because set may be lenient	            long localInstant = iZone.convertUTCToLocal(instant);	            localInstant = iField.set(localInstant, text, locale);	            return iZone.convertLocalToUTC(localInstant, false, instant);	        }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	            int offset = getOffsetToAdd(subtrahendInstant);	            return iField.getDifference	                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),	                 subtrahendInstant + offset);	        }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	            int offset = getOffsetToAdd(subtrahendInstant);	            return iField.getDifferenceAsLong	                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),	                 subtrahendInstant + offset);	        }	
public final DurationField getDurationField() {	            return iDurationField;	        }	
public final DurationField getRangeDurationField() {	            return iRangeDurationField;	        }	
public boolean isLeap(long instant) {	            long localInstant = iZone.convertUTCToLocal(instant);	            return iField.isLeap(localInstant);	        }	
public int getLeapAmount(long instant) {	            long localInstant = iZone.convertUTCToLocal(instant);	            return iField.getLeapAmount(localInstant);	        }	
public final DurationField getLeapDurationField() {	            return iLeapDurationField;	        }	
public long roundFloor(long instant) {	            if (iTimeField) {	                int offset = getOffsetToAdd(instant);	                instant = iField.roundFloor(instant + offset);	                return instant - offset;	            } else {	                long localInstant = iZone.convertUTCToLocal(instant);	                localInstant = iField.roundFloor(localInstant);	                return iZone.convertLocalToUTC(localInstant, false, instant);	            }	        }	
public long roundCeiling(long instant) {	            if (iTimeField) {	                int offset = getOffsetToAdd(instant);	                instant = iField.roundCeiling(instant + offset);	                return instant - offset;	            } else {	                long localInstant = iZone.convertUTCToLocal(instant);	                localInstant = iField.roundCeiling(localInstant);	                return iZone.convertLocalToUTC(localInstant, false, instant);	            }	        }	
public long remainder(long instant) {	            long localInstant = iZone.convertUTCToLocal(instant);	            return iField.remainder(localInstant);	        }	
public int getMinimumValue() {	            return iField.getMinimumValue();	        }	
public int getMinimumValue(long instant) {	            long localInstant = iZone.convertUTCToLocal(instant);	            return iField.getMinimumValue(localInstant);	        }	
public int getMinimumValue(ReadablePartial instant) {	            return iField.getMinimumValue(instant);	        }	
public int getMinimumValue(ReadablePartial instant, int[] values) {	            return iField.getMinimumValue(instant, values);	        }	
public int getMaximumValue() {	            return iField.getMaximumValue();	        }	
public int getMaximumValue(long instant) {	            long localInstant = iZone.convertUTCToLocal(instant);	            return iField.getMaximumValue(localInstant);	        }	
public int getMaximumValue(ReadablePartial instant) {	            return iField.getMaximumValue(instant);	        }	
public int getMaximumValue(ReadablePartial instant, int[] values) {	            return iField.getMaximumValue(instant, values);	        }	
public int getMaximumTextLength(Locale locale) {	            return iField.getMaximumTextLength(locale);	        }	
public int getMaximumShortTextLength(Locale locale) {	            return iField.getMaximumShortTextLength(locale);	        }	
private int getOffsetToAdd(long instant) {	            int offset = this.iZone.getOffset(instant);	            long sum = instant + offset;	            // If there is a sign change, but the two values have the same sign...	            if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {	                throw new ArithmeticException("Adding time zone offset caused overflow");	            }	            return offset;	        }	
/**	     * Restricted constructor	     */	    BasicWeekOfWeekyearDateTimeField(BasicChronology chronology, DurationField weeks) {	        super(DateTimeFieldType.weekOfWeekyear(), weeks);	        iChronology = chronology;	    }	
/**	     * Get the week of a week based year component of the specified time instant.	     * 	     * @see org.joda.time.DateTimeField#get(long)	     * @param instant  the time instant in millis to query.	     * @return the week of the year extracted from the input.	     */	    public int get(long instant) {	        return iChronology.getWeekOfWeekyear(instant);	    }	
public DurationField getRangeDurationField() {	        return iChronology.weekyears();	    }	
public long roundFloor(long instant) {	        return super.roundFloor(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)	            - 3 * DateTimeConstants.MILLIS_PER_DAY;	    }	
public long roundCeiling(long instant) {	        return super.roundCeiling(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)	            - 3 * DateTimeConstants.MILLIS_PER_DAY;	    }	
public long remainder(long instant) {	        return super.remainder(instant + 3 * DateTimeConstants.MILLIS_PER_DAY);	    }	
public int getMinimumValue() {	        return 1;	    }	
public int getMaximumValue() {	        return 53;	    }	
public int getMaximumValue(long instant) {	        int weekyear = iChronology.getWeekyear(instant);	        return iChronology.getWeeksInYear(weekyear);	    }	
public int getMaximumValue(ReadablePartial partial) {	        if (partial.isSupported(DateTimeFieldType.weekyear())) {	            int weekyear = partial.get(DateTimeFieldType.weekyear());	            return iChronology.getWeeksInYear(weekyear);	        }	        return 53;	    }	
public int getMaximumValue(ReadablePartial partial, int[] values) {	        int size = partial.size();	        for (int i = 0; i < size; i++) {	            if (partial.getFieldType(i) == DateTimeFieldType.weekyear()) {	                int weekyear = values[i];	                return iChronology.getWeeksInYear(weekyear);	            }	        }	        return 53;	    }	
protected int getMaximumValueForSet(long instant, int value) {	        return value > 52 ? getMaximumValue(instant) : 52;	    }	
/**	     * Serialization singleton	     */	    private Object readResolve() {	        return iChronology.weekOfWeekyear();	    }	
/**	     * Constructor calls the assemble method, enabling subclasses to define its	     * supported fields. If a base chronology is supplied, the field set	     * initially contains references to each base chronology field.	     * <p>	     * Other methods in this class will delegate to the base chronology, if it	     * can be determined that the base chronology will produce the same results	     * as AbstractChronology.	     *	     * @param base optional base chronology to copy initial fields from	     * @param param optional param object avalable for assemble method	     */	    protected AssembledChronology(Chronology base, Object param) {	        iBase = base;	        iParam = param;	        setFields();	    }	
public DateTimeZone getZone() {	        Chronology base;	        if ((base = iBase) != null) {	            return base.getZone();	        }	        return null;	    }	
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,	                                  int millisOfDay)	        throws IllegalArgumentException	    {	        Chronology base;	        if ((base = iBase) != null && (iBaseFlags & 6) == 6) {	            // Only call specialized implementation if applicable fields are the same.	            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);	        }	        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);	    }	
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,	                                  int hourOfDay, int minuteOfHour,	                                  int secondOfMinute, int millisOfSecond)	        throws IllegalArgumentException	    {	        Chronology base;	        if ((base = iBase) != null && (iBaseFlags & 5) == 5) {	            // Only call specialized implementation if applicable fields are the same.	            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,	                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	        }	        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth,	                                       hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	    }	
public long getDateTimeMillis(long instant,	                                  int hourOfDay, int minuteOfHour,	                                  int secondOfMinute, int millisOfSecond)	        throws IllegalArgumentException	    {	        Chronology base;	        if ((base = iBase) != null && (iBaseFlags & 1) == 1) {	            // Only call specialized implementation if applicable fields are the same.	            return base.getDateTimeMillis	                (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	        }	        return super.getDateTimeMillis	            (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	    }	
public final DurationField millis() {	        return iMillis;	    }	
public final DateTimeField millisOfSecond() {	        return iMillisOfSecond;	    }	
public final DateTimeField millisOfDay() {	        return iMillisOfDay;	    }	
public final DurationField seconds() {	        return iSeconds;	    }	
public final DateTimeField secondOfMinute() {	        return iSecondOfMinute;	    }	
public final DateTimeField secondOfDay() {	        return iSecondOfDay;	    }	
public final DurationField minutes() {	        return iMinutes;	    }	
public final DateTimeField minuteOfHour() {	        return iMinuteOfHour;	    }	
public final DateTimeField minuteOfDay() {	        return iMinuteOfDay;	    }	
public final DurationField hours() {	        return iHours;	    }	
public final DateTimeField hourOfDay() {	        return iHourOfDay;	    }	
public final DateTimeField clockhourOfDay() {	        return iClockhourOfDay;	    }	
public final DurationField halfdays() {	        return iHalfdays;	    }	
public final DateTimeField hourOfHalfday() {	        return iHourOfHalfday;	    }	
public final DateTimeField clockhourOfHalfday() {	        return iClockhourOfHalfday;	    }	
public final DateTimeField halfdayOfDay() {	        return iHalfdayOfDay;	    }	
public final DurationField days() {	        return iDays;	    }	
public final DateTimeField dayOfWeek() {	        return iDayOfWeek;	    }	
public final DateTimeField dayOfMonth() {	        return iDayOfMonth;	    }	
public final DateTimeField dayOfYear() {	        return iDayOfYear;	    }	
public final DurationField weeks() {	        return iWeeks;	    }	
public final DateTimeField weekOfWeekyear() {	        return iWeekOfWeekyear;	    }	
public final DurationField weekyears() {	        return iWeekyears;	    }	
public final DateTimeField weekyear() {	        return iWeekyear;	    }	
public final DateTimeField weekyearOfCentury() {	        return iWeekyearOfCentury;	    }	
public final DurationField months() {	        return iMonths;	    }	
public final DateTimeField monthOfYear() {	        return iMonthOfYear;	    }	
public final DurationField years() {	        return iYears;	    }	
public final DateTimeField year() {	        return iYear;	    }	
public final DateTimeField yearOfEra() {	        return iYearOfEra;	    }	
public final DateTimeField yearOfCentury() {	        return iYearOfCentury;	    }	
public final DurationField centuries() {	        return iCenturies;	    }	
public final DateTimeField centuryOfEra() {	        return iCenturyOfEra;	    }	
public final DurationField eras() {	        return iEras;	    }	
public final DateTimeField era() {	        return iEra;	    }	
/**	     * Returns the same base chronology as passed into the constructor.	     */	    protected final Chronology getBase() {	        return iBase;	    }	
/**	     * Returns the same param object as passed into the constructor.	     */	    protected final Object getParam() {	        return iParam;	    }	
private void setFields() {	        Fields fields = new Fields();	        if (iBase != null) {	            fields.copyFieldsFrom(iBase);	        }	        assemble(fields);		        {	            DurationField f;	            iMillis    = (f = fields.millis)    != null ? f : super.millis();	            iSeconds   = (f = fields.seconds)   != null ? f : super.seconds();	            iMinutes   = (f = fields.minutes)   != null ? f : super.minutes();	            iHours     = (f = fields.hours)     != null ? f : super.hours();	            iHalfdays  = (f = fields.halfdays)  != null ? f : super.halfdays();	            iDays      = (f = fields.days)      != null ? f : super.days();	            iWeeks     = (f = fields.weeks)     != null ? f : super.weeks();	            iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears();	            iMonths    = (f = fields.months)    != null ? f : super.months();	            iYears     = (f = fields.years)     != null ? f : super.years();	            iCenturies = (f = fields.centuries) != null ? f : super.centuries();	            iEras      = (f = fields.eras)      != null ? f : super.eras();	        }		        {	            DateTimeField f;	            iMillisOfSecond     = (f = fields.millisOfSecond)     != null ? f : super.millisOfSecond();	            iMillisOfDay        = (f = fields.millisOfDay)        != null ? f : super.millisOfDay();	            iSecondOfMinute     = (f = fields.secondOfMinute)     != null ? f : super.secondOfMinute();	            iSecondOfDay        = (f = fields.secondOfDay)        != null ? f : super.secondOfDay();	            iMinuteOfHour       = (f = fields.minuteOfHour)       != null ? f : super.minuteOfHour();	            iMinuteOfDay        = (f = fields.minuteOfDay)        != null ? f : super.minuteOfDay();	            iHourOfDay          = (f = fields.hourOfDay)          != null ? f : super.hourOfDay();	            iClockhourOfDay     = (f = fields.clockhourOfDay)     != null ? f : super.clockhourOfDay();	            iHourOfHalfday      = (f = fields.hourOfHalfday)      != null ? f : super.hourOfHalfday();	            iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday();	            iHalfdayOfDay       = (f = fields.halfdayOfDay)       != null ? f : super.halfdayOfDay();	            iDayOfWeek          = (f = fields.dayOfWeek)          != null ? f : super.dayOfWeek();	            iDayOfMonth         = (f = fields.dayOfMonth)         != null ? f : super.dayOfMonth();	            iDayOfYear          = (f = fields.dayOfYear)          != null ? f : super.dayOfYear();	            iWeekOfWeekyear     = (f = fields.weekOfWeekyear)     != null ? f : super.weekOfWeekyear();	            iWeekyear           = (f = fields.weekyear)           != null ? f : super.weekyear();	            iWeekyearOfCentury  = (f = fields.weekyearOfCentury)  != null ? f : super.weekyearOfCentury();	            iMonthOfYear        = (f = fields.monthOfYear)        != null ? f : super.monthOfYear();	            iYear               = (f = fields.year)               != null ? f : super.year();	            iYearOfEra          = (f = fields.yearOfEra)          != null ? f : super.yearOfEra();	            iYearOfCentury      = (f = fields.yearOfCentury)      != null ? f : super.yearOfCentury();	            iCenturyOfEra       = (f = fields.centuryOfEra)       != null ? f : super.centuryOfEra();	            iEra                = (f = fields.era)                != null ? f : super.era();	        }		        int flags;	        if (iBase == null) {	            flags = 0;	        } else {	            flags = 	                ((iHourOfDay      == iBase.hourOfDay()      &&	                  iMinuteOfHour   == iBase.minuteOfHour()   &&	                  iSecondOfMinute == iBase.secondOfMinute() &&	                  iMillisOfSecond == iBase.millisOfSecond()   ) ? 1 : 0) |		                ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) |		                ((iYear        == iBase.year()        &&	                  iMonthOfYear == iBase.monthOfYear() &&	                  iDayOfMonth  == iBase.dayOfMonth()    ) ? 4 : 0);	        }		        iBaseFlags = flags;	    }	
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {	        in.defaultReadObject();	        setFields();	    }	
Fields() {	        }	
/**	         * Copy the supported fields from a chronology into this container.	         */	        public void copyFieldsFrom(Chronology chrono) {	            {	                DurationField f;	                if (isSupported(f = chrono.millis())) {	                    millis = f;	                }	                if (isSupported(f = chrono.seconds())) {	                    seconds = f;	                }	                if (isSupported(f = chrono.minutes())) {	                    minutes = f;	                }	                if (isSupported(f = chrono.hours())) {	                    hours = f;	                }	                if (isSupported(f = chrono.halfdays())) {	                    halfdays = f;	                }	                if (isSupported(f = chrono.days())) {	                    days = f;	                }	                if (isSupported(f = chrono.weeks())) {	                    weeks = f;	                }	                if (isSupported(f = chrono.weekyears())) {	                    weekyears = f;	                }	                if (isSupported(f = chrono.months())) {	                    months = f;	                }	                if (isSupported(f = chrono.years())) {	                    years = f;	                }	                if (isSupported(f = chrono.centuries())) {	                    centuries = f;	                }	                if (isSupported(f = chrono.eras())) {	                    eras = f;	                }	            }		            {	                DateTimeField f;	                if (isSupported(f = chrono.millisOfSecond())) {	                    millisOfSecond = f;	                }	                if (isSupported(f = chrono.millisOfDay())) {	                    millisOfDay = f;	                }	                if (isSupported(f = chrono.secondOfMinute())) {	                    secondOfMinute = f;	                }	                if (isSupported(f = chrono.secondOfDay())) {	                    secondOfDay = f;	                }	                if (isSupported(f = chrono.minuteOfHour())) {	                    minuteOfHour = f;	                }	                if (isSupported(f = chrono.minuteOfDay())) {	                    minuteOfDay = f;	                }	                if (isSupported(f = chrono.hourOfDay())) {	                    hourOfDay = f;	                }	                if (isSupported(f = chrono.clockhourOfDay())) {	                    clockhourOfDay = f;	                }	                if (isSupported(f = chrono.hourOfHalfday())) {	                    hourOfHalfday = f;	                }	                if (isSupported(f = chrono.clockhourOfHalfday())) {	                    clockhourOfHalfday = f;	                }	                if (isSupported(f = chrono.halfdayOfDay())) {	                    halfdayOfDay = f;	                }	                if (isSupported(f = chrono.dayOfWeek())) {	                    dayOfWeek = f;	                }	                if (isSupported(f = chrono.dayOfMonth())) {	                    dayOfMonth = f;	                }	                if (isSupported(f = chrono.dayOfYear())) {	                    dayOfYear = f;	                }	                if (isSupported(f = chrono.weekOfWeekyear())) {	                    weekOfWeekyear = f;	                }	                if (isSupported(f = chrono.weekyear())) {	                    weekyear = f;	                }	                if (isSupported(f = chrono.weekyearOfCentury())) {	                    weekyearOfCentury = f;	                }	                if (isSupported(f = chrono.monthOfYear())) {	                    monthOfYear = f;	                }	                if (isSupported(f = chrono.year())) {	                    year = f;	                }	                if (isSupported(f = chrono.yearOfEra())) {	                    yearOfEra = f;	                }	                if (isSupported(f = chrono.yearOfCentury())) {	                    yearOfCentury = f;	                }	                if (isSupported(f = chrono.centuryOfEra())) {	                    centuryOfEra = f;	                }	                if (isSupported(f = chrono.era())) {	                    era = f;	                }	            }	        }	
private static boolean isSupported(DurationField field) {	            return field == null ? false : field.isSupported();	        }	
private static boolean isSupported(DateTimeField field) {	            return field == null ? false : field.isSupported();	        }	
BasicChronology(Chronology base, Object param, int minDaysInFirstWeek) {	        super(base, param);		        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {	            throw new IllegalArgumentException	                ("Invalid min days in first week: " + minDaysInFirstWeek);	        }		        iMinDaysInFirstWeek = minDaysInFirstWeek;	    }	
public DateTimeZone getZone() {	        Chronology base;	        if ((base = getBase()) != null) {	            return base.getZone();	        }	        return DateTimeZone.UTC;	    }	
public long getDateTimeMillis(	            int year, int monthOfYear, int dayOfMonth, int millisOfDay)	            throws IllegalArgumentException {	        Chronology base;	        if ((base = getBase()) != null) {	            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);	        }		        FieldUtils.verifyValueBounds	            (DateTimeFieldType.millisOfDay(), millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY);	        return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + millisOfDay;	    }	
public long getDateTimeMillis(	            int year, int monthOfYear, int dayOfMonth,	            int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)	            throws IllegalArgumentException {	        Chronology base;	        if ((base = getBase()) != null) {	            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,	                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	        }		        FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23);	        FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59);	        FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59);	        FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999);		        return getDateMidnightMillis(year, monthOfYear, dayOfMonth)	            + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR	            + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE	            + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND	            + millisOfSecond;	    }	
public int getMinimumDaysInFirstWeek() {	        return iMinDaysInFirstWeek;	    }	
/**	     * Checks if this chronology instance equals another.	     * 	     * @param obj  the object to compare to	     * @return true if equal	     * @since 1.6	     */	    public boolean equals(Object obj) {	        return super.equals(obj);	    }	
/**	     * A suitable hash code for the chronology.	     * 	     * @return the hash code	     * @since 1.6	     */	    public int hashCode() {	        return getClass().getName().hashCode() * 11 + getZone().hashCode() + getMinimumDaysInFirstWeek();	    }	
/**	     * Gets a debugging toString.	     * 	     * @return a debugging string	     */	    public String toString() {	        StringBuffer sb = new StringBuffer(60);	        String name = getClass().getName();	        int index = name.lastIndexOf('.');	        if (index >= 0) {	            name = name.substring(index + 1);	        }	        sb.append(name);	        sb.append('[');	        DateTimeZone zone = getZone();	        if (zone != null) {	            sb.append(zone.getID());	        }	        if (getMinimumDaysInFirstWeek() != 4) {	            sb.append(",mdfw=");	            sb.append(getMinimumDaysInFirstWeek());	        }	        sb.append(']');	        return sb.toString();	    }	
protected void assemble(Fields fields) {	        // First copy fields that are the same for all Gregorian and Julian	        // chronologies.		        fields.millis = cMillisField;	        fields.seconds = cSecondsField;	        fields.minutes = cMinutesField;	        fields.hours = cHoursField;	        fields.halfdays = cHalfdaysField;	        fields.days = cDaysField;	        fields.weeks = cWeeksField;		        fields.millisOfSecond = cMillisOfSecondField;	        fields.millisOfDay = cMillisOfDayField;	        fields.secondOfMinute = cSecondOfMinuteField;	        fields.secondOfDay = cSecondOfDayField;	        fields.minuteOfHour = cMinuteOfHourField;	        fields.minuteOfDay = cMinuteOfDayField;	        fields.hourOfDay = cHourOfDayField;	        fields.hourOfHalfday = cHourOfHalfdayField;	        fields.clockhourOfDay = cClockhourOfDayField;	        fields.clockhourOfHalfday = cClockhourOfHalfdayField;	        fields.halfdayOfDay = cHalfdayOfDayField;		        // Now create fields that have unique behavior for Gregorian and Julian	        // chronologies.		        fields.year = new BasicYearDateTimeField(this);	        fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);		        // Define one-based centuryOfEra and yearOfCentury.	        DateTimeField field = new OffsetDateTimeField(	            fields.yearOfEra, 99);	        fields.centuryOfEra = new DividedDateTimeField(	            field, DateTimeFieldType.centuryOfEra(), 100);	        	        field = new RemainderDateTimeField(	            (DividedDateTimeField) fields.centuryOfEra);	        fields.yearOfCentury = new OffsetDateTimeField(	            field, DateTimeFieldType.yearOfCentury(), 1);		        fields.era = new GJEraDateTimeField(this);	        fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);	        fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);	        fields.dayOfYear = new BasicDayOfYearDateTimeField(this, fields.days);	        fields.monthOfYear = new GJMonthOfYearDateTimeField(this);	        fields.weekyear = new BasicWeekyearDateTimeField(this);	        fields.weekOfWeekyear = new BasicWeekOfWeekyearDateTimeField(this, fields.weeks);	        	        field = new RemainderDateTimeField(	            fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);	        fields.weekyearOfCentury = new OffsetDateTimeField(	            field, DateTimeFieldType.weekyearOfCentury(), 1);	        	        // The remaining (imprecise) durations are available from the newly	        // created datetime fields.		        fields.years = fields.year.getDurationField();	        fields.centuries = fields.centuryOfEra.getDurationField();	        fields.months = fields.monthOfYear.getDurationField();	        fields.weekyears = fields.weekyear.getDurationField();	    }	
/**	     * Get the number of days in the year.	     *	     * @return 366	     */	    int getDaysInYearMax() {	        return 366;	    }	
/**	     * Get the number of days in the year.	     *	     * @param year  the year to use	     * @return 366 if a leap year, otherwise 365	     */	    int getDaysInYear(int year) {	        return isLeapYear(year) ? 366 : 365;	    }	
/**	     * Get the number of weeks in the year.	     *	     * @param year  the year to use	     * @return number of weeks in the year	     */	    int getWeeksInYear(int year) {	        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);	        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);	        return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK);	    }	
/**	     * Get the millis for the first week of a year.	     *	     * @param year  the year to use	     * @return millis	     */	    long getFirstWeekOfYearMillis(int year) {	        long jan1millis = getYearMillis(year);	        int jan1dayOfWeek = getDayOfWeek(jan1millis);	        	        if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) {	            // First week is end of previous year because it doesn't have enough days.	            return jan1millis + (8 - jan1dayOfWeek)	                * (long)DateTimeConstants.MILLIS_PER_DAY;	        } else {	            // First week is start of this year because it has enough days.	            return jan1millis - (jan1dayOfWeek - 1)	                * (long)DateTimeConstants.MILLIS_PER_DAY;	        }	    }	
/**	     * Get the milliseconds for the start of a year.	     *	     * @param year The year to use.	     * @return millis from 1970-01-01T00:00:00Z	     */	    long getYearMillis(int year) {	        return getYearInfo(year).iFirstDayMillis;	    }	
/**	     * Get the milliseconds for the start of a month.	     *	     * @param year The year to use.	     * @param month The month to use	     * @return millis from 1970-01-01T00:00:00Z	     */	    long getYearMonthMillis(int year, int month) {	        long millis = getYearMillis(year);	        millis += getTotalMillisByYearMonth(year, month);	        return millis;	    }	
/**	     * Get the milliseconds for a particular date.	     *	     * @param year The year to use.	     * @param month The month to use	     * @param dayOfMonth The day of the month to use	     * @return millis from 1970-01-01T00:00:00Z	     */	    long getYearMonthDayMillis(int year, int month, int dayOfMonth) {	        long millis = getYearMillis(year);	        millis += getTotalMillisByYearMonth(year, month);	        return millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;	    }	
/**	     * @param instant millis from 1970-01-01T00:00:00Z	     */	    int getYear(long instant) {	        // Get an initial estimate of the year, and the millis value that	        // represents the start of that year. Then verify estimate and fix if	        // necessary.		        // Initial estimate uses values divided by two to avoid overflow.	        long unitMillis = getAverageMillisPerYearDividedByTwo();	        long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();	        if (i2 < 0) {	            i2 = i2 - unitMillis + 1;	        }	        int year = (int) (i2 / unitMillis);		        long yearStart = getYearMillis(year);	        long diff = instant - yearStart;		        if (diff < 0) {	            year--;	        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {	            // One year may need to be added to fix estimate.	            long oneYear;	            if (isLeapYear(year)) {	                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;	            } else {	                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;	            }		            yearStart += oneYear;		            if (yearStart <= instant) {	                // Didn't go too far, so actually add one year.	                year++;	            }	        }		        return year;	    }	
/**	     * @param millis from 1970-01-01T00:00:00Z	     */	    int getMonthOfYear(long millis) {	        return getMonthOfYear(millis, getYear(millis));	    }	
/**	     * @param millis from 1970-01-01T00:00:00Z	     */	    int getDayOfMonth(long millis) {	        int year = getYear(millis);	        int month = getMonthOfYear(millis, year);	        return getDayOfMonth(millis, year, month);	    }	
/**	     * @param millis from 1970-01-01T00:00:00Z	     * @param year precalculated year of millis	     */	    int getDayOfMonth(long millis, int year) {	        int month = getMonthOfYear(millis, year);	        return getDayOfMonth(millis, year, month);	    }	
/**	     * @param millis from 1970-01-01T00:00:00Z	     * @param year precalculated year of millis	     * @param month precalculated month of millis	     */	    int getDayOfMonth(long millis, int year, int month) {	        long dateMillis = getYearMillis(year);	        dateMillis += getTotalMillisByYearMonth(year, month);	        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;	    }	
/**	     * @param instant millis from 1970-01-01T00:00:00Z	     */	    int getDayOfYear(long instant) {	        return getDayOfYear(instant, getYear(instant));	    }	
/**	     * @param instant millis from 1970-01-01T00:00:00Z	     * @param year precalculated year of millis	     */	    int getDayOfYear(long instant, int year) {	        long yearStart = getYearMillis(year);	        return (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;	    }	
/**	     * @param instant millis from 1970-01-01T00:00:00Z	     */	    int getWeekyear(long instant) {	        int year = getYear(instant);	        int week = getWeekOfWeekyear(instant, year);	        if (week == 1) {	            return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK);	        } else if (week > 51) {	            return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));	        } else {	            return year;	        }	    }	
/**	     * @param instant millis from 1970-01-01T00:00:00Z	     */	    int getWeekOfWeekyear(long instant) {	        return getWeekOfWeekyear(instant, getYear(instant));	    }	
/**	     * @param instant millis from 1970-01-01T00:00:00Z	     * @param year precalculated year of millis	     */	    int getWeekOfWeekyear(long instant, int year) {	        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);	        if (instant < firstWeekMillis1) {	            return getWeeksInYear(year - 1);	        }	        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);	        if (instant >= firstWeekMillis2) {	            return 1;	        }	        return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;	    }	
/**	     * @param instant millis from 1970-01-01T00:00:00Z	     */	    int getDayOfWeek(long instant) {	        // 1970-01-01 is day of week 4, Thursday.		        long daysSince19700101;	        if (instant >= 0) {	            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;	        } else {	            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))	                / DateTimeConstants.MILLIS_PER_DAY;	            if (daysSince19700101 < -3) {	                return 7 + (int) ((daysSince19700101 + 4) % 7);	            }	        }		        return 1 + (int) ((daysSince19700101 + 3) % 7);	    }	
/**	     * @param instant millis from 1970-01-01T00:00:00Z	     */	    int getMillisOfDay(long instant) {	        if (instant >= 0) {	            return (int) (instant % DateTimeConstants.MILLIS_PER_DAY);	        } else {	            return (DateTimeConstants.MILLIS_PER_DAY - 1)	                + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY);	        }	    }	
/**	     * Gets the maximum number of days in any month.	     * 	     * @return 31	     */	    int getDaysInMonthMax() {	        return 31;	    }	
/**	     * Gets the maximum number of days in the month specified by the instant.	     * 	     * @param instant  millis from 1970-01-01T00:00:00Z	     * @return the maximum number of days in the month	     */	    int getDaysInMonthMax(long instant) {	        int thisYear = getYear(instant);	        int thisMonth = getMonthOfYear(instant, thisYear);	        return getDaysInYearMonth(thisYear, thisMonth);	    }	
/**	     * Gets the maximum number of days in the month specified by the instant.	     * The value represents what the user is trying to set, and can be	     * used to optimise this method.	     * 	     * @param instant  millis from 1970-01-01T00:00:00Z	     * @param value  the value being set	     * @return the maximum number of days in the month	     */	    int getDaysInMonthMaxForSet(long instant, int value) {	        return getDaysInMonthMax(instant);	    }	
/**	     * Gets the milliseconds for a date at midnight.	     * 	     * @param year  the year	     * @param monthOfYear  the month	     * @param dayOfMonth  the day	     * @return the milliseconds	     */	    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {	        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());	        FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year));	        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));	        return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);	    }	
/**	     * Gets the maximum month for the specified year.	     * This implementation calls getMaxMonth().	     * 	     * @param year  the year	     * @return the maximum month value	     */	    int getMaxMonth(int year) {	        return getMaxMonth();	    }	
/**	     * Gets the maximum number of months.	     * 	     * @return 12	     */	    int getMaxMonth() {	        return 12;	    }	
private YearInfo getYearInfo(int year) {	        YearInfo info = iYearInfoCache[year & CACHE_MASK];	        if (info == null || info.iYear != year) {	            info = new YearInfo(year, calculateFirstDayOfYearMillis(year));	            iYearInfoCache[year & CACHE_MASK] = info;	        }	        return info;	    }	
HalfdayField() {	            super(DateTimeFieldType.halfdayOfDay(), cHalfdaysField, cDaysField);	        }	
public String getAsText(int fieldValue, Locale locale) {	            return GJLocaleSymbols.forLocale(locale).halfdayValueToText(fieldValue);	        }	
public long set(long millis, String text, Locale locale) {	            return set(millis, GJLocaleSymbols.forLocale(locale).halfdayTextToValue(text));	        }	
public int getMaximumTextLength(Locale locale) {	            return GJLocaleSymbols.forLocale(locale).getHalfdayMaxTextLength();	        }	
YearInfo(int year, long firstDayMillis) {	            iYear = year;	            iFirstDayMillis = firstDayMillis;	        }	
/**	     * Restricted constructor	     */	    GJEraDateTimeField(BasicChronology chronology) {	        super(DateTimeFieldType.era());	        iChronology = chronology;	    }	
public boolean isLenient() {	        return false;	    }	
/**	     * Get the Era component of the specified time instant.	     * 	     * @param instant  the time instant in millis to query.	     */	    public int get(long instant) {	        if (iChronology.getYear(instant) <= 0) {	            return DateTimeConstants.BCE;	        } else {	            return DateTimeConstants.CE;	        }	    }	
public String getAsText(int fieldValue, Locale locale) {	        return GJLocaleSymbols.forLocale(locale).eraValueToText(fieldValue);	    }	
/**	     * Set the Era component of the specified time instant.	     * 	     * @param instant  the time instant in millis to update.	     * @param era  the era to update the time to.	     * @return the updated time instant.	     * @throws IllegalArgumentException  if era is invalid.	     */	    public long set(long instant, int era) {	        FieldUtils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE);	            	        int oldEra = get(instant);	        if (oldEra != era) {	            int year = iChronology.getYear(instant);	            return iChronology.setYear(instant, -year);	        } else {	            return instant;	        }	    }	
public long set(long instant, String text, Locale locale) {	        return set(instant, GJLocaleSymbols.forLocale(locale).eraTextToValue(text));	    }	
public long roundFloor(long instant) {	        if (get(instant) == DateTimeConstants.CE) {	            return iChronology.setYear(0, 1);	        } else {	            return Long.MIN_VALUE;	        }	    }	
public long roundCeiling(long instant) {	        if (get(instant) == DateTimeConstants.BCE) {	            return iChronology.setYear(0, 1);	        } else {	            return Long.MAX_VALUE;	        }	    }	
public long roundHalfFloor(long instant) {	        // In reality, the era is infinite, so there is no halfway point.	        return roundFloor(instant);	    }	
public long roundHalfCeiling(long instant) {	        // In reality, the era is infinite, so there is no halfway point.	        return roundFloor(instant);	    }	
public long roundHalfEven(long instant) {	        // In reality, the era is infinite, so there is no halfway point.	        return roundFloor(instant);	    }	
public DurationField getDurationField() {	        return UnsupportedDurationField.getInstance(DurationFieldType.eras());	    }	
public DurationField getRangeDurationField() {	        return null;	    }	
public int getMinimumValue() {	        return DateTimeConstants.BCE;	    }	
public int getMaximumValue() {	        return DateTimeConstants.CE;	    }	
public int getMaximumTextLength(Locale locale) {	        return GJLocaleSymbols.forLocale(locale).getEraMaxTextLength();	    }	
/**	     * Serialization singleton	     */	    private Object readResolve() {	        return iChronology.era();	    }	
/**	     * Restricted constructor.	     */	    protected BaseChronology() {	        super();	    }	
/**	     * Returns a datetime millisecond instant, formed from the given year,	     * month, day, and millisecond values. The set of given values must refer	     * to a valid datetime, or else an IllegalArgumentException is thrown.	     * <p>	     * The default implementation calls upon separate DateTimeFields to	     * determine the result. Subclasses are encouraged to provide a more	     * efficient implementation.	     *	     * @param year year to use	     * @param monthOfYear month to use	     * @param dayOfMonth day of month to use	     * @param millisOfDay millisecond to use	     * @return millisecond instant from 1970-01-01T00:00:00Z	     */	    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,	                                  int millisOfDay)	        throws IllegalArgumentException	    {	        long instant = year().set(0, year);	        instant = monthOfYear().set(instant, monthOfYear);	        instant = dayOfMonth().set(instant, dayOfMonth);	        return millisOfDay().set(instant, millisOfDay);	    }	
/**	     * Returns a datetime millisecond instant, formed from the given year,	     * month, day, hour, minute, second, and millisecond values. The set of	     * given values must refer to a valid datetime, or else an	     * IllegalArgumentException is thrown.	     * <p>	     * The default implementation calls upon separate DateTimeFields to	     * determine the result. Subclasses are encouraged to provide a more	     * efficient implementation.	     *	     * @param year year to use	     * @param monthOfYear month to use	     * @param dayOfMonth day of month to use	     * @param hourOfDay hour to use	     * @param minuteOfHour minute to use	     * @param secondOfMinute second to use	     * @param millisOfSecond millisecond to use	     * @return millisecond instant from 1970-01-01T00:00:00Z	     */	    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,	                                  int hourOfDay, int minuteOfHour,	                                  int secondOfMinute, int millisOfSecond)	        throws IllegalArgumentException	    {	        long instant = year().set(0, year);	        instant = monthOfYear().set(instant, monthOfYear);	        instant = dayOfMonth().set(instant, dayOfMonth);	        instant = hourOfDay().set(instant, hourOfDay);	        instant = minuteOfHour().set(instant, minuteOfHour);	        instant = secondOfMinute().set(instant, secondOfMinute);	        return millisOfSecond().set(instant, millisOfSecond);	    }	
/**	     * Returns a datetime millisecond instant, from from the given instant,	     * hour, minute, second, and millisecond values. The set of given values	     * must refer to a valid datetime, or else an IllegalArgumentException is	     * thrown.	     * <p>	     * The default implementation calls upon separate DateTimeFields to	     * determine the result. Subclasses are encouraged to provide a more	     * efficient implementation.	     *	     * @param instant instant to start from	     * @param hourOfDay hour to use	     * @param minuteOfHour minute to use	     * @param secondOfMinute second to use	     * @param millisOfSecond millisecond to use	     * @return millisecond instant from 1970-01-01T00:00:00Z	     */	    public long getDateTimeMillis(long instant,	                                  int hourOfDay, int minuteOfHour,	                                  int secondOfMinute, int millisOfSecond)	        throws IllegalArgumentException	    {	        instant = hourOfDay().set(instant, hourOfDay);	        instant = minuteOfHour().set(instant, minuteOfHour);	        instant = secondOfMinute().set(instant, secondOfMinute);	        return millisOfSecond().set(instant, millisOfSecond);	    }	
/**	     * Validates whether the fields stored in a partial instant are valid.	     * <p>	     * This implementation uses {@link DateTimeField#getMinimumValue(ReadablePartial, int[])}	     * and {@link DateTimeField#getMaximumValue(ReadablePartial, int[])}.	     *	     * @param partial  the partial instant to validate	     * @param values  the values to validate, not null	     * @throws IllegalArgumentException if the instant is invalid	     */	    public void validate(ReadablePartial partial, int[] values) {	        // check values in standard range, catching really stupid cases like -1	        // this means that the second check will not hit trouble	        int size = partial.size();	        for (int i = 0; i < size; i++) {	            int value = values[i];	            DateTimeField field = partial.getField(i);	            if (value < field.getMinimumValue()) {	                throw new IllegalFieldValueException	                    (field.getType(), new Integer(value),	                     new Integer(field.getMinimumValue()), null);	            }	            if (value > field.getMaximumValue()) {	                throw new IllegalFieldValueException	                    (field.getType(), new Integer(value),	                     null, new Integer(field.getMaximumValue()));	            }	        }	        // check values in specific range, catching really odd cases like 30th Feb	        for (int i = 0; i < size; i++) {	            int value = values[i];	            DateTimeField field = partial.getField(i);	            if (value < field.getMinimumValue(partial, values)) {	                throw new IllegalFieldValueException	                    (field.getType(), new Integer(value),	                     new Integer(field.getMinimumValue(partial, values)), null);	            }	            if (value > field.getMaximumValue(partial, values)) {	                throw new IllegalFieldValueException	                    (field.getType(), new Integer(value),	                     null, new Integer(field.getMaximumValue(partial, values)));	            }	        }	    }	
/**	     * Gets the values of a partial from an instant.	     *	     * @param partial  the partial instant to use	     * @param instant  the instant to query	     * @return the values of the partial extracted from the instant	     */	    public int[] get(ReadablePartial partial, long instant) {	        int size = partial.size();	        int[] values = new int[size];	        for (int i = 0; i < size; i++) {	            values[i] = partial.getFieldType(i).getField(this).get(instant);	        }	        return values;	    }	
/**	     * Sets the partial into the instant.	     *	     * @param partial  the partial instant to use	     * @param instant  the instant to update	     * @return the updated instant	     */	    public long set(ReadablePartial partial, long instant) {	        for (int i = 0, isize = partial.size(); i < isize; i++) {	            instant = partial.getFieldType(i).getField(this).set(instant, partial.getValue(i));	        }	        return instant;	    }	
/**	     * Gets the values of a period from an interval.	     *	     * @param period  the period instant to use	     * @param startInstant  the start instant of an interval to query	     * @param endInstant  the start instant of an interval to query	     * @return the values of the period extracted from the interval	     */	    public int[] get(ReadablePeriod period, long startInstant, long endInstant) {	        int size = period.size();	        int[] values = new int[size];	        if (startInstant != endInstant) {	            for (int i = 0; i < size; i++) {	                DurationField field = period.getFieldType(i).getField(this);	                int value = field.getDifference(endInstant, startInstant);	                startInstant = field.add(startInstant, value);	                values[i] = value;	            }	        }	        return values;	    }	
/**	     * Gets the values of a period from an interval.	     *	     * @param period  the period instant to use	     * @param duration  the duration to query	     * @return the values of the period extracted from the duration	     */	    public int[] get(ReadablePeriod period, long duration) {	        int size = period.size();	        int[] values = new int[size];	        if (duration != 0) {	            long current = 0;	            for (int i = 0; i < size; i++) {	                DurationField field = period.getFieldType(i).getField(this);	                if (field.isPrecise()) {	                    int value = field.getDifference(duration, current);	                    current = field.add(current, value);	                    values[i] = value;	                }	            }	        }	        return values;	    }	
/**	     * Adds the period to the instant, specifying the number of times to add.	     *	     * @param period  the period to add, null means add nothing	     * @param instant  the instant to add to	     * @param scalar  the number of times to add	     * @return the updated instant	     */	    public long add(ReadablePeriod period, long instant, int scalar) {	        if (scalar != 0 && period != null) {	            for (int i = 0, isize = period.size(); i < isize; i++) {	                long value = period.getValue(i); // use long to allow for multiplication (fits OK)	                if (value != 0) {	                    instant = period.getFieldType(i).getField(this).add(instant, value * scalar);	                }	            }	        }	        return instant;	    }	
/**	     * Adds the duration to the instant, specifying the number of times to add.	     *	     * @param instant  the instant to add to	     * @param duration  the duration to add	     * @param scalar  the number of times to add	     * @return the updated instant	     */	    public long add(long instant, long duration, int scalar) {	        if (duration == 0 || scalar == 0) {	            return instant;	        }	        long add = FieldUtils.safeMultiply(duration, scalar);	        return FieldUtils.safeAdd(instant, add);	    }	
/**	     * Get the millis duration field for this chronology.	     * 	     * @return DurationField or UnsupportedDurationField if unsupported	     */	    public DurationField millis() {	        return UnsupportedDurationField.getInstance(DurationFieldType.millis());	    }	
/**	     * Get the millis of second field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField millisOfSecond() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.millisOfSecond(), millis());	    }	
/**	     * Get the millis of day field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField millisOfDay() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.millisOfDay(), millis());	    }	
/**	     * Get the seconds duration field for this chronology.	     * 	     * @return DurationField or UnsupportedDurationField if unsupported	     */	    public DurationField seconds() {	        return UnsupportedDurationField.getInstance(DurationFieldType.seconds());	    }	
/**	     * Get the second of minute field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField secondOfMinute() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.secondOfMinute(), seconds());	    }	
/**	     * Get the second of day field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField secondOfDay() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.secondOfDay(), seconds());	    }	
/**	     * Get the minutes duration field for this chronology.	     * 	     * @return DurationField or UnsupportedDurationField if unsupported	     */	    public DurationField minutes() {	        return UnsupportedDurationField.getInstance(DurationFieldType.minutes());	    }	
/**	     * Get the minute of hour field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField minuteOfHour() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.minuteOfHour(), minutes());	    }	
/**	     * Get the minute of day field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField minuteOfDay() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.minuteOfDay(), minutes());	    }	
/**	     * Get the hours duration field for this chronology.	     * 	     * @return DurationField or UnsupportedDurationField if unsupported	     */	    public DurationField hours() {	        return UnsupportedDurationField.getInstance(DurationFieldType.hours());	    }	
/**	     * Get the hour of day (0-23) field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField hourOfDay() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.hourOfDay(), hours());	    }	
/**	     * Get the hour of day (offset to 1-24) field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField clockhourOfDay() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.clockhourOfDay(), hours());	    }	
/**	     * Get the halfdays duration field for this chronology.	     * 	     * @return DurationField or UnsupportedDurationField if unsupported	     */	    public DurationField halfdays() {	        return UnsupportedDurationField.getInstance(DurationFieldType.halfdays());	    }	
/**	     * Get the hour of am/pm (0-11) field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField hourOfHalfday() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.hourOfHalfday(), hours());	    }	
/**	     * Get the hour of am/pm (offset to 1-12) field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField clockhourOfHalfday() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.clockhourOfHalfday(), hours());	    }	
/**	     * Get the AM(0) PM(1) field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField halfdayOfDay() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.halfdayOfDay(), halfdays());	    }	
/**	     * Get the days duration field for this chronology.	     * 	     * @return DurationField or UnsupportedDurationField if unsupported	     */	    public DurationField days() {	        return UnsupportedDurationField.getInstance(DurationFieldType.days());	    }	
/**	     * Get the day of week field for this chronology.	     *	     * <p>DayOfWeek values are defined in	     * {@link org.joda.time.DateTimeConstants DateTimeConstants}.	     * They use the ISO definitions, where 1 is Monday and 7 is Sunday.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField dayOfWeek() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.dayOfWeek(), days());	    }	
/**	     * Get the day of month field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField dayOfMonth() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.dayOfMonth(), days());	    }	
/**	     * Get the day of year field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField dayOfYear() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.dayOfYear(), days());	    }	
/**	     * Get the weeks duration field for this chronology.	     * 	     * @return DurationField or UnsupportedDurationField if unsupported	     */	    public DurationField weeks() {	        return UnsupportedDurationField.getInstance(DurationFieldType.weeks());	    }	
/**	     * Get the week of a week based year field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField weekOfWeekyear() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.weekOfWeekyear(), weeks());	    }	
/**	     * Get the weekyears duration field for this chronology.	     * 	     * @return DurationField or UnsupportedDurationField if unsupported	     */	    public DurationField weekyears() {	        return UnsupportedDurationField.getInstance(DurationFieldType.weekyears());	    }	
/**	     * Get the year of a week based year field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField weekyear() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.weekyear(), weekyears());	    }	
/**	     * Get the year of a week based year in a century field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField weekyearOfCentury() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.weekyearOfCentury(), weekyears());	    }	
/**	     * Get the months duration field for this chronology.	     * 	     * @return DurationField or UnsupportedDurationField if unsupported	     */	    public DurationField months() {	        return UnsupportedDurationField.getInstance(DurationFieldType.months());	    }	
/**	     * Get the month of year field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField monthOfYear() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.monthOfYear(), months());	    }	
/**	     * Get the years duration field for this chronology.	     * 	     * @return DurationField or UnsupportedDurationField if unsupported	     */	    public DurationField years() {	        return UnsupportedDurationField.getInstance(DurationFieldType.years());	    }	
/**	     * Get the year field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField year() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.year(), years());	    }	
/**	     * Get the year of era field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField yearOfEra() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.yearOfEra(), years());	    }	
/**	     * Get the year of century field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField yearOfCentury() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.yearOfCentury(), years());	    }	
/**	     * Get the centuries duration field for this chronology.	     * 	     * @return DurationField or UnsupportedDurationField if unsupported	     */	    public DurationField centuries() {	        return UnsupportedDurationField.getInstance(DurationFieldType.centuries());	    }	
/**	     * Get the century of era field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField centuryOfEra() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.centuryOfEra(), centuries());	    }	
/**	     * Get the eras duration field for this chronology.	     * 	     * @return DurationField or UnsupportedDurationField if unsupported	     */	    public DurationField eras() {	        return UnsupportedDurationField.getInstance(DurationFieldType.eras());	    }	
/**	     * Get the era field for this chronology.	     * 	     * @return DateTimeField or UnsupportedDateTimeField if unsupported	     */	    public DateTimeField era() {	        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.era(), eras());	    }	
/**	     * Convert a datetime from one chronology to another.	     */	    private static long convertByYear(long instant, Chronology from, Chronology to) {	        return to.getDateTimeMillis	            (from.year().get(instant),	             from.monthOfYear().get(instant),	             from.dayOfMonth().get(instant),	             from.millisOfDay().get(instant));	    }	
/**	     * Convert a datetime from one chronology to another.	     */	    private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {	        long newInstant;	        newInstant = to.weekyear().set(0, from.weekyear().get(instant));	        newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));	        newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));	        newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));	        return newInstant;	    }	
/**	     * Factory method returns instances of the default GJ cutover	     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)	     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by	     * October 15, 1582 (Gregorian).	     *	     * <p>The first day of the week is designated to be	     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},	     * and the minimum days in the first week of the year is 4.	     *	     * <p>The time zone of the returned instance is UTC.	     */	    public static GJChronology getInstanceUTC() {	        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);	    }	
/**	     * Factory method returns instances of the default GJ cutover	     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)	     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by	     * October 15, 1582 (Gregorian).	     *	     * <p>The first day of the week is designated to be	     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},	     * and the minimum days in the first week of the year is 4.	     *	     * <p>The returned chronology is in the default time zone.	     */	    public static GJChronology getInstance() {	        return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);	    }	
/**	     * Factory method returns instances of the GJ cutover chronology. This uses	     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this	     * value, October 4, 1582 (Julian) is followed by October 15, 1582	     * (Gregorian).	     *	     * <p>The first day of the week is designated to be	     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},	     * and the minimum days in the first week of the year is 4.	     *	     * @param zone  the time zone to use, null is default	     */	    public static GJChronology getInstance(DateTimeZone zone) {	        return getInstance(zone, DEFAULT_CUTOVER, 4);	    }	
/**	     * Factory method returns instances of the GJ cutover chronology. Any	     * cutover date may be specified.	     *	     * <p>The first day of the week is designated to be	     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},	     * and the minimum days in the first week of the year is 4.	     *	     * @param zone  the time zone to use, null is default	     * @param gregorianCutover  the cutover to use, null means default	     */	    public static GJChronology getInstance(	            DateTimeZone zone,	            ReadableInstant gregorianCutover) {	        	        return getInstance(zone, gregorianCutover, 4);	    }	
/**	     * Factory method returns instances of the GJ cutover chronology. Any	     * cutover date may be specified.	     *	     * @param zone  the time zone to use, null is default	     * @param gregorianCutover  the cutover to use, null means default	     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4	     */	    public static synchronized GJChronology getInstance(	            DateTimeZone zone,	            ReadableInstant gregorianCutover,	            int minDaysInFirstWeek) {	        	        zone = DateTimeUtils.getZone(zone);	        Instant cutoverInstant;	        if (gregorianCutover == null) {	            cutoverInstant = DEFAULT_CUTOVER;	        } else {	            cutoverInstant = gregorianCutover.toInstant();	        }		        GJChronology chrono;		        ArrayList<GJChronology> chronos = cCache.get(zone);	        if (chronos == null) {	            chronos = new ArrayList<GJChronology>(2);	            cCache.put(zone, chronos);	        } else {	            for (int i=chronos.size(); --i>=0; ) {	                chrono = chronos.get(i);	                if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&	                    cutoverInstant.equals(chrono.getGregorianCutover())) {	                    	                    return chrono;	                }	            }	        }		        if (zone == DateTimeZone.UTC) {	            chrono = new GJChronology	                (JulianChronology.getInstance(zone, minDaysInFirstWeek),	                 GregorianChronology.getInstance(zone, minDaysInFirstWeek),	                 cutoverInstant);	        } else {	            chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);	            chrono = new GJChronology	                (ZonedChronology.getInstance(chrono, zone),	                 chrono.iJulianChronology,	                 chrono.iGregorianChronology,	                 chrono.iCutoverInstant);	        }		        chronos.add(chrono);		        return chrono;	    }	
/**	     * Factory method returns instances of the GJ cutover chronology. Any	     * cutover date may be specified.	     *	     * @param zone  the time zone to use, null is default	     * @param gregorianCutover  the cutover to use	     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4	     */	    public static GJChronology getInstance(	            DateTimeZone zone,	            long gregorianCutover,	            int minDaysInFirstWeek) {	        	        Instant cutoverInstant;	        if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {	            cutoverInstant = null;	        } else {	            cutoverInstant = new Instant(gregorianCutover);	        }	        return getInstance(zone, cutoverInstant, minDaysInFirstWeek);	    }	
/**	     * @param julian chronology used before the cutover instant	     * @param gregorian chronology used at and after the cutover instant	     * @param cutoverInstant instant when the gregorian chronology began	     */	    private GJChronology(JulianChronology julian,	                         GregorianChronology gregorian,	                         Instant cutoverInstant) {	        super(null, new Object[] {julian, gregorian, cutoverInstant});	    }	
/**	     * Called when applying a time zone.	     */	    private GJChronology(Chronology base,	                         JulianChronology julian,	                         GregorianChronology gregorian,	                         Instant cutoverInstant) {	        super(base, new Object[] {julian, gregorian, cutoverInstant});	    }	
/**	     * Serialization singleton	     */	    private Object readResolve() {	        return getInstance(getZone(), iCutoverInstant, getMinimumDaysInFirstWeek());	    }	
public DateTimeZone getZone() {	        Chronology base;	        if ((base = getBase()) != null) {	            return base.getZone();	        }	        return DateTimeZone.UTC;	    }	
/**	     * Gets the Chronology in the UTC time zone.	     * 	     * @return the chronology in UTC	     */	    public Chronology withUTC() {	        return withZone(DateTimeZone.UTC);	    }	
/**	     * Gets the Chronology in a specific time zone.	     * 	     * @param zone  the zone to get the chronology in, null is default	     * @return the chronology	     */	    public Chronology withZone(DateTimeZone zone) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        if (zone == getZone()) {	            return this;	        }	        return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());	    }	
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,	                                  int millisOfDay)	        throws IllegalArgumentException	    {	        Chronology base;	        if ((base = getBase()) != null) {	            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);	        }		        // Assume date is Gregorian.	        long instant = iGregorianChronology.getDateTimeMillis	            (year, monthOfYear, dayOfMonth, millisOfDay);	        if (instant < iCutoverMillis) {	            // Maybe it's Julian.	            instant = iJulianChronology.getDateTimeMillis	                (year, monthOfYear, dayOfMonth, millisOfDay);	            if (instant >= iCutoverMillis) {	                // Okay, it's in the illegal cutover gap.	                throw new IllegalArgumentException("Specified date does not exist");	            }	        }	        return instant;	    }	
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,	                                  int hourOfDay, int minuteOfHour,	                                  int secondOfMinute, int millisOfSecond)	        throws IllegalArgumentException	    {	        Chronology base;	        if ((base = getBase()) != null) {	            return base.getDateTimeMillis	                (year, monthOfYear, dayOfMonth,	                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	        }		        // Assume date is Gregorian.	        long instant = iGregorianChronology.getDateTimeMillis	            (year, monthOfYear, dayOfMonth,	             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	        if (instant < iCutoverMillis) {	            // Maybe it's Julian.	            instant = iJulianChronology.getDateTimeMillis	                (year, monthOfYear, dayOfMonth,	                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);	            if (instant >= iCutoverMillis) {	                // Okay, it's in the illegal cutover gap.	                throw new IllegalArgumentException("Specified date does not exist");	            }	        }	        return instant;	    }	
/**	     * Gets the cutover instant between Gregorian and Julian chronologies.	     * @return the cutover instant	     */	    public Instant getGregorianCutover() {	        return iCutoverInstant;	    }	
/**	     * Gets the minimum days needed for a week to be the first week in a year.	     * 	     * @return the minimum days	     */	    public int getMinimumDaysInFirstWeek() {	        return iGregorianChronology.getMinimumDaysInFirstWeek();	    }	
/**	     * Checks if this chronology instance equals another.	     * 	     * @param obj  the object to compare to	     * @return true if equal	     * @since 1.6	     */	    public boolean equals(Object obj) {	        return super.equals(obj);	    }	
/**	     * A suitable hash code for the chronology.	     * 	     * @return the hash code	     * @since 1.6	     */	    public int hashCode() {	        return "GJ".hashCode() * 11 + iJulianChronology.hashCode() +	            iGregorianChronology.hashCode() + iCutoverInstant.hashCode();	    }	
/**	     * Gets a debugging toString.	     * 	     * @return a debugging string	     */	    public String toString() {	        StringBuffer sb = new StringBuffer(60);	        sb.append("GJChronology");	        sb.append('[');	        sb.append(getZone().getID());	        	        if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) {	            sb.append(",cutover=");	            DateTimeFormatter printer;	            if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {	                printer = ISODateTimeFormat.date();	            } else {	                printer = ISODateTimeFormat.dateTime();	            }	            printer.withChronology(withUTC()).printTo(sb, iCutoverMillis);	        }	        	        if (getMinimumDaysInFirstWeek() != 4) {	            sb.append(",mdfw=");	            sb.append(getMinimumDaysInFirstWeek());	        }	        sb.append(']');	        	        return sb.toString();	    }	
protected void assemble(Fields fields) {	        Object[] params = (Object[])getParam();		        JulianChronology julian = (JulianChronology)params[0];	        GregorianChronology gregorian = (GregorianChronology)params[1];	        Instant cutoverInstant = (Instant)params[2];	        iCutoverMillis = cutoverInstant.getMillis();		        iJulianChronology = julian;	        iGregorianChronology = gregorian;	        iCutoverInstant = cutoverInstant;		        if (getBase() != null) {	            return;	        }		        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {	            throw new IllegalArgumentException();	        }		        // Compute difference between the chronologies at the cutover instant	        iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);		        // Begin field definitions.		        // First just copy all the Gregorian fields and then override those	        // that need special attention.	        fields.copyFieldsFrom(gregorian);	        	        // Assuming cutover is at midnight, all time of day fields can be	        // gregorian since they are unaffected by cutover.		        // Verify assumption.	        if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {	            // Cutover is sometime in the day, so cutover fields are required	            // for time of day.		            fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);	            fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);	            fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);	            fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);	            fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);	            fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);	            fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);	            fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);	            fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);	            fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),	                                                         fields.clockhourOfHalfday, iCutoverMillis);	            fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);	        }		        // These fields just require basic cutover support.	        {	            fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);	        }		        // DayOfYear and weekOfWeekyear require special handling since cutover	        // year has fewer days and weeks. Extend the cutover to the start of	        // the next year or weekyear. This keeps the sequence unbroken during	        // the cutover year.		        {	            long cutover = gregorian.year().roundCeiling(iCutoverMillis);	            fields.dayOfYear = new CutoverField(	                julian.dayOfYear(), fields.dayOfYear, cutover);	        }		        {	            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);	            fields.weekOfWeekyear = new CutoverField(	                julian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);	        }		        // These fields are special because they have imprecise durations. The	        // family of addition methods need special attention. Override affected	        // duration fields as well.	        {	            fields.year = new ImpreciseCutoverField(	                julian.year(), fields.year, iCutoverMillis);	            fields.years = fields.year.getDurationField();	            fields.yearOfEra = new ImpreciseCutoverField(	                julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);	            fields.yearOfCentury = new ImpreciseCutoverField(	                julian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);	            	            fields.centuryOfEra = new ImpreciseCutoverField(	                julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);	            fields.centuries = fields.centuryOfEra.getDurationField();	            	            fields.monthOfYear = new ImpreciseCutoverField(	                julian.monthOfYear(), fields.monthOfYear, iCutoverMillis);	            fields.months = fields.monthOfYear.getDurationField();	            	            fields.weekyear = new ImpreciseCutoverField(	                julian.weekyear(), fields.weekyear, null, iCutoverMillis, true);	            fields.weekyearOfCentury = new ImpreciseCutoverField(	                julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);	            fields.weekyears = fields.weekyear.getDurationField();	        }		        // These fields require basic cutover support, except they must link to	        // imprecise durations.	        {	            CutoverField cf = new CutoverField	                (julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);	            cf.iRangeDurationField = fields.months;	            fields.dayOfMonth = cf;	        }	    }	
long julianToGregorianByYear(long instant) {	        return convertByYear(instant, iJulianChronology, iGregorianChronology);	    }	
long gregorianToJulianByYear(long instant) {	        return convertByYear(instant, iGregorianChronology, iJulianChronology);	    }	
long julianToGregorianByWeekyear(long instant) {	        return convertByWeekyear(instant, iJulianChronology, iGregorianChronology);	    }	
long gregorianToJulianByWeekyear(long instant) {	        return convertByWeekyear(instant, iGregorianChronology, iJulianChronology);	    }	
/**	         * @param julianField field from the chronology used before the cutover instant	         * @param gregorianField field from the chronology used at and after the cutover	         * @param cutoverMillis  the millis of the cutover	         */	        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {	            this(julianField, gregorianField, cutoverMillis, false);	        }	
/**	         * @param julianField field from the chronology used before the cutover instant	         * @param gregorianField field from the chronology used at and after the cutover	         * @param cutoverMillis  the millis of the cutover	         * @param convertByWeekyear	         */	        CutoverField(DateTimeField julianField, DateTimeField gregorianField,	                     long cutoverMillis, boolean convertByWeekyear) {	            super(gregorianField.getType());	            iJulianField = julianField;	            iGregorianField = gregorianField;	            iCutover = cutoverMillis;	            iConvertByWeekyear = convertByWeekyear;	            // Although average length of Julian and Gregorian years differ,	            // use the Gregorian duration field because it is more accurate.	            iDurationField = gregorianField.getDurationField();		            DurationField rangeField = gregorianField.getRangeDurationField();	            if (rangeField == null) {	                rangeField = julianField.getRangeDurationField();	            }	            iRangeDurationField = rangeField;	        }	
public boolean isLenient() {	            return false;	        }	
public int get(long instant) {	            if (instant >= iCutover) {	                return iGregorianField.get(instant);	            } else {	                return iJulianField.get(instant);	            }	        }	
public String getAsText(long instant, Locale locale) {	            if (instant >= iCutover) {	                return iGregorianField.getAsText(instant, locale);	            } else {	                return iJulianField.getAsText(instant, locale);	            }	        }	
public String getAsText(int fieldValue, Locale locale) {	            return iGregorianField.getAsText(fieldValue, locale);	        }	
public String getAsShortText(long instant, Locale locale) {	            if (instant >= iCutover) {	                return iGregorianField.getAsShortText(instant, locale);	            } else {	                return iJulianField.getAsShortText(instant, locale);	            }	        }	
public String getAsShortText(int fieldValue, Locale locale) {	            return iGregorianField.getAsShortText(fieldValue, locale);	        }	
public long add(long instant, int value) {	            return iGregorianField.add(instant, value);	        }	
public long add(long instant, long value) {	            return iGregorianField.add(instant, value);	        }	
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {	            // overridden as superclass algorithm can't handle	            // 2004-02-29 + 48 months -> 2008-02-29 type dates	            if (valueToAdd == 0) {	                return values;	            }	            if (DateTimeUtils.isContiguous(partial)) {	                long instant = 0L;	                for (int i = 0, isize = partial.size(); i < isize; i++) {	                    instant = partial.getFieldType(i).getField(GJChronology.this).set(instant, values[i]);	                }	                instant = add(instant, valueToAdd);	                return GJChronology.this.get(partial, instant);	            } else {	                return super.add(partial, fieldIndex, values, valueToAdd);	            }	        }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	            return iGregorianField.getDifference(minuendInstant, subtrahendInstant);	        }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	            return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);	        }	
public long set(long instant, int value) {	            if (instant >= iCutover) {	                instant = iGregorianField.set(instant, value);	                if (instant < iCutover) {	                    // Only adjust if gap fully crossed.	                    if (instant + iGapDuration < iCutover) {	                        instant = gregorianToJulian(instant);	                    }	                    // Verify that new value stuck.	                    if (get(instant) != value) {	                        throw new IllegalFieldValueException	                            (iGregorianField.getType(), new Integer(value), null, null);	                    }	                }	            } else {	                instant = iJulianField.set(instant, value);	                if (instant >= iCutover) {	                    // Only adjust if gap fully crossed.	                    if (instant - iGapDuration >= iCutover) {	                        instant = julianToGregorian(instant);	                    }	                    // Verify that new value stuck.	                    if (get(instant) != value) {	                       throw new IllegalFieldValueException	                            (iJulianField.getType(), new Integer(value), null, null);	                    }	                }	            }	            return instant;	        }	
public long set(long instant, String text, Locale locale) {	            if (instant >= iCutover) {	                instant = iGregorianField.set(instant, text, locale);	                if (instant < iCutover) {	                    // Only adjust if gap fully crossed.	                    if (instant + iGapDuration < iCutover) {	                        instant = gregorianToJulian(instant);	                    }	                    // Cannot verify that new value stuck because set may be lenient.	                }	            } else {	                instant = iJulianField.set(instant, text, locale);	                if (instant >= iCutover) {	                    // Only adjust if gap fully crossed.	                    if (instant - iGapDuration >= iCutover) {	                        instant = julianToGregorian(instant);	                    }	                    // Cannot verify that new value stuck because set may be lenient.	                }	            }	            return instant;	        }	
public DurationField getDurationField() {	            return iDurationField;	        }	
public DurationField getRangeDurationField() {	            return iRangeDurationField;	        }	
public boolean isLeap(long instant) {	            if (instant >= iCutover) {	                return iGregorianField.isLeap(instant);	            } else {	                return iJulianField.isLeap(instant);	            }	        }	
public int getLeapAmount(long instant) {	            if (instant >= iCutover) {	                return iGregorianField.getLeapAmount(instant);	            } else {	                return iJulianField.getLeapAmount(instant);	            }	        }	
public DurationField getLeapDurationField() {	            return iGregorianField.getLeapDurationField();	        }	
public int getMinimumValue() {	            // For all precise fields, the Julian and Gregorian limits are	            // identical. Choose Julian to tighten up the year limits.	            return iJulianField.getMinimumValue();	        }	
public int getMinimumValue(ReadablePartial partial) {	            return iJulianField.getMinimumValue(partial);	        }	
public int getMinimumValue(ReadablePartial partial, int[] values) {	            return iJulianField.getMinimumValue(partial, values);	        }	
public int getMinimumValue(long instant) {	            if (instant < iCutover) {	                return iJulianField.getMinimumValue(instant);	            }		            int min = iGregorianField.getMinimumValue(instant);		            // Because the cutover may reduce the length of this field, verify	            // the minimum by setting it.	            instant = iGregorianField.set(instant, min);	            if (instant < iCutover) {	                min = iGregorianField.get(iCutover);	            }		            return min;	        }	
public int getMaximumValue() {	            // For all precise fields, the Julian and Gregorian limits are	            // identical.	            return iGregorianField.getMaximumValue();	        }	
public int getMaximumValue(long instant) {	            if (instant >= iCutover) {	                return iGregorianField.getMaximumValue(instant);	            }		            int max = iJulianField.getMaximumValue(instant);		            // Because the cutover may reduce the length of this field, verify	            // the maximum by setting it.	            instant = iJulianField.set(instant, max);	            if (instant >= iCutover) {	                max = iJulianField.get(iJulianField.add(iCutover, -1));	            }		            return max;	        }	
public int getMaximumValue(ReadablePartial partial) {	            long instant = GJChronology.getInstanceUTC().set(partial, 0L);	            return getMaximumValue(instant);	        }	
public int getMaximumValue(ReadablePartial partial, int[] values) {	            Chronology chrono = GJChronology.getInstanceUTC();	            long instant = 0L;	            for (int i = 0, isize = partial.size(); i < isize; i++) {	                DateTimeField field = partial.getFieldType(i).getField(chrono);	                if (values[i] <= field.getMaximumValue(instant)) {	                    instant = field.set(instant, values[i]);	                }	            }	            return getMaximumValue(instant);	        }	
public long roundFloor(long instant) {	            if (instant >= iCutover) {	                instant = iGregorianField.roundFloor(instant);	                if (instant < iCutover) {	                    // Only adjust if gap fully crossed.	                    if (instant + iGapDuration < iCutover) {	                        instant = gregorianToJulian(instant);	                    }	                }	            } else {	                instant = iJulianField.roundFloor(instant);	            }	            return instant;	        }	
public long roundCeiling(long instant) {	            if (instant >= iCutover) {	                instant = iGregorianField.roundCeiling(instant);	            } else {	                instant = iJulianField.roundCeiling(instant);	                if (instant >= iCutover) {	                    // Only adjust if gap fully crossed.	                    if (instant - iGapDuration >= iCutover) {	                        instant = julianToGregorian(instant);	                    }	                }	            }	            return instant;	        }	
public int getMaximumTextLength(Locale locale) {	            return Math.max(iJulianField.getMaximumTextLength(locale),	                            iGregorianField.getMaximumTextLength(locale));	        }	
public int getMaximumShortTextLength(Locale locale) {	            return Math.max(iJulianField.getMaximumShortTextLength(locale),	                            iGregorianField.getMaximumShortTextLength(locale));	        }	
protected long julianToGregorian(long instant) {	            if (iConvertByWeekyear) {	                return julianToGregorianByWeekyear(instant);	            } else {	                return julianToGregorianByYear(instant);	            }	        }	
protected long gregorianToJulian(long instant) {	            if (iConvertByWeekyear) {	                return gregorianToJulianByWeekyear(instant);	            } else {	                return gregorianToJulianByYear(instant);	            }	        }	
/**	         * Creates a duration field that links back to this.	         */	        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {	            this(julianField, gregorianField, null, cutoverMillis, false);	        }	
/**	         * Uses a shared duration field rather than creating a new one.	         *	         * @param durationField shared duration field	         */	        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,	                              DurationField durationField, long cutoverMillis)	        {	            this(julianField, gregorianField, durationField, cutoverMillis, false);	        }	
/**	         * Uses a shared duration field rather than creating a new one.	         *	         * @param durationField shared duration field	         */	        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,	                              DurationField durationField,	                              long cutoverMillis, boolean convertByWeekyear)	        {	            super(julianField, gregorianField, cutoverMillis, convertByWeekyear);	            if (durationField == null) {	                durationField = new LinkedDurationField(iDurationField, this);	            }	            iDurationField = durationField;	        }	
public long add(long instant, int value) {	            if (instant >= iCutover) {	                instant = iGregorianField.add(instant, value);	                if (instant < iCutover) {	                    // Only adjust if gap fully crossed.	                    if (instant + iGapDuration < iCutover) {	                        instant = gregorianToJulian(instant);	                    }	                }	            } else {	                instant = iJulianField.add(instant, value);	                if (instant >= iCutover) {	                    // Only adjust if gap fully crossed.	                    if (instant - iGapDuration >= iCutover) {	                        instant = julianToGregorian(instant);	                    }	                }	            }	            return instant;	        }	
public long add(long instant, long value) {	            if (instant >= iCutover) {	                instant = iGregorianField.add(instant, value);	                if (instant < iCutover) {	                    // Only adjust if gap fully crossed.	                    if (instant + iGapDuration < iCutover) {	                        instant = gregorianToJulian(instant);	                    }	                }	            } else {	                instant = iJulianField.add(instant, value);	                if (instant >= iCutover) {	                    // Only adjust if gap fully crossed.	                    if (instant - iGapDuration >= iCutover) {	                        instant = julianToGregorian(instant);	                    }	                }	            }	            return instant;	        }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	            if (minuendInstant >= iCutover) {	                if (subtrahendInstant >= iCutover) {	                    return iGregorianField.getDifference(minuendInstant, subtrahendInstant);	                }	                // Remember, the add is being reversed. Since subtrahend is	                // Julian, convert minuend to Julian to match.	                minuendInstant = gregorianToJulian(minuendInstant);	                return iJulianField.getDifference(minuendInstant, subtrahendInstant);	            } else {	                if (subtrahendInstant < iCutover) {	                    return iJulianField.getDifference(minuendInstant, subtrahendInstant);	                }	                // Remember, the add is being reversed. Since subtrahend is	                // Gregorian, convert minuend to Gregorian to match.	                minuendInstant = julianToGregorian(minuendInstant);	                return iGregorianField.getDifference(minuendInstant, subtrahendInstant);	            }	        }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	            if (minuendInstant >= iCutover) {	                if (subtrahendInstant >= iCutover) {	                    return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);	                }	                // Remember, the add is being reversed. Since subtrahend is	                // Julian, convert minuend to Julian to match.	                minuendInstant = gregorianToJulian(minuendInstant);	                return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);	            } else {	                if (subtrahendInstant < iCutover) {	                    return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);	                }	                // Remember, the add is being reversed. Since subtrahend is	                // Gregorian, convert minuend to Gregorian to match.	                minuendInstant = julianToGregorian(minuendInstant);	                return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);	            }	        }	
public int getMinimumValue(long instant) {	            if (instant >= iCutover) {	                return iGregorianField.getMinimumValue(instant);	            } else {	                return iJulianField.getMinimumValue(instant);	            }	        }	
public int getMaximumValue(long instant) {	            if (instant >= iCutover) {	                return iGregorianField.getMaximumValue(instant);	            } else {	                return iJulianField.getMaximumValue(instant);	            }	        }	
LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {	            super(durationField, durationField.getType());	            iField = dateTimeField;	        }	
public long add(long instant, int value) {	            return iField.add(instant, value);	        }	
public long add(long instant, long value) {	            return iField.add(instant, value);	        }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	            return iField.getDifference(minuendInstant, subtrahendInstant);	        }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	            return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);	        }	
/**	     * Gets an instance of the GregorianChronology.	     * The time zone of the returned instance is UTC.	     * 	     * @return a singleton UTC instance of the chronology	     */	    public static GregorianChronology getInstanceUTC() {	        return INSTANCE_UTC;	    }	
/**	     * Gets an instance of the GregorianChronology in the default time zone.	     * 	     * @return a chronology in the default time zone	     */	    public static GregorianChronology getInstance() {	        return getInstance(DateTimeZone.getDefault(), 4);	    }	
/**	     * Gets an instance of the GregorianChronology in the given time zone.	     * 	     * @param zone  the time zone to get the chronology in, null is default	     * @return a chronology in the specified time zone	     */	    public static GregorianChronology getInstance(DateTimeZone zone) {	        return getInstance(zone, 4);	    }	
/**	     * Gets an instance of the GregorianChronology in the given time zone.	     * 	     * @param zone  the time zone to get the chronology in, null is default	     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4	     * @return a chronology in the specified time zone	     */	    public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        GregorianChronology chrono;	        synchronized (cCache) {	            GregorianChronology[] chronos = cCache.get(zone);	            if (chronos == null) {	                chronos = new GregorianChronology[7];	                cCache.put(zone, chronos);	            }	            try {	                chrono = chronos[minDaysInFirstWeek - 1];	            } catch (ArrayIndexOutOfBoundsException e) {	                throw new IllegalArgumentException	                    ("Invalid min days in first week: " + minDaysInFirstWeek);	            }	            if (chrono == null) {	                if (zone == DateTimeZone.UTC) {	                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);	                } else {	                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);	                    chrono = new GregorianChronology	                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);	                }	                chronos[minDaysInFirstWeek - 1] = chrono;	            }	        }	        return chrono;	    }	
/**	     * Restricted constructor	     */	    private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {	        super(base, param, minDaysInFirstWeek);	    }	
/**	     * Serialization singleton	     */	    private Object readResolve() {	        Chronology base = getBase();	        int minDays = getMinimumDaysInFirstWeek();	        minDays = (minDays == 0 ? 4 : minDays);  // handle rename of BaseGJChronology	        return base == null ?	                getInstance(DateTimeZone.UTC, minDays) :	                    getInstance(base.getZone(), minDays);	    }	
/**	     * Gets the Chronology in the UTC time zone.	     * 	     * @return the chronology in UTC	     */	    public Chronology withUTC() {	        return INSTANCE_UTC;	    }	
/**	     * Gets the Chronology in a specific time zone.	     * 	     * @param zone  the zone to get the chronology in, null is default	     * @return the chronology	     */	    public Chronology withZone(DateTimeZone zone) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        if (zone == getZone()) {	            return this;	        }	        return getInstance(zone);	    }	
protected void assemble(Fields fields) {	        if (getBase() == null) {	            super.assemble(fields);	        }	    }	
boolean isLeapYear(int year) {	        return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);	    }	
long calculateFirstDayOfYearMillis(int year) {	        // Initial value is just temporary.	        int leapYears = year / 100;	        if (year < 0) {	            // Add 3 before shifting right since /4 and >>2 behave differently	            // on negative numbers. When the expression is written as	            // (year / 4) - (year / 100) + (year / 400),	            // it works for both positive and negative values, except this optimization	            // eliminates two divisions.	            leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1;	        } else {	            leapYears = (year >> 2) - leapYears + (leapYears >> 2);	            if (isLeapYear(year)) {	                leapYears--;	            }	        }		        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;	    }	
int getMinYear() {	        return MIN_YEAR;	    }	
int getMaxYear() {	        return MAX_YEAR;	    }	
long getAverageMillisPerYear() {	        return MILLIS_PER_YEAR;	    }	
long getAverageMillisPerYearDividedByTwo() {	        return MILLIS_PER_YEAR / 2;	    }	
long getAverageMillisPerMonth() {	        return MILLIS_PER_MONTH;	    }	
long getApproxMillisAtEpochDividedByTwo() {	        return (1970L * MILLIS_PER_YEAR) / 2;	    }	
/**	     * Restricted constructor	     */	    GJMonthOfYearDateTimeField(BasicChronology chronology) {	        super(chronology, 2);	    }	
public String getAsText(int fieldValue, Locale locale) {	        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(fieldValue);	    }	
public String getAsShortText(int fieldValue, Locale locale) {	        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(fieldValue);	    }	
protected int convertText(String text, Locale locale) {	        return GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text);	    }	
public int getMaximumTextLength(Locale locale) {	        return GJLocaleSymbols.forLocale(locale).getMonthMaxTextLength();	    }	
public int getMaximumShortTextLength(Locale locale) {	        return GJLocaleSymbols.forLocale(locale).getMonthMaxShortTextLength();	    }	
static int adjustYearForSet(int year) {	        if (year <= 0) {	            if (year == 0) {	                throw new IllegalFieldValueException	                    (DateTimeFieldType.year(), new Integer(year), null, null);	            }	            year++;	        }	        return year;	    }	
/**	     * Gets an instance of the JulianChronology.	     * The time zone of the returned instance is UTC.	     * 	     * @return a singleton UTC instance of the chronology	     */	    public static JulianChronology getInstanceUTC() {	        return INSTANCE_UTC;	    }	
/**	     * Gets an instance of the JulianChronology in the default time zone.	     * 	     * @return a chronology in the default time zone	     */	    public static JulianChronology getInstance() {	        return getInstance(DateTimeZone.getDefault(), 4);	    }	
/**	     * Gets an instance of the JulianChronology in the given time zone.	     * 	     * @param zone  the time zone to get the chronology in, null is default	     * @return a chronology in the specified time zone	     */	    public static JulianChronology getInstance(DateTimeZone zone) {	        return getInstance(zone, 4);	    }	
/**	     * Gets an instance of the JulianChronology in the given time zone.	     * 	     * @param zone  the time zone to get the chronology in, null is default	     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4	     * @return a chronology in the specified time zone	     */	    public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        JulianChronology chrono;	        synchronized (cCache) {	            JulianChronology[] chronos = cCache.get(zone);	            if (chronos == null) {	                chronos = new JulianChronology[7];	                cCache.put(zone, chronos);	            }	            try {	                chrono = chronos[minDaysInFirstWeek - 1];	            } catch (ArrayIndexOutOfBoundsException e) {	                throw new IllegalArgumentException	                    ("Invalid min days in first week: " + minDaysInFirstWeek);	            }	            if (chrono == null) {	                if (zone == DateTimeZone.UTC) {	                    chrono = new JulianChronology(null, null, minDaysInFirstWeek);	                } else {	                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);	                    chrono = new JulianChronology	                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);	                }	                chronos[minDaysInFirstWeek - 1] = chrono;	            }	        }	        return chrono;	    }	
/**	     * Restricted constructor	     */	    JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {	        super(base, param, minDaysInFirstWeek);	    }	
/**	     * Serialization singleton	     */	    private Object readResolve() {	        Chronology base = getBase();	        int minDays = getMinimumDaysInFirstWeek();	        minDays = (minDays == 0 ? 4 : minDays);  // handle rename of BaseGJChronology	        return base == null ?	                getInstance(DateTimeZone.UTC, minDays) :	                    getInstance(base.getZone(), minDays);	    }	
/**	     * Gets the Chronology in the UTC time zone.	     * 	     * @return the chronology in UTC	     */	    public Chronology withUTC() {	        return INSTANCE_UTC;	    }	
/**	     * Gets the Chronology in a specific time zone.	     * 	     * @param zone  the zone to get the chronology in, null is default	     * @return the chronology	     */	    public Chronology withZone(DateTimeZone zone) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        if (zone == getZone()) {	            return this;	        }	        return getInstance(zone);	    }	
long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth)	        throws IllegalArgumentException	    {	        return super.getDateMidnightMillis(adjustYearForSet(year), monthOfYear, dayOfMonth);	    }	
boolean isLeapYear(int year) {	        return (year & 3) == 0;	    }	
long calculateFirstDayOfYearMillis(int year) {	        // Java epoch is 1970-01-01 Gregorian which is 1969-12-19 Julian.	        // Calculate relative to the nearest leap year and account for the	        // difference later.		        int relativeYear = year - 1968;	        int leapYears;	        if (relativeYear <= 0) {	            // Add 3 before shifting right since /4 and >>2 behave differently	            // on negative numbers.	            leapYears = (relativeYear + 3) >> 2;	        } else {	            leapYears = relativeYear >> 2;	            // For post 1968 an adjustment is needed as jan1st is before leap day	            if (!isLeapYear(year)) {	                leapYears++;	            }	        }	        	        long millis = (relativeYear * 365L + leapYears) * (long)DateTimeConstants.MILLIS_PER_DAY;		        // Adjust to account for difference between 1968-01-01 and 1969-12-19.		        return millis - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY;	    }	
int getMinYear() {	        return MIN_YEAR;	    }	
int getMaxYear() {	        return MAX_YEAR;	    }	
long getAverageMillisPerYear() {	        return MILLIS_PER_YEAR;	    }	
long getAverageMillisPerYearDividedByTwo() {	        return MILLIS_PER_YEAR / 2;	    }	
long getAverageMillisPerMonth() {	        return MILLIS_PER_MONTH;	    }	
long getApproxMillisAtEpochDividedByTwo() {	        return (1969L * MILLIS_PER_YEAR + 352L * DateTimeConstants.MILLIS_PER_DAY) / 2;	    }	
protected void assemble(Fields fields) {	        if (getBase() == null) {	            super.assemble(fields);	            // Julian chronology has no year zero.	            fields.year = new SkipDateTimeField(this, fields.year);	            fields.weekyear = new SkipDateTimeField(this, fields.weekyear);	        }	    }	
public static GJLocaleSymbols forLocale(Locale locale) {	        if (locale == null) {	            locale = Locale.getDefault();	        }	        int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1);	        GJLocaleSymbols symbols = cFastCache[index];	        if (symbols != null && symbols.iLocale.get() == locale) {	            return symbols;	        }	        synchronized (cCache) {	            symbols = cCache.get(locale);	            if (symbols == null) {	                symbols = new GJLocaleSymbols(locale);	                cCache.put(locale, symbols);	            }	        }	        cFastCache[index] = symbols;	        return symbols;	    }	
private static String[] realignMonths(String[] months) {	        String[] a = new String[13];	        for (int i=1; i<13; i++) {	            a[i] = months[i - 1];	        }	        return a;	    }	
private static String[] realignDaysOfWeek(String[] daysOfWeek) {	        String[] a = new String[8];	        for (int i=1; i<8; i++) {	            a[i] = daysOfWeek[(i < 7) ? i + 1 : 1];	        }	        return a;	    }	
private static void addSymbols(TreeMap<String, Integer> map, String[] symbols, Integer[] integers) {	        for (int i=symbols.length; --i>=0; ) {	            String symbol = symbols[i];	            if (symbol != null) {	                map.put(symbol, integers[i]);	            }	        }	    }	
private static void addNumerals(TreeMap<String, Integer> map, int start, int end, Integer[] integers) {	        for (int i=start; i<=end; i++) {	            map.put(String.valueOf(i).intern(), integers[i]);	        }	    }	
private static int maxLength(String[] a) {	        int max = 0;	        for (int i=a.length; --i>=0; ) {	            String s = a[i];	            if (s != null) {	                int len = s.length();	                if (len > max) {	                    max = len;	                }	            }	        }	        return max;	    }	
/**	     * @param locale must not be null	     */	    private GJLocaleSymbols(Locale locale) {	        iLocale = new WeakReference<Locale>(locale);	        	        DateFormatSymbols dfs = DateTimeUtils.getDateFormatSymbols(locale);	        	        iEras = dfs.getEras();	        iDaysOfWeek = realignDaysOfWeek(dfs.getWeekdays());	        iShortDaysOfWeek = realignDaysOfWeek(dfs.getShortWeekdays());	        iMonths = realignMonths(dfs.getMonths());	        iShortMonths = realignMonths(dfs.getShortMonths());	        iHalfday = dfs.getAmPmStrings();		        Integer[] integers = new Integer[13];	        for (int i=0; i<13; i++) {	            integers[i] = new Integer(i);	        }		        iParseEras = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER);	        addSymbols(iParseEras, iEras, integers);	        if ("en".equals(locale.getLanguage())) {	            // Include support for parsing "BCE" and "CE" if the language is	            // English. At some point Joda-Time will need an independent set of	            // localized symbols and not depend on java.text.DateFormatSymbols.	            iParseEras.put("BCE", integers[0]);	            iParseEras.put("CE", integers[1]);	        }		        iParseDaysOfWeek = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER);	        addSymbols(iParseDaysOfWeek, iDaysOfWeek, integers);	        addSymbols(iParseDaysOfWeek, iShortDaysOfWeek, integers);	        addNumerals(iParseDaysOfWeek, 1, 7, integers);		        iParseMonths = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER);	        addSymbols(iParseMonths, iMonths, integers);	        addSymbols(iParseMonths, iShortMonths, integers);	        addNumerals(iParseMonths, 1, 12, integers);		        iMaxEraLength = maxLength(iEras);	        iMaxDayOfWeekLength = maxLength(iDaysOfWeek);	        iMaxShortDayOfWeekLength = maxLength(iShortDaysOfWeek);	        iMaxMonthLength = maxLength(iMonths);	        iMaxShortMonthLength = maxLength(iShortMonths);	        iMaxHalfdayLength = maxLength(iHalfday);	    }	
public String eraValueToText(int value) {	        return iEras[value];	    }	
public int eraTextToValue(String text) {	        Integer era = iParseEras.get(text);	        if (era != null) {	            return era.intValue();	        }	        throw new IllegalFieldValueException(DateTimeFieldType.era(), text);	    }	
public int getEraMaxTextLength() {	        return iMaxEraLength;	    }	
public String monthOfYearValueToText(int value) {	        return iMonths[value];	    }	
public String monthOfYearValueToShortText(int value) {	        return iShortMonths[value];	    }	
public int monthOfYearTextToValue(String text) {	        Integer month = iParseMonths.get(text);	        if (month != null) {	            return month.intValue();	        }	        throw new IllegalFieldValueException(DateTimeFieldType.monthOfYear(), text);	    }	
public int getMonthMaxTextLength() {	        return iMaxMonthLength;	    }	
public int getMonthMaxShortTextLength() {	        return iMaxShortMonthLength;	    }	
public String dayOfWeekValueToText(int value) {	        return iDaysOfWeek[value];	    }	
public String dayOfWeekValueToShortText(int value) {	        return iShortDaysOfWeek[value];	    }	
public int dayOfWeekTextToValue(String text) {	        Integer day = iParseDaysOfWeek.get(text);	        if (day != null) {	            return day.intValue();	        }	        throw new IllegalFieldValueException(DateTimeFieldType.dayOfWeek(), text);	    }	
public int getDayOfWeekMaxTextLength() {	        return iMaxDayOfWeekLength;	    }	
public int getDayOfWeekMaxShortTextLength() {	        return iMaxShortDayOfWeekLength;	    }	
public String halfdayValueToText(int value) {	        return iHalfday[value];	    }	
public int halfdayTextToValue(String text) {	        String[] halfday = iHalfday;	        for (int i = halfday.length; --i>=0; ) {	            if (halfday[i].equalsIgnoreCase(text)) {	                return i;	            }	        }	        throw new IllegalFieldValueException(DateTimeFieldType.halfdayOfDay(), text);	    }	
public int getHalfdayMaxTextLength() {	        return iMaxHalfdayLength;	    }	
/**	     * Restricted constructor.	     */	    GJDayOfWeekDateTimeField(BasicChronology chronology, DurationField days) {	        super(DateTimeFieldType.dayOfWeek(), days);	        iChronology = chronology;	    }	
/**	     * Get the value of the specified time instant.	     * 	     * @param instant  the time instant in millis to query	     * @return the day of the week extracted from the input	     */	    public int get(long instant) {	        return iChronology.getDayOfWeek(instant);	    }	
/**	     * Get the textual value of the specified time instant.	     * 	     * @param fieldValue  the field value to query	     * @param locale  the locale to use	     * @return the day of the week, such as 'Monday'	     */	    public String getAsText(int fieldValue, Locale locale) {	        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(fieldValue);	    }	
/**	     * Get the abbreviated textual value of the specified time instant.	     * 	     * @param fieldValue  the field value to query	     * @param locale  the locale to use	     * @return the day of the week, such as 'Mon'	     */	    public String getAsShortText(int fieldValue, Locale locale) {	        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(fieldValue);	    }	
/**	     * Convert the specified text and locale into a value.	     * 	     * @param text  the text to convert	     * @param locale  the locale to convert using	     * @return the value extracted from the text	     * @throws IllegalArgumentException if the text is invalid	     */	    protected int convertText(String text, Locale locale) {	        return GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text);	    }	
public DurationField getRangeDurationField() {	        return iChronology.weeks();	    }	
/**	     * Get the minimum value that this field can have.	     * 	     * @return the field's minimum value	     */	    public int getMinimumValue() {	        return DateTimeConstants.MONDAY;	    }	
/**	     * Get the maximum value that this field can have.	     * 	     * @return the field's maximum value	     */	    public int getMaximumValue() {	        return DateTimeConstants.SUNDAY;	    }	
/**	     * Get the maximum length of the text returned by this field.	     * 	     * @param locale  the locale to use	     * @return the maximum textual length	     */	    public int getMaximumTextLength(Locale locale) {	        return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxTextLength();	    }	
/**	     * Get the maximum length of the abbreviated text returned by this field.	     * 	     * @param locale  the locale to use	     * @return the maximum abbreviated textual length	     */	    public int getMaximumShortTextLength(Locale locale) {	        return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxShortTextLength();	    }	
/**	     * Serialization singleton	     */	    private Object readResolve() {	        return iChronology.dayOfWeek();	    }	
/**	     * Gets an instance of the EthiopicChronology.	     * The time zone of the returned instance is UTC.	     * 	     * @return a singleton UTC instance of the chronology	     */	    public static EthiopicChronology getInstanceUTC() {	        return INSTANCE_UTC;	    }	
/**	     * Gets an instance of the EthiopicChronology in the default time zone.	     * 	     * @return a chronology in the default time zone	     */	    public static EthiopicChronology getInstance() {	        return getInstance(DateTimeZone.getDefault(), 4);	    }	
/**	     * Gets an instance of the EthiopicChronology in the given time zone.	     * 	     * @param zone  the time zone to get the chronology in, null is default	     * @return a chronology in the specified time zone	     */	    public static EthiopicChronology getInstance(DateTimeZone zone) {	        return getInstance(zone, 4);	    }	
/**	     * Gets an instance of the EthiopicChronology in the given time zone.	     * 	     * @param zone  the time zone to get the chronology in, null is default	     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4	     * @return a chronology in the specified time zone	     */	    public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        EthiopicChronology chrono;	        synchronized (cCache) {	            EthiopicChronology[] chronos = cCache.get(zone);	            if (chronos == null) {	                chronos = new EthiopicChronology[7];	                cCache.put(zone, chronos);	            }	            try {	                chrono = chronos[minDaysInFirstWeek - 1];	            } catch (ArrayIndexOutOfBoundsException e) {	                throw new IllegalArgumentException	                    ("Invalid min days in first week: " + minDaysInFirstWeek);	            }	            if (chrono == null) {	                if (zone == DateTimeZone.UTC) {	                    // First create without a lower limit.	                    chrono = new EthiopicChronology(null, null, minDaysInFirstWeek);	                    // Impose lower limit and make another EthiopicChronology.	                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);	                    chrono = new EthiopicChronology	                        (LimitChronology.getInstance(chrono, lowerLimit, null),	                         null, minDaysInFirstWeek);	                } else {	                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);	                    chrono = new EthiopicChronology	                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);	                }	                chronos[minDaysInFirstWeek - 1] = chrono;	            }	        }	        return chrono;	    }	
/**	     * Restricted constructor.	     */	    EthiopicChronology(Chronology base, Object param, int minDaysInFirstWeek) {	        super(base, param, minDaysInFirstWeek);	    }	
/**	     * Serialization singleton.	     */	    private Object readResolve() {	        Chronology base = getBase();	        return base == null ?	                getInstance(DateTimeZone.UTC, getMinimumDaysInFirstWeek()) :	                    getInstance(base.getZone(), getMinimumDaysInFirstWeek());	    }	
/**	     * Gets the Chronology in the UTC time zone.	     * 	     * @return the chronology in UTC	     */	    public Chronology withUTC() {	        return INSTANCE_UTC;	    }	
/**	     * Gets the Chronology in a specific time zone.	     * 	     * @param zone  the zone to get the chronology in, null is default	     * @return the chronology	     */	    public Chronology withZone(DateTimeZone zone) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        if (zone == getZone()) {	            return this;	        }	        return getInstance(zone);	    }	
long calculateFirstDayOfYearMillis(int year) {	        // Java epoch is 1970-01-01 Gregorian which is 1962-04-23 Ethiopic.	        // Calculate relative to the nearest leap year and account for the	        // difference later.		        int relativeYear = year - 1963;	        int leapYears;	        if (relativeYear <= 0) {	            // Add 3 before shifting right since /4 and >>2 behave differently	            // on negative numbers.	            leapYears = (relativeYear + 3) >> 2;	        } else {	            leapYears = relativeYear >> 2;	            // For post 1963 an adjustment is needed as jan1st is before leap day	            if (!isLeapYear(year)) {	                leapYears++;	            }	        }	        	        long millis = (relativeYear * 365L + leapYears)	            * (long)DateTimeConstants.MILLIS_PER_DAY;		        // Adjust to account for difference between 1963-01-01 and 1962-04-23.		        return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY;	    }	
int getMinYear() {	        return MIN_YEAR;	    }	
int getMaxYear() {	        return MAX_YEAR;	    }	
long getApproxMillisAtEpochDividedByTwo() {	        return (1962L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY) / 2;	    }	
protected void assemble(Fields fields) {	        if (getBase() == null) {	            super.assemble(fields);		            // Ethiopic, like Julian, has no year zero.	            fields.year = new SkipDateTimeField(this, fields.year);	            fields.weekyear = new SkipDateTimeField(this, fields.weekyear);	            	            fields.era = ERA_FIELD;	            fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 13);	            fields.months = fields.monthOfYear.getDurationField();	        }	    }	
/**	     * Create a StrictChronology for any chronology.	     *	     * @param base the chronology to wrap	     * @throws IllegalArgumentException if chronology is null	     */	    public static StrictChronology getInstance(Chronology base) {	        if (base == null) {	            throw new IllegalArgumentException("Must supply a chronology");	        }	        return new StrictChronology(base);	    }	
/**	     * Create a StrictChronology for any chronology.	     *	     * @param base the chronology to wrap	     */	    private StrictChronology(Chronology base) {	        super(base, null);	    }	
public Chronology withUTC() {	        if (iWithUTC == null) {	            if (getZone() == DateTimeZone.UTC) {	                iWithUTC = this;	            } else {	                iWithUTC = StrictChronology.getInstance(getBase().withUTC());	            }	        }	        return iWithUTC;	    }	
public Chronology withZone(DateTimeZone zone) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        if (zone == DateTimeZone.UTC) {	            return withUTC();	        }	        if (zone == getZone()) {	            return this;	        }	        return StrictChronology.getInstance(getBase().withZone(zone));	    }	
protected void assemble(Fields fields) {	        fields.year = convertField(fields.year);	        fields.yearOfEra = convertField(fields.yearOfEra);	        fields.yearOfCentury = convertField(fields.yearOfCentury);	        fields.centuryOfEra = convertField(fields.centuryOfEra);	        fields.era = convertField(fields.era);	        fields.dayOfWeek = convertField(fields.dayOfWeek);	        fields.dayOfMonth = convertField(fields.dayOfMonth);	        fields.dayOfYear = convertField(fields.dayOfYear);	        fields.monthOfYear = convertField(fields.monthOfYear);	        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear);	        fields.weekyear = convertField(fields.weekyear);	        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury);		        fields.millisOfSecond = convertField(fields.millisOfSecond);	        fields.millisOfDay = convertField(fields.millisOfDay);	        fields.secondOfMinute = convertField(fields.secondOfMinute);	        fields.secondOfDay = convertField(fields.secondOfDay);	        fields.minuteOfHour = convertField(fields.minuteOfHour);	        fields.minuteOfDay = convertField(fields.minuteOfDay);	        fields.hourOfDay = convertField(fields.hourOfDay);	        fields.hourOfHalfday = convertField(fields.hourOfHalfday);	        fields.clockhourOfDay = convertField(fields.clockhourOfDay);	        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday);	        fields.halfdayOfDay = convertField(fields.halfdayOfDay);	    }	
private static final DateTimeField convertField(DateTimeField field) {	        return StrictDateTimeField.getInstance(field);	    }	
/**	     * A strict chronology is only equal to a strict chronology with the	     * same base chronology.	     * 	     * @param obj  the object to compare to	     * @return true if equal	     * @since 1.4	     */	    public boolean equals(Object obj) {	        if (this == obj) {	            return true;	        }	        if (obj instanceof StrictChronology == false) {	            return false;	        }	        StrictChronology chrono = (StrictChronology) obj;	        return getBase().equals(chrono.getBase());	    }	
/**	     * A suitable hashcode for the chronology.	     * 	     * @return the hashcode	     * @since 1.4	     */	    public int hashCode() {	        return 352831696 + getBase().hashCode() * 7;	    }	
/**	     * A debugging string for the chronology.	     * 	     * @return the debugging string	     */	    public String toString() {	        return "StrictChronology[" + getBase().toString() + ']';	    }	
/**	     * Restricted constructor.	     *	     * @param base  the base chronology	     * @param param  the init parameter	     * @param minDaysInFirstWeek  the minimum days in the first week	     */	    BasicFixedMonthChronology(Chronology base, Object param, int minDaysInFirstWeek) {	        super(base, param, minDaysInFirstWeek);	    }	
long setYear(long instant, int year) {	        // optimsed implementation of set, due to fixed months	        int thisYear = getYear(instant);	        int dayOfYear = getDayOfYear(instant, thisYear);	        int millisOfDay = getMillisOfDay(instant);		        if (dayOfYear > 365) {	            // Current year is leap, and day is leap.	            if (!isLeapYear(year)) {	                // Moving to a non-leap year, leap day doesn't exist.	                dayOfYear--;	            }	        }		        instant = getYearMonthDayMillis(year, 1, dayOfYear);	        instant += millisOfDay;	        return instant;	    }	
long getYearDifference(long minuendInstant, long subtrahendInstant) {	        // optimsed implementation of getDifference, due to fixed months	        int minuendYear = getYear(minuendInstant);	        int subtrahendYear = getYear(subtrahendInstant);		        // Inlined remainder method to avoid duplicate calls to get.	        long minuendRem = minuendInstant - getYearMillis(minuendYear);	        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);		        int difference = minuendYear - subtrahendYear;	        if (minuendRem < subtrahendRem) {	            difference--;	        }	        return difference;	    }	
long getTotalMillisByYearMonth(int year, int month) {	        return ((month - 1) * MILLIS_PER_MONTH);	    }	
int getDayOfMonth(long millis) {	        // optimised for fixed months	        return (getDayOfYear(millis) - 1) % MONTH_LENGTH + 1;	    }	
boolean isLeapYear(int year) {	        return (year & 3) == 3;	    }	
int getDaysInYearMonth(int year, int month) {	        return (month != 13) ? MONTH_LENGTH : (isLeapYear(year) ? 6 : 5);	    }	
int getDaysInMonthMax() {	        return MONTH_LENGTH;	    }	
int getDaysInMonthMax(int month) {	        return (month != 13 ? MONTH_LENGTH : 6);	    }	
int getMonthOfYear(long millis) {	        return (getDayOfYear(millis) - 1) / MONTH_LENGTH + 1;	    }	
int getMonthOfYear(long millis, int year) {	        long monthZeroBased = (millis - getYearMillis(year)) / MILLIS_PER_MONTH;	        return ((int) monthZeroBased) + 1;	    }	
int getMaxMonth() {	        return 13;	    }	
long getAverageMillisPerYear() {	        return MILLIS_PER_YEAR;	    }	
long getAverageMillisPerYearDividedByTwo() {	        return MILLIS_PER_YEAR / 2;	    }	
long getAverageMillisPerMonth() {	        return MILLIS_PER_MONTH;	    }	
/**	     * Restricted constructor.	     */	    private ISOYearOfEraDateTimeField() {	        super(GregorianChronology.getInstanceUTC().year(), DateTimeFieldType.yearOfEra());	    }	
public int get(long instant) {	        int year = getWrappedField().get(instant);	        return year < 0 ? -year : year;	    }	
public long add(long instant, int years) {	        return getWrappedField().add(instant, years);	    }	
public long add(long instant, long years) {	        return getWrappedField().add(instant, years);	    }	
public long addWrapField(long instant, int years) {	        return getWrappedField().addWrapField(instant, years);	    }	
public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int years) {	        return getWrappedField().addWrapField(instant, fieldIndex, values, years);	    }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);	    }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);	    }	
public long set(long instant, int year) {	        FieldUtils.verifyValueBounds(this, year, 0, getMaximumValue());	        if (getWrappedField().get(instant) < 0) {	            year = -year;	        }	        return super.set(instant, year);	    }	
public int getMinimumValue() {	        return 0;	    }	
public int getMaximumValue() {	        return getWrappedField().getMaximumValue();	    }	
public long roundFloor(long instant) {	        return getWrappedField().roundFloor(instant);	    }	
public long roundCeiling(long instant) {	        return getWrappedField().roundCeiling(instant);	    }	
public long remainder(long instant) {	        return getWrappedField().remainder(instant);	    }	
/**	     * Serialization singleton	     */	    private Object readResolve() {	        return INSTANCE;	    }	
/**	     * Create a LenientChronology for any chronology.	     *	     * @param base the chronology to wrap	     * @throws IllegalArgumentException if chronology is null	     */	    public static LenientChronology getInstance(Chronology base) {	        if (base == null) {	            throw new IllegalArgumentException("Must supply a chronology");	        }	        return new LenientChronology(base);	    }	
/**	     * Create a LenientChronology for any chronology.	     *	     * @param base the chronology to wrap	     */	    private LenientChronology(Chronology base) {	        super(base, null);	    }	
public Chronology withUTC() {	        if (iWithUTC == null) {	            if (getZone() == DateTimeZone.UTC) {	                iWithUTC = this;	            } else {	                iWithUTC = LenientChronology.getInstance(getBase().withUTC());	            }	        }	        return iWithUTC;	    }	
public Chronology withZone(DateTimeZone zone) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        if (zone == DateTimeZone.UTC) {	            return withUTC();	        }	        if (zone == getZone()) {	            return this;	        }	        return LenientChronology.getInstance(getBase().withZone(zone));	    }	
protected void assemble(Fields fields) {	        fields.year = convertField(fields.year);	        fields.yearOfEra = convertField(fields.yearOfEra);	        fields.yearOfCentury = convertField(fields.yearOfCentury);	        fields.centuryOfEra = convertField(fields.centuryOfEra);	        fields.era = convertField(fields.era);	        fields.dayOfWeek = convertField(fields.dayOfWeek);	        fields.dayOfMonth = convertField(fields.dayOfMonth);	        fields.dayOfYear = convertField(fields.dayOfYear);	        fields.monthOfYear = convertField(fields.monthOfYear);	        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear);	        fields.weekyear = convertField(fields.weekyear);	        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury);		        fields.millisOfSecond = convertField(fields.millisOfSecond);	        fields.millisOfDay = convertField(fields.millisOfDay);	        fields.secondOfMinute = convertField(fields.secondOfMinute);	        fields.secondOfDay = convertField(fields.secondOfDay);	        fields.minuteOfHour = convertField(fields.minuteOfHour);	        fields.minuteOfDay = convertField(fields.minuteOfDay);	        fields.hourOfDay = convertField(fields.hourOfDay);	        fields.hourOfHalfday = convertField(fields.hourOfHalfday);	        fields.clockhourOfDay = convertField(fields.clockhourOfDay);	        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday);	        fields.halfdayOfDay = convertField(fields.halfdayOfDay);	    }	
private final DateTimeField convertField(DateTimeField field) {	        return LenientDateTimeField.getInstance(field, getBase());	    }	
/**	     * A lenient chronology is only equal to a lenient chronology with the	     * same base chronology.	     * 	     * @param obj  the object to compare to	     * @return true if equal	     * @since 1.4	     */	    public boolean equals(Object obj) {	        if (this == obj) {	            return true;	        }	        if (obj instanceof LenientChronology == false) {	            return false;	        }	        LenientChronology chrono = (LenientChronology) obj;	        return getBase().equals(chrono.getBase());	    }	
/**	     * A suitable hashcode for the chronology.	     * 	     * @return the hashcode	     * @since 1.4	     */	    public int hashCode() {	        return 236548278 + getBase().hashCode() * 7;	    }	
/**	     * A debugging string for the chronology.	     * 	     * @return the debugging string	     */	    public String toString() {	        return "LenientChronology[" + getBase().toString() + ']';	    }	
/**	     * Gets an instance of the ISOChronology.	     * The time zone of the returned instance is UTC.	     * 	     * @return a singleton UTC instance of the chronology	     */	    public static ISOChronology getInstanceUTC() {	        return INSTANCE_UTC;	    }	
/**	     * Gets an instance of the ISOChronology in the default time zone.	     * 	     * @return a chronology in the default time zone	     */	    public static ISOChronology getInstance() {	        return getInstance(DateTimeZone.getDefault());	    }	
/**	     * Gets an instance of the ISOChronology in the given time zone.	     * 	     * @param zone  the time zone to get the chronology in, null is default	     * @return a chronology in the specified time zone	     */	    public static ISOChronology getInstance(DateTimeZone zone) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);	        ISOChronology chrono = cFastCache[index];	        if (chrono != null && chrono.getZone() == zone) {	            return chrono;	        }	        synchronized (cCache) {	            chrono = cCache.get(zone);	            if (chrono == null) {	                chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));	                cCache.put(zone, chrono);	            }	        }	        cFastCache[index] = chrono;	        return chrono;	    }	
/**	     * Restricted constructor	     */	    private ISOChronology(Chronology base) {	        super(base, null);	    }	
/**	     * Gets the Chronology in the UTC time zone.	     * 	     * @return the chronology in UTC	     */	    public Chronology withUTC() {	        return INSTANCE_UTC;	    }	
/**	     * Gets the Chronology in a specific time zone.	     * 	     * @param zone  the zone to get the chronology in, null is default	     * @return the chronology	     */	    public Chronology withZone(DateTimeZone zone) {	        if (zone == null) {	            zone = DateTimeZone.getDefault();	        }	        if (zone == getZone()) {	            return this;	        }	        return getInstance(zone);	    }	
/**	     * Gets a debugging toString.	     * 	     * @return a debugging string	     */	    public String toString() {	        String str = "ISOChronology";	        DateTimeZone zone = getZone();	        if (zone != null) {	            str = str + '[' + zone.getID() + ']';	        }	        return str;	    }	
protected void assemble(Fields fields) {	        if (getBase().getZone() == DateTimeZone.UTC) {	            // Use zero based century and year of century.	            fields.centuryOfEra = new DividedDateTimeField(	                ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100);	            fields.yearOfCentury = new RemainderDateTimeField(	                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury());	            fields.weekyearOfCentury = new RemainderDateTimeField(	                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.weekyearOfCentury());		            fields.centuries = fields.centuryOfEra.getDurationField();	        }	    }	
/**	     * Checks if this chronology instance equals another.	     * 	     * @param obj  the object to compare to	     * @return true if equal	     * @since 1.6	     */	    public boolean equals(Object obj) {	        return super.equals(obj);	    }	
/**	     * A suitable hash code for the chronology.	     * 	     * @return the hash code	     * @since 1.6	     */	    public int hashCode() {	        return "ISO".hashCode() * 11 + getZone().hashCode();	    }	
/**	     * Serialize ISOChronology instances using a small stub. This reduces the	     * serialized size, and deserialized instances come from the cache.	     */	    private Object writeReplace() {	        return new Stub(getZone());	    }	
Stub(DateTimeZone zone) {	            iZone = zone;	        }	
private Object readResolve() {	            return ISOChronology.getInstance(iZone);	        }	
private void writeObject(ObjectOutputStream out) throws IOException {	            out.writeObject(iZone);	        }	
private void readObject(ObjectInputStream in)	            throws IOException, ClassNotFoundException	        {	            iZone = (DateTimeZone)in.readObject();	        }	
/**	     * Restricted constructor.	     */	    GJYearOfEraDateTimeField(DateTimeField yearField, BasicChronology chronology) {	        super(yearField, DateTimeFieldType.yearOfEra());	        iChronology = chronology;	    }	
public int get(long instant) {	        int year = getWrappedField().get(instant);	        if (year <= 0) {	            year = 1 - year;	        }	        return year;	    }	
public long add(long instant, int years) {	        return getWrappedField().add(instant, years);	    }	
public long add(long instant, long years) {	        return getWrappedField().add(instant, years);	    }	
public long addWrapField(long instant, int years) {	        return getWrappedField().addWrapField(instant, years);	    }	
public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int years) {	        return getWrappedField().addWrapField(instant, fieldIndex, values, years);	    }	
public int getDifference(long minuendInstant, long subtrahendInstant) {	        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);	    }	
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {	        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);	    }	
/**	     * Set the year component of the specified time instant.	     * 	     * @param instant  the time instant in millis to update.	     * @param year  the year (0,292278994) to update the time to.	     * @return the updated time instant.	     * @throws IllegalArgumentException  if year is invalid.	     */	    public long set(long instant, int year) {	        FieldUtils.verifyValueBounds(this, year, 1, getMaximumValue());	        if (iChronology.getYear(instant) <= 0) {	            year = 1 - year;	        }	        return super.set(instant, year);	    }	
public int getMinimumValue() {	        return 1;	    }	
public int getMaximumValue() {	        return getWrappedField().getMaximumValue();	    }	
public long roundFloor(long instant) {	        return getWrappedField().roundFloor(instant);	    }	
public long roundCeiling(long instant) {	        return getWrappedField().roundCeiling(instant);	    }	
public long remainder(long instant) {	        return getWrappedField().remainder(instant);	    }	
/**	     * Serialization singleton	     */	    private Object readResolve() {	        return iChronology.yearOfEra();	    }	
/**	     * Returns a new CachedDateTimeZone unless given zone is already cached.	     */	    public static CachedDateTimeZone forZone(DateTimeZone zone) {	        if (zone instanceof CachedDateTimeZone) {	            return (CachedDateTimeZone)zone;	        }	        return new CachedDateTimeZone(zone);	    }	
private CachedDateTimeZone(DateTimeZone zone) {	        super(zone.getID());	        iZone = zone;	        iInfoCache = new Info[cInfoCacheMask + 1];	    }	
private void readObject(java.io.ObjectInputStream in)	        throws java.io.IOException, ClassNotFoundException	    {	        in.defaultReadObject();	        iInfoCache = new Info[cInfoCacheMask + 1];	    }	
/**	     * Returns the DateTimeZone being wrapped.	     */	    public DateTimeZone getUncachedZone() {	        return iZone;	    }	
public String getNameKey(long instant) {	        return getInfo(instant).getNameKey(instant);	    }	
public int getOffset(long instant) {	        return getInfo(instant).getOffset(instant);	    }	
public int getStandardOffset(long instant) {	        return getInfo(instant).getStandardOffset(instant);	    }	
public boolean isFixed() {	        return iZone.isFixed();	    }	
public long nextTransition(long instant) {	        return iZone.nextTransition(instant);	    }	
public long previousTransition(long instant) {	        return iZone.previousTransition(instant);	    }	
public int hashCode() {	        return iZone.hashCode();	    }	
public boolean equals(Object obj) {	        if (this == obj) {	            return true;	        }	        if (obj instanceof CachedDateTimeZone) {	            return iZone.equals(((CachedDateTimeZone)obj).iZone);	        }	        return false;	    }	
private Info getInfo(long millis) {	        int period = (int)(millis >> 32);	        Info[] cache = iInfoCache;	        int index = period & cInfoCacheMask;	        Info info = cache[index];	        if (info == null || (int)((info.iPeriodStart >> 32)) != period) {	            info = createInfo(millis);	            cache[index] = info;	        }	        return info;	    }	
private Info createInfo(long millis) {	        long periodStart = millis & (0xffffffffL << 32);	        Info info = new Info(iZone, periodStart);	        	        long end = periodStart | 0xffffffffL;	        Info chain = info;	        while (true) {	            long next = iZone.nextTransition(periodStart);	            if (next == periodStart || next > end) {	                break;	            }	            periodStart = next;	            chain = (chain.iNextInfo = new Info(iZone, periodStart));	        }		        return info;	    }	
Info(DateTimeZone zone, long periodStart) {	            iPeriodStart = periodStart;	            iZoneRef = zone;	        }	
public String getNameKey(long millis) {	            if (iNextInfo == null || millis < iNextInfo.iPeriodStart) {	                if (iNameKey == null) {	                    iNameKey = iZoneRef.getNameKey(iPeriodStart);	                }	                return iNameKey;	            }	            return iNextInfo.getNameKey(millis);	        }	
public int getOffset(long millis) {	            if (iNextInfo == null || millis < iNextInfo.iPeriodStart) {	                if (iOffset == Integer.MIN_VALUE) {	                    iOffset = iZoneRef.getOffset(iPeriodStart);	                }	                return iOffset;	            }	            return iNextInfo.getOffset(millis);	        }	
public int getStandardOffset(long millis) {	            if (iNextInfo == null || millis < iNextInfo.iPeriodStart) {	                if (iStandardOffset == Integer.MIN_VALUE) {	                    iStandardOffset = iZoneRef.getStandardOffset(iPeriodStart);	                }	                return iStandardOffset;	            }	            return iNextInfo.getStandardOffset(millis);	        }	
/**	     * Constructor.	     */	    public UTCProvider() {	        super();	    }	
/**	     * Returns {@link DateTimeZone#UTC UTC} for <code>"UTC"</code>, null	     * otherwise.	     */	    public DateTimeZone getZone(String id) {	        if ("UTC".equalsIgnoreCase(id)) {	            return DateTimeZone.UTC;	        }	        return null;	    }	
/**	     * Returns a singleton collection containing only <code>"UTC"</code>.	     */    	    public Set<String> getAvailableIDs() {	        return Collections.singleton("UTC");	    }	
public FixedDateTimeZone(String id, String nameKey,	                             int wallOffset, int standardOffset) {	        super(id);	        iNameKey = nameKey;	        iWallOffset = wallOffset;	        iStandardOffset = standardOffset;	    }	
public String getNameKey(long instant) {	        return iNameKey;	    }	
public int getOffset(long instant) {	        return iWallOffset;	    }	
public int getStandardOffset(long instant) {	        return iStandardOffset;	    }	
public int getOffsetFromLocal(long instantLocal) {	        return iWallOffset;	    }	
public boolean isFixed() {	        return true;	    }	
public long nextTransition(long instant) {	        return instant;	    }	
public long previousTransition(long instant) {	        return instant;	    }	
/**	     * Override to return the correct timzone instance.	     * @since 1.5	     */	    public java.util.TimeZone toTimeZone() {	        String id = getID();	        if (id.length() == 6 && (id.startsWith("+") || id.startsWith("-"))) {	            // standard format offset [+-]hh:mm	            // our ID is without any prefix, so we need to add the GMT back	            return java.util.TimeZone.getTimeZone("GMT" + getID());	        }	        // unusual offset, so setup a SimpleTimeZone as best we can	        return new java.util.SimpleTimeZone(iWallOffset, getID());	    }	
public boolean equals(Object obj) {	        if (this == obj) {	            return true;	        }	        if (obj instanceof FixedDateTimeZone) {	            FixedDateTimeZone other = (FixedDateTimeZone)obj;	            return	                getID().equals(other.getID()) &&	                iStandardOffset == other.iStandardOffset &&	                iWallOffset == other.iWallOffset;	        }	        return false;	    }	
public int hashCode() {	        return getID().hashCode() + 37 * iStandardOffset + 31 * iWallOffset;	    }	
/**	     * Decodes a built DateTimeZone from the given stream, as encoded by	     * writeTo.	     *	     * @param in input stream to read encoded DateTimeZone from.	     * @param id time zone id to assign	     */	    public static DateTimeZone readFrom(InputStream in, String id) throws IOException {	        if (in instanceof DataInput) {	            return readFrom((DataInput)in, id);	        } else {	            return readFrom((DataInput)new DataInputStream(in), id);	        }	    }	
/**	     * Decodes a built DateTimeZone from the given stream, as encoded by	     * writeTo.	     *	     * @param in input stream to read encoded DateTimeZone from.	     * @param id time zone id to assign	     */	    public static DateTimeZone readFrom(DataInput in, String id) throws IOException {	        switch (in.readUnsignedByte()) {	        case 'F':	            DateTimeZone fixed = new FixedDateTimeZone	                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));	            if (fixed.equals(DateTimeZone.UTC)) {	                fixed = DateTimeZone.UTC;	            }	            return fixed;	        case 'C':	            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));	        case 'P':	            return PrecalculatedZone.readFrom(in, id);	        default:	            throw new IOException("Invalid encoding");	        }	    }	
/**	     * Millisecond encoding formats:	     *	     * upper two bits  units       field length  approximate range	     * ---------------------------------------------------------------	     * 00              30 minutes  1 byte        +/- 16 hours	     * 01              minutes     4 bytes       +/- 1020 years	     * 10              seconds     5 bytes       +/- 4355 years	     * 11              millis      9 bytes       +/- 292,000,000 years	     *	     * Remaining bits in field form signed offset from 1970-01-01T00:00:00Z.	     */	    static void writeMillis(DataOutput out, long millis) throws IOException {	        if (millis % (30 * 60000L) == 0) {	            // Try to write in 30 minute units.	            long units = millis / (30 * 60000L);	            if (((units << (64 - 6)) >> (64 - 6)) == units) {	                // Form 00 (6 bits effective precision)	                out.writeByte((int)(units & 0x3f));	                return;	            }	        }		        if (millis % 60000L == 0) {	            // Try to write minutes.	            long minutes = millis / 60000L;	            if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) {	                // Form 01 (30 bits effective precision)	                out.writeInt(0x40000000 | (int)(minutes & 0x3fffffff));	                return;	            }	        }	        	        if (millis % 1000L == 0) {	            // Try to write seconds.	            long seconds = millis / 1000L;	            if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) {	                // Form 10 (38 bits effective precision)	                out.writeByte(0x80 | (int)((seconds >> 32) & 0x3f));	                out.writeInt((int)(seconds & 0xffffffff));	                return;	            }	        }		        // Write milliseconds either because the additional precision is	        // required or the minutes didn't fit in the field.	        	        // Form 11 (64 bits effective precision, but write as if 70 bits)	        out.writeByte(millis < 0 ? 0xff : 0xc0);	        out.writeLong(millis);	    }	
/**	     * Reads encoding generated by writeMillis.	     */	    static long readMillis(DataInput in) throws IOException {	        int v = in.readUnsignedByte();	        switch (v >> 6) {	        case 0: default:	            // Form 00 (6 bits effective precision)	            v = (v << (32 - 6)) >> (32 - 6);	            return v * (30 * 60000L);		        case 1:	            // Form 01 (30 bits effective precision)	            v = (v << (32 - 6)) >> (32 - 30);	            v |= (in.readUnsignedByte()) << 16;	            v |= (in.readUnsignedByte()) << 8;	            v |= (in.readUnsignedByte());	            return v * 60000L;		        case 2:	            // Form 10 (38 bits effective precision)	            long w = (((long)v) << (64 - 6)) >> (64 - 38);	            w |= (in.readUnsignedByte()) << 24;	            w |= (in.readUnsignedByte()) << 16;	            w |= (in.readUnsignedByte()) << 8;	            w |= (in.readUnsignedByte());	            return w * 1000L;		        case 3:	            // Form 11 (64 bits effective precision)	            return in.readLong();	        }	    }	
private static DateTimeZone buildFixedZone(String id, String nameKey,	                                               int wallOffset, int standardOffset) {	        if ("UTC".equals(id) && id.equals(nameKey) &&	            wallOffset == 0 && standardOffset == 0) {	            return DateTimeZone.UTC;	        }	        return new FixedDateTimeZone(id, nameKey, wallOffset, standardOffset);	    }	
public DateTimeZoneBuilder() {	        iRuleSets = new ArrayList<RuleSet>(10);	    }	
/**	     * Adds a cutover for added rules. The standard offset at the cutover	     * defaults to 0. Call setStandardOffset afterwards to change it.	     *	     * @param year  the year of cutover	     * @param mode 'u' - cutover is measured against UTC, 'w' - against wall	     *  offset, 's' - against standard offset	     * @param monthOfYear  the month from 1 (January) to 12 (December)	     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).	     *  For example, if -1, set to last day of month	     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore	     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to	     *  dayOfWeek when true, retreat when false.	     * @param millisOfDay  additional precision for specifying time of day of cutover	     */	    public DateTimeZoneBuilder addCutover(int year,	                                          char mode,	                                          int monthOfYear,	                                          int dayOfMonth,	                                          int dayOfWeek,	                                          boolean advanceDayOfWeek,	                                          int millisOfDay)	    {	        OfYear ofYear = new OfYear	            (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);	        if (iRuleSets.size() > 0) {	            RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1);	            lastRuleSet.setUpperLimit(year, ofYear);	        }	        iRuleSets.add(new RuleSet());	        return this;	    }	
/**	     * Sets the standard offset to use for newly added rules until the next	     * cutover is added.	     * @param standardOffset  the standard offset in millis	     */	    public DateTimeZoneBuilder setStandardOffset(int standardOffset) {	        getLastRuleSet().setStandardOffset(standardOffset);	        return this;	    }	
/**	     * Set a fixed savings rule at the cutover.	     */	    public DateTimeZoneBuilder setFixedSavings(String nameKey, int saveMillis) {	        getLastRuleSet().setFixedSavings(nameKey, saveMillis);	        return this;	    }	
/**	     * Add a recurring daylight saving time rule.	     *	     * @param nameKey  the name key of new rule	     * @param saveMillis  the milliseconds to add to standard offset	     * @param fromYear  the first year that rule is in effect, MIN_VALUE indicates	     * beginning of time	     * @param toYear  the last year (inclusive) that rule is in effect, MAX_VALUE	     *  indicates end of time	     * @param mode  'u' - transitions are calculated against UTC, 'w' -	     *  transitions are calculated against wall offset, 's' - transitions are	     *  calculated against standard offset	     * @param monthOfYear  the month from 1 (January) to 12 (December)	     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).	     *  For example, if -1, set to last day of month	     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore	     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to	     *  dayOfWeek when true, retreat when false.	     * @param millisOfDay  additional precision for specifying time of day of transitions	     */	    public DateTimeZoneBuilder addRecurringSavings(String nameKey, int saveMillis,	                                                   int fromYear, int toYear,	                                                   char mode,	                                                   int monthOfYear,	                                                   int dayOfMonth,	                                                   int dayOfWeek,	                                                   boolean advanceDayOfWeek,	                                                   int millisOfDay)	    {	        if (fromYear <= toYear) {	            OfYear ofYear = new OfYear	                (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);	            Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis);	            Rule rule = new Rule(recurrence, fromYear, toYear);	            getLastRuleSet().addRule(rule);	        }	        return this;	    }	
private RuleSet getLastRuleSet() {	        if (iRuleSets.size() == 0) {	            addCutover(Integer.MIN_VALUE, 'w', 1, 1, 0, false, 0);	        }	        return iRuleSets.get(iRuleSets.size() - 1);	    }	
/**	     * Processes all the rules and builds a DateTimeZone.	     *	     * @param id  time zone id to assign	     * @param outputID  true if the zone id should be output	     */	    public DateTimeZone toDateTimeZone(String id, boolean outputID) {	        if (id == null) {	            throw new IllegalArgumentException();	        }		        // Discover where all the transitions occur and store the results in	        // these lists.	        ArrayList<Transition> transitions = new ArrayList<Transition>();		        // Tail zone picks up remaining transitions in the form of an endless	        // DST cycle.	        DSTZone tailZone = null;		        long millis = Long.MIN_VALUE;	        int saveMillis = 0;	            	        int ruleSetCount = iRuleSets.size();	        for (int i=0; i<ruleSetCount; i++) {	            RuleSet rs = iRuleSets.get(i);	            Transition next = rs.firstTransition(millis);	            if (next == null) {	                continue;	            }	            addTransition(transitions, next);	            millis = next.getMillis();	            saveMillis = next.getSaveMillis();		            // Copy it since we're going to destroy it.	            rs = new RuleSet(rs);		            while ((next = rs.nextTransition(millis, saveMillis)) != null) {	                if (addTransition(transitions, next)) {	                    if (tailZone != null) {	                        // Got the extra transition before DSTZone.	                        break;	                    }	                }	                millis = next.getMillis();	                saveMillis = next.getSaveMillis();	                if (tailZone == null && i == ruleSetCount - 1) {	                    tailZone = rs.buildTailZone(id);	                    // If tailZone is not null, don't break out of main loop until	                    // at least one more transition is calculated. This ensures a	                    // correct 'seam' to the DSTZone.	                }	            }		            millis = rs.getUpperLimit(saveMillis);	        }		        // Check if a simpler zone implementation can be returned.	        if (transitions.size() == 0) {	            if (tailZone != null) {	                // This shouldn't happen, but handle just in case.	                return tailZone;	            }	            return buildFixedZone(id, "UTC", 0, 0);	        }	        if (transitions.size() == 1 && tailZone == null) {	            Transition tr = transitions.get(0);	            return buildFixedZone(id, tr.getNameKey(),	                                  tr.getWallOffset(), tr.getStandardOffset());	        }		        PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone);	        if (zone.isCachable()) {	            return CachedDateTimeZone.forZone(zone);	        }	        return zone;	    }	
private boolean addTransition(ArrayList<Transition> transitions, Transition tr) {	        int size = transitions.size();	        if (size == 0) {	            transitions.add(tr);	            return true;	        }		        Transition last = transitions.get(size - 1);	        if (!tr.isTransitionFrom(last)) {	            return false;	        }		        // If local time of new transition is same as last local time, just	        // replace last transition with new one.	        int offsetForLast = 0;	        if (size >= 2) {	            offsetForLast = transitions.get(size - 2).getWallOffset();	        }	        int offsetForNew = last.getWallOffset();		        long lastLocal = last.getMillis() + offsetForLast;	        long newLocal = tr.getMillis() + offsetForNew;		        if (newLocal != lastLocal) {	            transitions.add(tr);	            return true;	        }		        transitions.remove(size - 1);	        return addTransition(transitions, tr);	    }	
/**	     * Encodes a built DateTimeZone to the given stream. Call readFrom to	     * decode the data into a DateTimeZone object.	     *	     * @param out  the output stream to receive the encoded DateTimeZone	     * @since 1.5 (parameter added)	     */	    public void writeTo(String zoneID, OutputStream out) throws IOException {	        if (out instanceof DataOutput) {	            writeTo(zoneID, (DataOutput)out);	        } else {	            writeTo(zoneID, (DataOutput)new DataOutputStream(out));	        }	    }	
/**	     * Encodes a built DateTimeZone to the given stream. Call readFrom to	     * decode the data into a DateTimeZone object.	     *	     * @param out  the output stream to receive the encoded DateTimeZone	     * @since 1.5 (parameter added)	     */	    public void writeTo(String zoneID, DataOutput out) throws IOException {	        // pass false so zone id is not written out	        DateTimeZone zone = toDateTimeZone(zoneID, false);		        if (zone instanceof FixedDateTimeZone) {	            out.writeByte('F'); // 'F' for fixed	            out.writeUTF(zone.getNameKey(0));	            writeMillis(out, zone.getOffset(0));	            writeMillis(out, zone.getStandardOffset(0));	        } else {	            if (zone instanceof CachedDateTimeZone) {	                out.writeByte('C'); // 'C' for cached, precalculated	                zone = ((CachedDateTimeZone)zone).getUncachedZone();	            } else {	                out.writeByte('P'); // 'P' for precalculated, uncached	            }	            ((PrecalculatedZone)zone).writeTo(out);	        }	    }	
static OfYear readFrom(DataInput in) throws IOException {	            return new OfYear((char)in.readUnsignedByte(),	                              (int)in.readUnsignedByte(),	                              (int)in.readByte(),	                              (int)in.readUnsignedByte(),	                              in.readBoolean(),	                              (int)readMillis(in));	        }	
OfYear(char mode,	               int monthOfYear,	               int dayOfMonth,	               int dayOfWeek, boolean advanceDayOfWeek,	               int millisOfDay)	        {	            if (mode != 'u' && mode != 'w' && mode != 's') {	                throw new IllegalArgumentException("Unknown mode: " + mode);	            }		            iMode = mode;	            iMonthOfYear = monthOfYear;	            iDayOfMonth = dayOfMonth;	            iDayOfWeek = dayOfWeek;	            iAdvance = advanceDayOfWeek;	            iMillisOfDay = millisOfDay;	        }	
/**	         * @param standardOffset standard offset just before instant	         */	        public long setInstant(int year, int standardOffset, int saveMillis) {	            int offset;	            if (iMode == 'w') {	                offset = standardOffset + saveMillis;	            } else if (iMode == 's') {	                offset = standardOffset;	            } else {	                offset = 0;	            }		            Chronology chrono = ISOChronology.getInstanceUTC();	            long millis = chrono.year().set(0, year);	            millis = chrono.monthOfYear().set(millis, iMonthOfYear);	            millis = chrono.millisOfDay().set(millis, iMillisOfDay);	            millis = setDayOfMonth(chrono, millis);		            if (iDayOfWeek != 0) {	                millis = setDayOfWeek(chrono, millis);	            }		            // Convert from local time to UTC.	            return millis - offset;	        }	
/**	         * @param standardOffset standard offset just before next recurrence	         */	        public long next(long instant, int standardOffset, int saveMillis) {	            int offset;	            if (iMode == 'w') {	                offset = standardOffset + saveMillis;	            } else if (iMode == 's') {	                offset = standardOffset;	            } else {	                offset = 0;	            }		            // Convert from UTC to local time.	            instant += offset;		            Chronology chrono = ISOChronology.getInstanceUTC();	            long next = chrono.monthOfYear().set(instant, iMonthOfYear);	            // Be lenient with millisOfDay.	            next = chrono.millisOfDay().set(next, 0);	            next = chrono.millisOfDay().add(next, iMillisOfDay);	            next = setDayOfMonthNext(chrono, next);		            if (iDayOfWeek == 0) {	                if (next <= instant) {	                    next = chrono.year().add(next, 1);	                    next = setDayOfMonthNext(chrono, next);	                }	            } else {	                next = setDayOfWeek(chrono, next);	                if (next <= instant) {	                    next = chrono.year().add(next, 1);	                    next = chrono.monthOfYear().set(next, iMonthOfYear);	                    next = setDayOfMonthNext(chrono, next);	                    next = setDayOfWeek(chrono, next);	                }	            }		            // Convert from local time to UTC.	            return next - offset;	        }	
/**	         * @param standardOffset standard offset just before previous recurrence	         */	        public long previous(long instant, int standardOffset, int saveMillis) {	            int offset;	            if (iMode == 'w') {	                offset = standardOffset + saveMillis;	            } else if (iMode == 's') {	                offset = standardOffset;	            } else {	                offset = 0;	            }		            // Convert from UTC to local time.	            instant += offset;		            Chronology chrono = ISOChronology.getInstanceUTC();	            long prev = chrono.monthOfYear().set(instant, iMonthOfYear);	            // Be lenient with millisOfDay.	            prev = chrono.millisOfDay().set(prev, 0);	            prev = chrono.millisOfDay().add(prev, iMillisOfDay);	            prev = setDayOfMonthPrevious(chrono, prev);		            if (iDayOfWeek == 0) {	                if (prev >= instant) {	                    prev = chrono.year().add(prev, -1);	                    prev = setDayOfMonthPrevious(chrono, prev);	                }	            } else {	                prev = setDayOfWeek(chrono, prev);	                if (prev >= instant) {	                    prev = chrono.year().add(prev, -1);	                    prev = chrono.monthOfYear().set(prev, iMonthOfYear);	                    prev = setDayOfMonthPrevious(chrono, prev);	                    prev = setDayOfWeek(chrono, prev);	                }	            }		            // Convert from local time to UTC.	            return prev - offset;	        }	
public boolean equals(Object obj) {	            if (this == obj) {	                return true;	            }	            if (obj instanceof OfYear) {	                OfYear other = (OfYear)obj;	                return	                    iMode == other.iMode &&	                    iMonthOfYear == other.iMonthOfYear &&	                    iDayOfMonth == other.iDayOfMonth &&	                    iDayOfWeek == other.iDayOfWeek &&	                    iAdvance == other.iAdvance &&	                    iMillisOfDay == other.iMillisOfDay;	            }	            return false;	        }	
public void writeTo(DataOutput out) throws IOException {	            out.writeByte(iMode);	            out.writeByte(iMonthOfYear);	            out.writeByte(iDayOfMonth);	            out.writeByte(iDayOfWeek);	            out.writeBoolean(iAdvance);	            writeMillis(out, iMillisOfDay);	        }	
/**	         * If month-day is 02-29 and year isn't leap, advances to next leap year.	         */	        private long setDayOfMonthNext(Chronology chrono, long next) {	            try {	                next = setDayOfMonth(chrono, next);	            } catch (IllegalArgumentException e) {	                if (iMonthOfYear == 2 && iDayOfMonth == 29) {	                    while (chrono.year().isLeap(next) == false) {	                        next = chrono.year().add(next, 1);	                    }	                    next = setDayOfMonth(chrono, next);	                } else {	                    throw e;	                }	            }	            return next;	        }	
/**	         * If month-day is 02-29 and year isn't leap, retreats to previous leap year.	         */	        private long setDayOfMonthPrevious(Chronology chrono, long prev) {	            try {	                prev = setDayOfMonth(chrono, prev);	            } catch (IllegalArgumentException e) {	                if (iMonthOfYear == 2 && iDayOfMonth == 29) {	                    while (chrono.year().isLeap(prev) == false) {	                        prev = chrono.year().add(prev, -1);	                    }	                    prev = setDayOfMonth(chrono, prev);	                } else {	                    throw e;	                }	            }	            return prev;	        }	
private long setDayOfMonth(Chronology chrono, long instant) {	            if (iDayOfMonth >= 0) {	                instant = chrono.dayOfMonth().set(instant, iDayOfMonth);	            } else {	                instant = chrono.dayOfMonth().set(instant, 1);	                instant = chrono.monthOfYear().add(instant, 1);	                instant = chrono.dayOfMonth().add(instant, iDayOfMonth);	            }	            return instant;	        }	
private long setDayOfWeek(Chronology chrono, long instant) {	            int dayOfWeek = chrono.dayOfWeek().get(instant);	            int daysToAdd = iDayOfWeek - dayOfWeek;	            if (daysToAdd != 0) {	                if (iAdvance) {	                    if (daysToAdd < 0) {	                        daysToAdd += 7;	                    }	                } else {	                    if (daysToAdd > 0) {	                        daysToAdd -= 7;	                    }	                }	                instant = chrono.dayOfWeek().add(instant, daysToAdd);	            }	            return instant;	        }	
static Recurrence readFrom(DataInput in) throws IOException {	            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));	        }	
Recurrence(OfYear ofYear, String nameKey, int saveMillis) {	            iOfYear = ofYear;	            iNameKey = nameKey;	            iSaveMillis = saveMillis;	        }	
public OfYear getOfYear() {	            return iOfYear;	        }	
/**	         * @param standardOffset standard offset just before next recurrence	         */	        public long next(long instant, int standardOffset, int saveMillis) {	            return iOfYear.next(instant, standardOffset, saveMillis);	        }	
/**	         * @param standardOffset standard offset just before previous recurrence	         */	        public long previous(long instant, int standardOffset, int saveMillis) {	            return iOfYear.previous(instant, standardOffset, saveMillis);	        }	
public String getNameKey() {	            return iNameKey;	        }	
public int getSaveMillis() {	            return iSaveMillis;	        }	
public boolean equals(Object obj) {	            if (this == obj) {	                return true;	            }	            if (obj instanceof Recurrence) {	                Recurrence other = (Recurrence)obj;	                return	                    iSaveMillis == other.iSaveMillis &&	                    iNameKey.equals(other.iNameKey) &&	                    iOfYear.equals(other.iOfYear);	            }	            return false;	        }	
public void writeTo(DataOutput out) throws IOException {	            iOfYear.writeTo(out);	            out.writeUTF(iNameKey);	            writeMillis(out, iSaveMillis);	        }	
Recurrence rename(String nameKey) {	            return new Recurrence(iOfYear, nameKey, iSaveMillis);	        }	
Recurrence renameAppend(String appendNameKey) {	            return rename((iNameKey + appendNameKey).intern());	        }	
Rule(Recurrence recurrence, int fromYear, int toYear) {	            iRecurrence = recurrence;	            iFromYear = fromYear;	            iToYear = toYear;	        }	
public int getFromYear() {	            return iFromYear;	        }	
public int getToYear() {	            return iToYear;	        }	
public OfYear getOfYear() {	            return iRecurrence.getOfYear();	        }	
public String getNameKey() {	            return iRecurrence.getNameKey();	        }	
public int getSaveMillis() {	            return iRecurrence.getSaveMillis();	        }	
public long next(final long instant, int standardOffset, int saveMillis) {	            Chronology chrono = ISOChronology.getInstanceUTC();		            final int wallOffset = standardOffset + saveMillis;	            long testInstant = instant;		            int year;	            if (instant == Long.MIN_VALUE) {	                year = Integer.MIN_VALUE;	            } else {	                year = chrono.year().get(instant + wallOffset);	            }		            if (year < iFromYear) {	                // First advance instant to start of from year.	                testInstant = chrono.year().set(0, iFromYear) - wallOffset;	                // Back off one millisecond to account for next recurrence	                // being exactly at the beginning of the year.	                testInstant -= 1;	            }		            long next = iRecurrence.next(testInstant, standardOffset, saveMillis);		            if (next > instant) {	                year = chrono.year().get(next + wallOffset);	                if (year > iToYear) {	                    // Out of range, return original value.	                    next = instant;	                }	            }		            return next;	        }	
Transition(long millis, Transition tr) {	            iMillis = millis;	            iNameKey = tr.iNameKey;	            iWallOffset = tr.iWallOffset;	            iStandardOffset = tr.iStandardOffset;	        }	
Transition(long millis, Rule rule, int standardOffset) {	            iMillis = millis;	            iNameKey = rule.getNameKey();	            iWallOffset = standardOffset + rule.getSaveMillis();	            iStandardOffset = standardOffset;	        }	
Transition(long millis, String nameKey,	                   int wallOffset, int standardOffset) {	            iMillis = millis;	            iNameKey = nameKey;	            iWallOffset = wallOffset;	            iStandardOffset = standardOffset;	        }	
public long getMillis() {	            return iMillis;	        }	
public String getNameKey() {	            return iNameKey;	        }	
public int getWallOffset() {	            return iWallOffset;	        }	
public int getStandardOffset() {	            return iStandardOffset;	        }	
public int getSaveMillis() {	            return iWallOffset - iStandardOffset;	        }	
/**	         * There must be a change in the millis, wall offsets or name keys.	         */	        public boolean isTransitionFrom(Transition other) {	            if (other == null) {	                return true;	            }	            return iMillis > other.iMillis &&	                (iWallOffset != other.iWallOffset ||	                 //iStandardOffset != other.iStandardOffset ||	                 !(iNameKey.equals(other.iNameKey)));	        }	
RuleSet() {	            iRules = new ArrayList<Rule>(10);	            iUpperYear = Integer.MAX_VALUE;	        }	
/**	         * Copy constructor.	         */	        RuleSet(RuleSet rs) {	            iStandardOffset = rs.iStandardOffset;	            iRules = new ArrayList<Rule>(rs.iRules);	            iInitialNameKey = rs.iInitialNameKey;	            iInitialSaveMillis = rs.iInitialSaveMillis;	            iUpperYear = rs.iUpperYear;	            iUpperOfYear = rs.iUpperOfYear;	        }	
public int getStandardOffset() {	            return iStandardOffset;	        }	
public void setStandardOffset(int standardOffset) {	            iStandardOffset = standardOffset;	        }	
public void setFixedSavings(String nameKey, int saveMillis) {	            iInitialNameKey = nameKey;	            iInitialSaveMillis = saveMillis;	        }	
public void addRule(Rule rule) {	            if (!iRules.contains(rule)) {	                iRules.add(rule);	            }	        }	
public void setUpperLimit(int year, OfYear ofYear) {	            iUpperYear = year;	            iUpperOfYear = ofYear;	        }	
/**	         * Returns a transition at firstMillis with the first name key and	         * offsets for this rule set. This method may return null.	         *	         * @param firstMillis millis of first transition	         */	        public Transition firstTransition(final long firstMillis) {	            if (iInitialNameKey != null) {	                // Initial zone info explicitly set, so don't search the rules.	                return new Transition(firstMillis, iInitialNameKey,	                                      iStandardOffset + iInitialSaveMillis, iStandardOffset);	            }		            // Make a copy before we destroy the rules.	            ArrayList<Rule> copy = new ArrayList<Rule>(iRules);		            // Iterate through all the transitions until firstMillis is	            // reached. Use the name key and savings for whatever rule reaches	            // the limit.		            long millis = Long.MIN_VALUE;	            int saveMillis = 0;	            Transition first = null;		            Transition next;	            while ((next = nextTransition(millis, saveMillis)) != null) {	                millis = next.getMillis();		                if (millis == firstMillis) {	                    first = new Transition(firstMillis, next);	                    break;	                }		                if (millis > firstMillis) {	                    if (first == null) {	                        // Find first rule without savings. This way a more	                        // accurate nameKey is found even though no rule	                        // extends to the RuleSet's lower limit.	                        for (Rule rule : copy) {	                            if (rule.getSaveMillis() == 0) {	                                first = new Transition(firstMillis, rule, iStandardOffset);	                                break;	                            }	                        }	                    }	                    if (first == null) {	                        // Found no rule without savings. Create a transition	                        // with no savings anyhow, and use the best available	                        // name key.	                        first = new Transition(firstMillis, next.getNameKey(),	                                               iStandardOffset, iStandardOffset);	                    }	                    break;	                }	                	                // Set first to the best transition found so far, but next	                // iteration may find something closer to lower limit.	                first = new Transition(firstMillis, next);		                saveMillis = next.getSaveMillis();	            }		            iRules = copy;	            return first;	        }	
/**	         * Returns null if RuleSet is exhausted or upper limit reached. Calling	         * this method will throw away rules as they each become	         * exhausted. Copy the RuleSet before using it to compute transitions.	         *	         * Returned transition may be a duplicate from previous	         * transition. Caller must call isTransitionFrom to filter out	         * duplicates.	         *	         * @param saveMillis savings before next transition	         */	        public Transition nextTransition(final long instant, final int saveMillis) {	            Chronology chrono = ISOChronology.getInstanceUTC();		            // Find next matching rule.	            Rule nextRule = null;	            long nextMillis = Long.MAX_VALUE;	            	            Iterator<Rule> it = iRules.iterator();	            while (it.hasNext()) {	                Rule rule = it.next();	                long next = rule.next(instant, iStandardOffset, saveMillis);	                if (next <= instant) {	                    it.remove();	                    continue;	                }	                // Even if next is same as previous next, choose the rule	                // in order for more recently added rules to override.	                if (next <= nextMillis) {	                    // Found a better match.	                    nextRule = rule;	                    nextMillis = next;	                }	            }	            	            if (nextRule == null) {	                return null;	            }	            	            // Stop precalculating if year reaches some arbitrary limit.	            if (chrono.year().get(nextMillis) >= YEAR_LIMIT) {	                return null;	            }	            	            // Check if upper limit reached or passed.	            if (iUpperYear < Integer.MAX_VALUE) {	                long upperMillis =	                    iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);	                if (nextMillis >= upperMillis) {	                    // At or after upper limit.	                    return null;	                }	            }	            	            return new Transition(nextMillis, nextRule, iStandardOffset);	        }	
/**	         * @param saveMillis savings before upper limit	         */	        public long getUpperLimit(int saveMillis) {	            if (iUpperYear == Integer.MAX_VALUE) {	                return Long.MAX_VALUE;	            }	            return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);	        }	
/**	         * Returns null if none can be built.	         */	        public DSTZone buildTailZone(String id) {	            if (iRules.size() == 2) {	                Rule startRule = iRules.get(0);	                Rule endRule = iRules.get(1);	                if (startRule.getToYear() == Integer.MAX_VALUE &&	                    endRule.getToYear() == Integer.MAX_VALUE) {		                    // With exactly two infinitely recurring rules left, a	                    // simple DSTZone can be formed.		                    // The order of rules can come in any order, and it doesn't	                    // really matter which rule was chosen the 'start' and	                    // which is chosen the 'end'. DSTZone works properly either	                    // way.	                    return new DSTZone(id, iStandardOffset,	                                       startRule.iRecurrence, endRule.iRecurrence);	                }	            }	            return null;	        }	
static DSTZone readFrom(DataInput in, String id) throws IOException {	            return new DSTZone(id, (int)readMillis(in), 	                               Recurrence.readFrom(in), Recurrence.readFrom(in));	        }	
DSTZone(String id, int standardOffset,	                Recurrence startRecurrence, Recurrence endRecurrence) {	            super(id);	            iStandardOffset = standardOffset;	            iStartRecurrence = startRecurrence;	            iEndRecurrence = endRecurrence;	        }	
public String getNameKey(long instant) {	            return findMatchingRecurrence(instant).getNameKey();	        }	
public int getOffset(long instant) {	            return iStandardOffset + findMatchingRecurrence(instant).getSaveMillis();	        }	
public int getStandardOffset(long instant) {	            return iStandardOffset;	        }	
public boolean isFixed() {	            return false;	        }	
public long nextTransition(long instant) {	            int standardOffset = iStandardOffset;	            Recurrence startRecurrence = iStartRecurrence;	            Recurrence endRecurrence = iEndRecurrence;		            long start, end;		            try {	                start = startRecurrence.next	                    (instant, standardOffset, endRecurrence.getSaveMillis());	                if (instant > 0 && start < 0) {	                    // Overflowed.	                    start = instant;	                }	            } catch (IllegalArgumentException e) {	                // Overflowed.	                start = instant;	            } catch (ArithmeticException e) {	                // Overflowed.	                start = instant;	            }		            try {	                end = endRecurrence.next	                    (instant, standardOffset, startRecurrence.getSaveMillis());	                if (instant > 0 && end < 0) {	                    // Overflowed.	                    end = instant;	                }	            } catch (IllegalArgumentException e) {	                // Overflowed.	                end = instant;	            } catch (ArithmeticException e) {	                // Overflowed.	                end = instant;	            }		            return (start > end) ? end : start;	        }	
public long previousTransition(long instant) {	            // Increment in order to handle the case where instant is exactly at	            // a transition.	            instant++;		            int standardOffset = iStandardOffset;	            Recurrence startRecurrence = iStartRecurrence;	            Recurrence endRecurrence = iEndRecurrence;		            long start, end;		            try {	                start = startRecurrence.previous	                    (instant, standardOffset, endRecurrence.getSaveMillis());	                if (instant < 0 && start > 0) {	                    // Overflowed.	                    start = instant;	                }	            } catch (IllegalArgumentException e) {	                // Overflowed.	                start = instant;	            } catch (ArithmeticException e) {	                // Overflowed.	                start = instant;	            }		            try {	                end = endRecurrence.previous	                    (instant, standardOffset, startRecurrence.getSaveMillis());	                if (instant < 0 && end > 0) {	                    // Overflowed.	                    end = instant;	                }	            } catch (IllegalArgumentException e) {	                // Overflowed.	                end = instant;	            } catch (ArithmeticException e) {	                // Overflowed.	                end = instant;	            }		            return ((start > end) ? start : end) - 1;	        }	
public boolean equals(Object obj) {	            if (this == obj) {	                return true;	            }	            if (obj instanceof DSTZone) {	                DSTZone other = (DSTZone)obj;	                return	                    getID().equals(other.getID()) &&	                    iStandardOffset == other.iStandardOffset &&	                    iStartRecurrence.equals(other.iStartRecurrence) &&	                    iEndRecurrence.equals(other.iEndRecurrence);	            }	            return false;	        }	
public void writeTo(DataOutput out) throws IOException {	            writeMillis(out, iStandardOffset);	            iStartRecurrence.writeTo(out);	            iEndRecurrence.writeTo(out);	        }	
private Recurrence findMatchingRecurrence(long instant) {	            int standardOffset = iStandardOffset;	            Recurrence startRecurrence = iStartRecurrence;	            Recurrence endRecurrence = iEndRecurrence;		            long start, end;		            try {	                start = startRecurrence.next	                    (instant, standardOffset, endRecurrence.getSaveMillis());	            } catch (IllegalArgumentException e) {	                // Overflowed.	                start = instant;	            } catch (ArithmeticException e) {	                // Overflowed.	                start = instant;	            }		            try {	                end = endRecurrence.next	                    (instant, standardOffset, startRecurrence.getSaveMillis());	            } catch (IllegalArgumentException e) {	                // Overflowed.	                end = instant;	            } catch (ArithmeticException e) {	                // Overflowed.	                end = instant;	            }		            return (start > end) ? startRecurrence : endRecurrence;	        }	
static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {	            // Read string pool.	            int poolSize = in.readUnsignedShort();	            String[] pool = new String[poolSize];	            for (int i=0; i<poolSize; i++) {	                pool[i] = in.readUTF();	            }		            int size = in.readInt();	            long[] transitions = new long[size];	            int[] wallOffsets = new int[size];	            int[] standardOffsets = new int[size];	            String[] nameKeys = new String[size];	            	            for (int i=0; i<size; i++) {	                transitions[i] = readMillis(in);	                wallOffsets[i] = (int)readMillis(in);	                standardOffsets[i] = (int)readMillis(in);	                try {	                    int index;	                    if (poolSize < 256) {	                        index = in.readUnsignedByte();	                    } else {	                        index = in.readUnsignedShort();	                    }	                    nameKeys[i] = pool[index];	                } catch (ArrayIndexOutOfBoundsException e) {	                    throw new IOException("Invalid encoding");	                }	            }		            DSTZone tailZone = null;	            if (in.readBoolean()) {	                tailZone = DSTZone.readFrom(in, id);	            }		            return new PrecalculatedZone	                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);	        }	
/**	         * Factory to create instance from builder.	         * 	         * @param id  the zone id	         * @param outputID  true if the zone id should be output	         * @param transitions  the list of Transition objects	         * @param tailZone  optional zone for getting info beyond precalculated tables	         */	        static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transition> transitions,	                                        DSTZone tailZone) {	            int size = transitions.size();	            if (size == 0) {	                throw new IllegalArgumentException();	            }		            long[] trans = new long[size];	            int[] wallOffsets = new int[size];	            int[] standardOffsets = new int[size];	            String[] nameKeys = new String[size];		            Transition last = null;	            for (int i=0; i<size; i++) {	                Transition tr = transitions.get(i);		                if (!tr.isTransitionFrom(last)) {	                    throw new IllegalArgumentException(id);	                }		                trans[i] = tr.getMillis();	                wallOffsets[i] = tr.getWallOffset();	                standardOffsets[i] = tr.getStandardOffset();	                nameKeys[i] = tr.getNameKey();		                last = tr;	            }		            // Some timezones (Australia) have the same name key for	            // summer and winter which messes everything up. Fix it here.	            String[] zoneNameData = new String[5];	            String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();	            for (int j = 0; j < zoneStrings.length; j++) {	                String[] set = zoneStrings[j];	                if (set != null && set.length == 5 && id.equals(set[0])) {	                    zoneNameData = set;	                }	            }		            Chronology chrono = ISOChronology.getInstanceUTC();		            for (int i = 0; i < nameKeys.length - 1; i++) {	                String curNameKey = nameKeys[i];	                String nextNameKey = nameKeys[i + 1];	                long curOffset = wallOffsets[i];	                long nextOffset = wallOffsets[i + 1];	                long curStdOffset = standardOffsets[i];	                long nextStdOffset = standardOffsets[i + 1];	                Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);	                if (curOffset != nextOffset &&	                        curStdOffset == nextStdOffset &&	                        curNameKey.equals(nextNameKey) &&	                        p.getYears() == 0 && p.getMonths() > 4 && p.getMonths() < 8 &&	                        curNameKey.equals(zoneNameData[2]) &&	                        curNameKey.equals(zoneNameData[4])) {	                    	                    if (ZoneInfoCompiler.verbose()) {	                        System.out.println("Fixing duplicate name key - " + nextNameKey);	                        System.out.println("     - " + new DateTime(trans[i], chrono) +	                                           " - " + new DateTime(trans[i + 1], chrono));	                    }	                    if (curOffset > nextOffset) {	                        nameKeys[i] = (curNameKey + "-Summer").intern();	                    } else if (curOffset < nextOffset) {	                        nameKeys[i + 1] = (nextNameKey + "-Summer").intern();	                        i++;	                    }	                }	            }		            if (tailZone != null) {	                if (tailZone.iStartRecurrence.getNameKey()	                    .equals(tailZone.iEndRecurrence.getNameKey())) {	                    if (ZoneInfoCompiler.verbose()) {	                        System.out.println("Fixing duplicate recurrent name key - " +	                                           tailZone.iStartRecurrence.getNameKey());	                    }	                    if (tailZone.iStartRecurrence.getSaveMillis() > 0) {	                        tailZone = new DSTZone(	                            tailZone.getID(),	                            tailZone.iStandardOffset,	                            tailZone.iStartRecurrence.renameAppend("-Summer"),	                            tailZone.iEndRecurrence);	                    } else {	                        tailZone = new DSTZone(	                            tailZone.getID(),	                            tailZone.iStandardOffset,	                            tailZone.iStartRecurrence,	                            tailZone.iEndRecurrence.renameAppend("-Summer"));	                    }	                }	            }	            	            return new PrecalculatedZone	                ((outputID ? id : ""), trans, wallOffsets, standardOffsets, nameKeys, tailZone);	        }	
/**	         * Constructor used ONLY for valid input, loaded via static methods.	         */	        private PrecalculatedZone(String id, long[] transitions, int[] wallOffsets,	                          int[] standardOffsets, String[] nameKeys, DSTZone tailZone)	        {	            super(id);	            iTransitions = transitions;	            iWallOffsets = wallOffsets;	            iStandardOffsets = standardOffsets;	            iNameKeys = nameKeys;	            iTailZone = tailZone;	        }	
public String getNameKey(long instant) {	            long[] transitions = iTransitions;	            int i = Arrays.binarySearch(transitions, instant);	            if (i >= 0) {	                return iNameKeys[i];	            }	            i = ~i;	            if (i < transitions.length) {	                if (i > 0) {	                    return iNameKeys[i - 1];	                }	                return "UTC";	            }	            if (iTailZone == null) {	                return iNameKeys[i - 1];	            }	            return iTailZone.getNameKey(instant);	        }	
public int getOffset(long instant) {	            long[] transitions = iTransitions;	            int i = Arrays.binarySearch(transitions, instant);	            if (i >= 0) {	                return iWallOffsets[i];	            }	            i = ~i;	            if (i < transitions.length) {	                if (i > 0) {	                    return iWallOffsets[i - 1];	                }	                return 0;	            }	            if (iTailZone == null) {	                return iWallOffsets[i - 1];	            }	            return iTailZone.getOffset(instant);	        }	
public int getStandardOffset(long instant) {	            long[] transitions = iTransitions;	            int i = Arrays.binarySearch(transitions, instant);	            if (i >= 0) {	                return iStandardOffsets[i];	            }	            i = ~i;	            if (i < transitions.length) {	                if (i > 0) {	                    return iStandardOffsets[i - 1];	                }	                return 0;	            }	            if (iTailZone == null) {	                return iStandardOffsets[i - 1];	            }	            return iTailZone.getStandardOffset(instant);	        }	
public boolean isFixed() {	            return false;	        }	
public long nextTransition(long instant) {	            long[] transitions = iTransitions;	            int i = Arrays.binarySearch(transitions, instant);	            i = (i >= 0) ? (i + 1) : ~i;	            if (i < transitions.length) {	                return transitions[i];	            }	            if (iTailZone == null) {	                return instant;	            }	            long end = transitions[transitions.length - 1];	            if (instant < end) {	                instant = end;	            }	            return iTailZone.nextTransition(instant);	        }	
public long previousTransition(long instant) {	            long[] transitions = iTransitions;	            int i = Arrays.binarySearch(transitions, instant);	            if (i >= 0) {	                if (instant > Long.MIN_VALUE) {	                    return instant - 1;	                }	                return instant;	            }	            i = ~i;	            if (i < transitions.length) {	                if (i > 0) {	                    long prev = transitions[i - 1];	                    if (prev > Long.MIN_VALUE) {	                        return prev - 1;	                    }	                }	                return instant;	            }	            if (iTailZone != null) {	                long prev = iTailZone.previousTransition(instant);	                if (prev < instant) {	                    return prev;	                }	            }	            long prev = transitions[i - 1];	            if (prev > Long.MIN_VALUE) {	                return prev - 1;	            }	            return instant;	        }	
public boolean equals(Object obj) {	            if (this == obj) {	                return true;	            }	            if (obj instanceof PrecalculatedZone) {	                PrecalculatedZone other = (PrecalculatedZone)obj;	                return	                    getID().equals(other.getID()) &&	                    Arrays.equals(iTransitions, other.iTransitions) &&	                    Arrays.equals(iNameKeys, other.iNameKeys) &&	                    Arrays.equals(iWallOffsets, other.iWallOffsets) &&	                    Arrays.equals(iStandardOffsets, other.iStandardOffsets) &&	                    ((iTailZone == null)	                     ? (null == other.iTailZone)	                     : (iTailZone.equals(other.iTailZone)));	            }	            return false;	        }	
public void writeTo(DataOutput out) throws IOException {	            int size = iTransitions.length;		            // Create unique string pool.	            Set<String> poolSet = new HashSet<String>();	            for (int i=0; i<size; i++) {	                poolSet.add(iNameKeys[i]);	            }		            int poolSize = poolSet.size();	            if (poolSize > 65535) {	                throw new UnsupportedOperationException("String pool is too large");	            }	            String[] pool = new String[poolSize];	            Iterator<String> it = poolSet.iterator();	            for (int i=0; it.hasNext(); i++) {	                pool[i] = it.next();	            }		            // Write out the pool.	            out.writeShort(poolSize);	            for (int i=0; i<poolSize; i++) {	                out.writeUTF(pool[i]);	            }		            out.writeInt(size);		            for (int i=0; i<size; i++) {	                writeMillis(out, iTransitions[i]);	                writeMillis(out, iWallOffsets[i]);	                writeMillis(out, iStandardOffsets[i]);	                	                // Find pool index and write it out.	                String nameKey = iNameKeys[i];	                for (int j=0; j<poolSize; j++) {	                    if (pool[j].equals(nameKey)) {	                        if (poolSize < 256) {	                            out.writeByte(j);	                        } else {	                            out.writeShort(j);	                        }	                        break;	                    }	                }	            }		            out.writeBoolean(iTailZone != null);	            if (iTailZone != null) {	                iTailZone.writeTo(out);	            }	        }	
public boolean isCachable() {	            if (iTailZone != null) {	                return true;	            }	            long[] transitions = iTransitions;	            if (transitions.length <= 1) {	                return false;	            }		            // Add up all the distances between transitions that are less than	            // about two years.	            double distances = 0;	            int count = 0;		            for (int i=1; i<transitions.length; i++) {	                long diff = transitions[i] - transitions[i - 1];	                if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) {	                    distances += (double)diff;	                    count++;	                }	            }		            if (count > 0) {	                double avg = distances / count;	                avg /= 24 * 60 * 60 * 1000;	                if (avg >= 25) {	                    // Only bother caching if average distance between	                    // transitions is at least 25 days. Why 25?	                    // CachedDateTimeZone is more efficient if the distance	                    // between transitions is large. With an average of 25, it	                    // will on average perform about 2 tests per cache	                    // hit. (49.7 / 25) is approximately 2.	                    return true;	                }	            }		            return false;	        }	
/**	     * Gets a flag indicating that verbose logging is required.	     * @return true to log verbosely	     */	    public static boolean verbose() {	        return cVerbose.get();	    }	
/**	     * Launches the ZoneInfoCompiler tool.	     *	     * <pre>	     * Usage: java org.joda.time.tz.ZoneInfoCompiler &lt;options&gt; &lt;source files&gt;	     * where possible options include:	     *   -src &lt;directory&gt;    Specify where to read source files	     *   -dst &lt;directory&gt;    Specify where to write generated files	     *   -verbose            Output verbosely (default false)	     * </pre>	     */	    public static void main(String[] args) throws Exception {	        if (args.length == 0) {	            printUsage();	            return;	        }		        File inputDir = null;	        File outputDir = null;	        boolean verbose = false;		        int i;	        for (i=0; i<args.length; i++) {	            try {	                if ("-src".equals(args[i])) {	                    inputDir = new File(args[++i]);	                } else if ("-dst".equals(args[i])) {	                    outputDir = new File(args[++i]);	                } else if ("-verbose".equals(args[i])) {	                    verbose = true;	                } else if ("-?".equals(args[i])) {	                    printUsage();	                    return;	                } else {	                    break;	                }	            } catch (IndexOutOfBoundsException e) {	                printUsage();	                return;	            }	        }		        if (i >= args.length) {	            printUsage();	            return;	        }		        File[] sources = new File[args.length - i];	        for (int j=0; i<args.length; i++,j++) {	            sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]);	        }		        cVerbose.set(verbose);	        ZoneInfoCompiler zic = new ZoneInfoCompiler();	        zic.compile(outputDir, sources);	    }	
private static void printUsage() {	        System.out.println("Usage: java org.joda.time.tz.ZoneInfoCompiler <options> <source files>");	        System.out.println("where possible options include:");	        System.out.println("  -src <directory>    Specify where to read source files");	        System.out.println("  -dst <directory>    Specify where to write generated files");	        System.out.println("  -verbose            Output verbosely (default false)");	    }	
static DateTimeOfYear getStartOfYear() {	        if (cStartOfYear == null) {	            cStartOfYear = new DateTimeOfYear();	        }	        return cStartOfYear;	    }	
static Chronology getLenientISOChronology() {	        if (cLenientISO == null) {	            cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC());	        }	        return cLenientISO;	    }	
/**	     * @param zimap maps string ids to DateTimeZone objects.	     */	    static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException {	        // Build the string pool.	        Map<String, Short> idToIndex = new HashMap<String, Short>(zimap.size());	        TreeMap<Short, String> indexToId = new TreeMap<Short, String>();		        short count = 0;	        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {	            String id = (String)entry.getKey();	            if (!idToIndex.containsKey(id)) {	                Short index = Short.valueOf(count);	                idToIndex.put(id, index);	                indexToId.put(index, id);	                if (++count == 0) {	                    throw new InternalError("Too many time zone ids");	                }	            }	            id = ((DateTimeZone)entry.getValue()).getID();	            if (!idToIndex.containsKey(id)) {	                Short index = Short.valueOf(count);	                idToIndex.put(id, index);	                indexToId.put(index, id);	                if (++count == 0) {	                    throw new InternalError("Too many time zone ids");	                }	            }	        }		        // Write the string pool, ordered by index.	        dout.writeShort(indexToId.size());	        for (String id : indexToId.values()) {	            dout.writeUTF(id);	        }		        // Write the mappings.	        dout.writeShort(zimap.size());	        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {	            String id = entry.getKey();	            dout.writeShort(idToIndex.get(id).shortValue());	            id = entry.getValue().getID();	            dout.writeShort(idToIndex.get(id).shortValue());	        }	    }	
static int parseYear(String str, int def) {	        str = str.toLowerCase();	        if (str.equals("minimum") || str.equals("min")) {	            return Integer.MIN_VALUE;	        } else if (str.equals("maximum") || str.equals("max")) {	            return Integer.MAX_VALUE;	        } else if (str.equals("only")) {	            return def;	        }	        return Integer.parseInt(str);	    }	
static int parseMonth(String str) {	        DateTimeField field = ISOChronology.getInstanceUTC().monthOfYear();	        return field.get(field.set(0, str, Locale.ENGLISH));	    }	
static int parseDayOfWeek(String str) {	        DateTimeField field = ISOChronology.getInstanceUTC().dayOfWeek();	        return field.get(field.set(0, str, Locale.ENGLISH));	    }	
static String parseOptional(String str) {	        return (str.equals("-")) ? null : str;	    }	
static int parseTime(String str) {	        DateTimeFormatter p = ISODateTimeFormat.hourMinuteSecondFraction();	        MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());	        int pos = 0;	        if (str.startsWith("-")) {	            pos = 1;	        }	        int newPos = p.parseInto(mdt, str, pos);	        if (newPos == ~pos) {	            throw new IllegalArgumentException(str);	        }	        int millis = (int)mdt.getMillis();	        if (pos == 1) {	            millis = -millis;	        }	        return millis;	    }	
static char parseZoneChar(char c) {	        switch (c) {	        case 's': case 'S':	            // Standard time	            return 's';	        case 'u': case 'U': case 'g': case 'G': case 'z': case 'Z':	            // UTC	            return 'u';	        case 'w': case 'W': default:	            // Wall time	            return 'w';	        }	    }	
/**	     * @return false if error.	     */	    static boolean test(String id, DateTimeZone tz) {	        if (!id.equals(tz.getID())) {	            return true;	        }		        // Test to ensure that reported transitions are not duplicated.		        long millis = ISOChronology.getInstanceUTC().year().set(0, 1850);	        long end = ISOChronology.getInstanceUTC().year().set(0, 2050);		        int offset = tz.getOffset(millis);	        String key = tz.getNameKey(millis);		        List<Long> transitions = new ArrayList<Long>();		        while (true) {	            long next = tz.nextTransition(millis);	            if (next == millis || next > end) {	                break;	            }		            millis = next;		            int nextOffset = tz.getOffset(millis);	            String nextKey = tz.getNameKey(millis);		            if (offset == nextOffset	                && key.equals(nextKey)) {	                System.out.println("*d* Error in " + tz.getID() + " "	                                   + new DateTime(millis,	                                                  ISOChronology.getInstanceUTC()));	                return false;	            }		            if (nextKey == null || (nextKey.length() < 3 && !"??".equals(nextKey))) {	                System.out.println("*s* Error in " + tz.getID() + " "	                                   + new DateTime(millis,	                                                  ISOChronology.getInstanceUTC())	                                   + ", nameKey=" + nextKey);	                return false;	            }		            transitions.add(Long.valueOf(millis));		            offset = nextOffset;	            key = nextKey;	        }		        // Now verify that reverse transitions match up.		        millis = ISOChronology.getInstanceUTC().year().set(0, 2050);	        end = ISOChronology.getInstanceUTC().year().set(0, 1850);		        for (int i=transitions.size(); --i>= 0; ) {	            long prev = tz.previousTransition(millis);	            if (prev == millis || prev < end) {	                break;	            }		            millis = prev;		            long trans = transitions.get(i).longValue();	            	            if (trans - 1 != millis) {	                System.out.println("*r* Error in " + tz.getID() + " "	                                   + new DateTime(millis,	                                                  ISOChronology.getInstanceUTC()) + " != "	                                   + new DateTime(trans - 1,	                                                  ISOChronology.getInstanceUTC()));	                                   	                return false;	            }	        }		        return true;	    }	
public ZoneInfoCompiler() {	        iRuleSets = new HashMap<String, RuleSet>();	        iZones = new ArrayList<Zone>();	        iLinks = new ArrayList<String>();	    }	
/**	     * Returns a map of ids to DateTimeZones.	     *	     * @param outputDir optional directory to write compiled data files to	     * @param sources optional list of source files to parse	     */	    public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException {	        if (sources != null) {	            for (int i=0; i<sources.length; i++) {	                BufferedReader in = new BufferedReader(new FileReader(sources[i]));	                parseDataFile(in);	                in.close();	            }	        }		        if (outputDir != null) {	            if (!outputDir.exists()) {	                throw new IOException("Destination directory doesn't exist: " + outputDir);	            }	            if (!outputDir.isDirectory()) {	                throw new IOException("Destination is not a directory: " + outputDir);	            }	        }		        Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();		        System.out.println("Writing zoneinfo files");	        for (int i=0; i<iZones.size(); i++) {	            Zone zone = iZones.get(i);	            DateTimeZoneBuilder builder = new DateTimeZoneBuilder();	            zone.addToBuilder(builder, iRuleSets);	            final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);	            DateTimeZone tz = original;	            if (test(tz.getID(), tz)) {	                map.put(tz.getID(), tz);	                if (outputDir != null) {	                    if (ZoneInfoCompiler.verbose()) {	                        System.out.println("Writing " + tz.getID());	                    }	                    File file = new File(outputDir, tz.getID());	                    if (!file.getParentFile().exists()) {	                        file.getParentFile().mkdirs();	                    }	                    OutputStream out = new FileOutputStream(file);	                    builder.writeTo(zone.iName, out);	                    out.close();		                    // Test if it can be read back.	                    InputStream in = new FileInputStream(file);	                    DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID());	                    in.close();		                    if (!original.equals(tz2)) {	                        System.out.println("*e* Error in " + tz.getID() +	                                           ": Didn't read properly from file");	                    }	                }	            }	        }		        for (int pass=0; pass<2; pass++) {	            for (int i=0; i<iLinks.size(); i += 2) {	                String id = iLinks.get(i);	                String alias = iLinks.get(i + 1);	                DateTimeZone tz = map.get(id);	                if (tz == null) {	                    if (pass > 0) {	                        System.out.println("Cannot find time zone '" + id +	                                           "' to link alias '" + alias + "' to");	                    }	                } else {	                    map.put(alias, tz);	                }	            }	        }		        if (outputDir != null) {	            System.out.println("Writing ZoneInfoMap");	            File file = new File(outputDir, "ZoneInfoMap");	            if (!file.getParentFile().exists()) {	                file.getParentFile().mkdirs();	            }		            OutputStream out = new FileOutputStream(file);	            DataOutputStream dout = new DataOutputStream(out);	            // Sort and filter out any duplicates that match case.	            Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);	            zimap.putAll(map);	            writeZoneInfoMap(dout, zimap);	            dout.close();	        }		        return map;	    }	
public void parseDataFile(BufferedReader in) throws IOException {	        Zone zone = null;	        String line;	        while ((line = in.readLine()) != null) {	            String trimmed = line.trim();	            if (trimmed.length() == 0 || trimmed.charAt(0) == '#') {	                continue;	            }		            int index = line.indexOf('#');	            if (index >= 0) {	                line = line.substring(0, index);	            }		            //System.out.println(line);		            StringTokenizer st = new StringTokenizer(line, " \t");		            if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) {	                if (zone != null) {	                    // Zone continuation	                    zone.chain(st);	                }	                continue;	            } else {	                if (zone != null) {	                    iZones.add(zone);	                }	                zone = null;	            }		            if (st.hasMoreTokens()) {	                String token = st.nextToken();	                if (token.equalsIgnoreCase("Rule")) {	                    Rule r = new Rule(st);	                    RuleSet rs = iRuleSets.get(r.iName);	                    if (rs == null) {	                        rs = new RuleSet(r);	                        iRuleSets.put(r.iName, rs);	                    } else {	                        rs.addRule(r);	                    }	                } else if (token.equalsIgnoreCase("Zone")) {	                    zone = new Zone(st);	                } else if (token.equalsIgnoreCase("Link")) {	                    iLinks.add(st.nextToken());	                    iLinks.add(st.nextToken());	                } else {	                    System.out.println("Unknown line: " + line);	                }	            }	        }		        if (zone != null) {	            iZones.add(zone);	        }	    }	
DateTimeOfYear() {	            iMonthOfYear = 1;	            iDayOfMonth = 1;	            iDayOfWeek = 0;	            iAdvanceDayOfWeek = false;	            iMillisOfDay = 0;	            iZoneChar = 'w';	        }	
DateTimeOfYear(StringTokenizer st) {	            int month = 1;	            int day = 1;	            int dayOfWeek = 0;	            int millis = 0;	            boolean advance = false;	            char zoneChar = 'w';		            if (st.hasMoreTokens()) {	                month = parseMonth(st.nextToken());		                if (st.hasMoreTokens()) {	                    String str = st.nextToken();	                    if (str.startsWith("last")) {	                        day = -1;	                        dayOfWeek = parseDayOfWeek(str.substring(4));	                        advance = false;	                    } else {	                        try {	                            day = Integer.parseInt(str);	                            dayOfWeek = 0;	                            advance = false;	                        } catch (NumberFormatException e) {	                            int index = str.indexOf(">=");	                            if (index > 0) {	                                day = Integer.parseInt(str.substring(index + 2));	                                dayOfWeek = parseDayOfWeek(str.substring(0, index));	                                advance = true;	                            } else {	                                index = str.indexOf("<=");	                                if (index > 0) {	                                    day = Integer.parseInt(str.substring(index + 2));	                                    dayOfWeek = parseDayOfWeek(str.substring(0, index));	                                    advance = false;	                                } else {	                                    throw new IllegalArgumentException(str);	                                }	                            }	                        }	                    }		                    if (st.hasMoreTokens()) {	                        str = st.nextToken();	                        zoneChar = parseZoneChar(str.charAt(str.length() - 1));	                        if (str.equals("24:00")) {	                            LocalDate date = (day == -1 ?	                                    new LocalDate(2001, month, 1).plusMonths(1) :	                                    new LocalDate(2001, month, day).plusDays(1));	                            advance = (day != -1);	                            month = date.getMonthOfYear();	                            day = date.getDayOfMonth();	                            dayOfWeek = ((dayOfWeek - 1 + 1) % 7) + 1;	                        } else {	                            millis = parseTime(str);	                        }	                    }	                }	            }		            iMonthOfYear = month;	            iDayOfMonth = day;	            iDayOfWeek = dayOfWeek;	            iAdvanceDayOfWeek = advance;	            iMillisOfDay = millis;	            iZoneChar = zoneChar;	        }	
/**	         * Adds a recurring savings rule to the builder.	         */	        public void addRecurring(DateTimeZoneBuilder builder, String nameKey,	                                 int saveMillis, int fromYear, int toYear)	        {	            builder.addRecurringSavings(nameKey, saveMillis,	                                        fromYear, toYear,	                                        iZoneChar,	                                        iMonthOfYear,	                                        iDayOfMonth,	                                        iDayOfWeek,	                                        iAdvanceDayOfWeek,	                                        iMillisOfDay);	        }	
/**	         * Adds a cutover to the builder.	         */	        public void addCutover(DateTimeZoneBuilder builder, int year) {	            builder.addCutover(year,	                               iZoneChar,	                               iMonthOfYear,	                               iDayOfMonth,	                               iDayOfWeek,	                               iAdvanceDayOfWeek,	                               iMillisOfDay);	        }	
public String toString() {	            return	                "MonthOfYear: " + iMonthOfYear + "\n" +	                "DayOfMonth: " + iDayOfMonth + "\n" +	                "DayOfWeek: " + iDayOfWeek + "\n" +	                "AdvanceDayOfWeek: " + iAdvanceDayOfWeek + "\n" +	                "MillisOfDay: " + iMillisOfDay + "\n" +	                "ZoneChar: " + iZoneChar + "\n";	        }	
Rule(StringTokenizer st) {	            iName = st.nextToken().intern();	            iFromYear = parseYear(st.nextToken(), 0);	            iToYear = parseYear(st.nextToken(), iFromYear);	            if (iToYear < iFromYear) {	                throw new IllegalArgumentException();	            }	            iType = parseOptional(st.nextToken());	            iDateTimeOfYear = new DateTimeOfYear(st);	            iSaveMillis = parseTime(st.nextToken());	            iLetterS = parseOptional(st.nextToken());	        }	
/**	         * Adds a recurring savings rule to the builder.	         */	        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {	            String nameKey = formatName(nameFormat);	            iDateTimeOfYear.addRecurring	                (builder, nameKey, iSaveMillis, iFromYear, iToYear);	        }	
private String formatName(String nameFormat) {	            int index = nameFormat.indexOf('/');	            if (index > 0) {	                if (iSaveMillis == 0) {	                    // Extract standard name.	                    return nameFormat.substring(0, index).intern();	                } else {	                    return nameFormat.substring(index + 1).intern();	                }	            }	            index = nameFormat.indexOf("%s");	            if (index < 0) {	                return nameFormat;	            }	            String left = nameFormat.substring(0, index);	            String right = nameFormat.substring(index + 2);	            String name;	            if (iLetterS == null) {	                name = left.concat(right);	            } else {	                name = left + iLetterS + right;	            }	            return name.intern();	        }	
public String toString() {	            return	                "[Rule]\n" + 	                "Name: " + iName + "\n" +	                "FromYear: " + iFromYear + "\n" +	                "ToYear: " + iToYear + "\n" +	                "Type: " + iType + "\n" +	                iDateTimeOfYear +	                "SaveMillis: " + iSaveMillis + "\n" +	                "LetterS: " + iLetterS + "\n";	        }	
RuleSet(Rule rule) {	            iRules = new ArrayList<Rule>();	            iRules.add(rule);	        }	
void addRule(Rule rule) {	            if (!(rule.iName.equals(iRules.get(0).iName))) {	                throw new IllegalArgumentException("Rule name mismatch");	            }	            iRules.add(rule);	        }	
/**	         * Adds recurring savings rules to the builder.	         */	        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {	            for (int i=0; i<iRules.size(); i++) {	                Rule rule = iRules.get(i);	                rule.addRecurring(builder, nameFormat);	            }	        }	
Zone(StringTokenizer st) {	            this(st.nextToken(), st);	        }	
private Zone(String name, StringTokenizer st) {	            iName = name.intern();	            iOffsetMillis = parseTime(st.nextToken());	            iRules = parseOptional(st.nextToken());	            iFormat = st.nextToken().intern();		            int year = Integer.MAX_VALUE;	            DateTimeOfYear dtOfYear = getStartOfYear();		            if (st.hasMoreTokens()) {	                year = Integer.parseInt(st.nextToken());	                if (st.hasMoreTokens()) {	                    dtOfYear = new DateTimeOfYear(st);	                }	            }		            iUntilYear = year;	            iUntilDateTimeOfYear = dtOfYear;	        }	
void chain(StringTokenizer st) {	            if (iNext != null) {	                iNext.chain(st);	            } else {	                iNext = new Zone(iName, st);	            }	        }	
/**	         * Adds zone info to the builder.	         */	        public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) {	            addToBuilder(this, builder, ruleSets);	        }	
private static void addToBuilder(Zone zone,	                                         DateTimeZoneBuilder builder,	                                         Map<String, RuleSet> ruleSets)	        {	            for (; zone != null; zone = zone.iNext) {	                builder.setStandardOffset(zone.iOffsetMillis);		                if (zone.iRules == null) {	                    builder.setFixedSavings(zone.iFormat, 0);	                } else {	                    try {	                        // Check if iRules actually just refers to a savings.	                        int saveMillis = parseTime(zone.iRules);	                        builder.setFixedSavings(zone.iFormat, saveMillis);	                    }	                    catch (Exception e) {	                        RuleSet rs = ruleSets.get(zone.iRules);	                        if (rs == null) {	                            throw new IllegalArgumentException	                                ("Rules not found: " + zone.iRules);	                        }	                        rs.addRecurring(builder, zone.iFormat);	                    }	                }		                if (zone.iUntilYear == Integer.MAX_VALUE) {	                    break;	                }		                zone.iUntilDateTimeOfYear.addCutover(builder, zone.iUntilYear);	            }	        }	
public String toString() {	            String str =	                "[Zone]\n" + 	                "Name: " + iName + "\n" +	                "OffsetMillis: " + iOffsetMillis + "\n" +	                "Rules: " + iRules + "\n" +	                "Format: " + iFormat + "\n" +	                "UntilYear: " + iUntilYear + "\n" +	                iUntilDateTimeOfYear;		            if (iNext == null) {	                return str;	            }		            return str + "...\n" + iNext.toString();	        }	
/**	     * ZoneInfoProvider searches the given directory for compiled data files.	     *	     * @throws IOException if directory or map file cannot be read	     */	    public ZoneInfoProvider(File fileDir) throws IOException {	        if (fileDir == null) {	            throw new IllegalArgumentException("No file directory provided");	        }	        if (!fileDir.exists()) {	            throw new IOException("File directory doesn't exist: " + fileDir);	        }	        if (!fileDir.isDirectory()) {	            throw new IOException("File doesn't refer to a directory: " + fileDir);	        }		        iFileDir = fileDir;	        iResourcePath = null;	        iLoader = null;		        iZoneInfoMap = loadZoneInfoMap(openResource("ZoneInfoMap"));	    }	
/**	     * ZoneInfoProvider searches the given ClassLoader resource path for	     * compiled data files. Resources are loaded from the ClassLoader that	     * loaded this class.	     *	     * @throws IOException if directory or map file cannot be read	     */	    public ZoneInfoProvider(String resourcePath) throws IOException {	        this(resourcePath, null, false);	    }	
/**	     * ZoneInfoProvider searches the given ClassLoader resource path for	     * compiled data files.	     *	     * @param loader ClassLoader to load compiled data files from. If null,	     * use system ClassLoader.	     * @throws IOException if directory or map file cannot be read	     */	    public ZoneInfoProvider(String resourcePath, ClassLoader loader)	        throws IOException	    {	        this(resourcePath, loader, true);	    }	
/**	     * @param favorSystemLoader when true, use the system class loader if	     * loader null. When false, use the current class loader if loader is null.	     */	    private ZoneInfoProvider(String resourcePath,	                             ClassLoader loader, boolean favorSystemLoader) 	        throws IOException	    {	        if (resourcePath == null) {	            throw new IllegalArgumentException("No resource path provided");	        }	        if (!resourcePath.endsWith("/")) {	            resourcePath += '/';	        }		        iFileDir = null;	        iResourcePath = resourcePath;		        if (loader == null && !favorSystemLoader) {	            loader = getClass().getClassLoader();	        }		        iLoader = loader;		        iZoneInfoMap = loadZoneInfoMap(openResource("ZoneInfoMap"));	    }	
/**	     * If an error is thrown while loading zone data, uncaughtException is	     * called to log the error and null is returned for this and all future	     * requests.	     * 	     * @param id  the id to load	     * @return the loaded zone	     */	    public DateTimeZone getZone(String id) {	        if (id == null) {	            return null;	        }		        Object obj = iZoneInfoMap.get(id);	        if (obj == null) {	            return null;	        }		        if (id.equals(obj)) {	            // Load zone data for the first time.	            return loadZoneData(id);	        }		        if (obj instanceof SoftReference<?>) {	            @SuppressWarnings("unchecked")	            SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;	            DateTimeZone tz = ref.get();	            if (tz != null) {	                return tz;	            }	            // Reference cleared; load data again.	            return loadZoneData(id);	        }		        // If this point is reached, mapping must link to another.	        return getZone((String)obj);	    }	
/**	     * Gets a list of all the available zone ids.	     * 	     * @return the zone ids	     */	    public Set<String> getAvailableIDs() {	        // Return a copy of the keys rather than an umodifiable collection.	        // This prevents ConcurrentModificationExceptions from being thrown by	        // some JVMs if zones are opened while this set is iterated over.	        return new TreeSet<String>(iZoneInfoMap.keySet());	    }	
/**	     * Called if an exception is thrown from getZone while loading zone data.	     * 	     * @param ex  the exception	     */	    protected void uncaughtException(Exception ex) {	        Thread t = Thread.currentThread();	        t.getThreadGroup().uncaughtException(t, ex);	    }	
/**	     * Opens a resource from file or classpath.	     * 	     * @param name  the name to open	     * @return the input stream	     * @throws IOException if an error occurs	     */	    private InputStream openResource(String name) throws IOException {	        InputStream in;	        if (iFileDir != null) {	            in = new FileInputStream(new File(iFileDir, name));	        } else {	            String path = iResourcePath.concat(name);	            if (iLoader != null) {	                in = iLoader.getResourceAsStream(path);	            } else {	                in = ClassLoader.getSystemResourceAsStream(path);	            }	            if (in == null) {	                StringBuffer buf = new StringBuffer(40)	                    .append("Resource not found: \"")	                    .append(path)	                    .append("\" ClassLoader: ")	                    .append(iLoader != null ? iLoader.toString() : "system");	                throw new IOException(buf.toString());	            }	        }	        return in;	    }	
/**	     * Loads the time zone data for one id.	     * 	     * @param id  the id to load	     * @return the zone	     */	    private DateTimeZone loadZoneData(String id) {	        InputStream in = null;	        try {	            in = openResource(id);	            DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);	            iZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));	            return tz;	        } catch (IOException e) {	            uncaughtException(e);	            iZoneInfoMap.remove(id);	            return null;	        } finally {	            try {	                if (in != null) {	                    in.close();	                }	            } catch (IOException e) {	            }	        }	    }	
/**	     * Loads the zone info map.	     * 	     * @param in  the input stream	     * @return the map	     */	    private static Map<String, Object> loadZoneInfoMap(InputStream in) throws IOException {	        Map<String, Object> map = new ConcurrentHashMap<String, Object>();	        DataInputStream din = new DataInputStream(in);	        try {	            readZoneInfoMap(din, map);	        } finally {	            try {	                din.close();	            } catch (IOException e) {	            }	        }	        map.put("UTC", new SoftReference<DateTimeZone>(DateTimeZone.UTC));	        return map;	    }	
/**	     * Reads the zone info map from file.	     * 	     * @param din  the input stream	     * @param zimap  gets filled with string id to string id mappings	     */	    private static void readZoneInfoMap(DataInputStream din, Map<String, Object> zimap) throws IOException {	        // Read the string pool.	        int size = din.readUnsignedShort();	        String[] pool = new String[size];	        for (int i=0; i<size; i++) {	            pool[i] = din.readUTF().intern();	        }		        // Read the mappings.	        size = din.readUnsignedShort();	        for (int i=0; i<size; i++) {	            try {	                zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]);	            } catch (ArrayIndexOutOfBoundsException e) {	                throw new IOException("Corrupt zone info map");	            }	        }	    }	
public DefaultNameProvider() {	    }	
public String getShortName(Locale locale, String id, String nameKey) {	        String[] nameSet = getNameSet(locale, id, nameKey);	        return nameSet == null ? null : nameSet[0];	    }	
public String getName(Locale locale, String id, String nameKey) {	        String[] nameSet = getNameSet(locale, id, nameKey);	        return nameSet == null ? null : nameSet[1];	    }	
private synchronized String[] getNameSet(Locale locale, String id, String nameKey) {	        if (locale == null || id == null || nameKey == null) {	            return null;	        }		        Map<String, Map<String, Object>> byIdCache = iByLocaleCache.get(locale);	        if (byIdCache == null) {	            iByLocaleCache.put(locale, byIdCache = createCache());	        }		        Map<String, Object> byNameKeyCache = byIdCache.get(id);	        if (byNameKeyCache == null) {	            byIdCache.put(id, byNameKeyCache = createCache());	            String[][] zoneStrings = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();	            for (int i=0; i<zoneStrings.length; i++) {	                String[] set = zoneStrings[i];	                if (set != null && set.length == 5 && id.equals(set[0])) {	                    byNameKeyCache.put(set[2], new String[] {set[2], set[1]});	                    // need to handle case where summer and winter have the same	                    // abbreviation, such as EST in Australia [1716305]	                    // we handle this by appending "-Summer", cf ZoneInfoCompiler	                    if (set[2].equals(set[4])) {	                        byNameKeyCache.put(set[4] + "-Summer", new String[] {set[4], set[3]});	                    } else {	                        byNameKeyCache.put(set[4], new String[] {set[4], set[3]});	                    }	                    break;	                }	            }	        }		        return (String[])byNameKeyCache.get(nameKey);	    }	
private HashMap createCache() {	        return new HashMap(7);	    }	
